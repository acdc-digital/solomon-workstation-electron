{"version":3,"file":"vendors.ascii85.chunk.js","sources":["webpack:///vendors.ascii85.chunk.js","webpack:///./node_modules/ascii85/index.js"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[17],{\n\n/***/ 531:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n\n// Buffer api is changed since v6.0.0. this wrapper is designed to leverage new\n// api features if possible without breaking old node.\n//\n// it's not a completed polyfill implementation. i just do necessary shims for this\n// package only.\nvar _BufferFrom = Buffer.from || function() {\n  switch (arguments.length) {\n    case 1: return new Buffer(arguments[0]);\n    case 2: return new Buffer(arguments[0], arguments[1]);\n    case 3: return new Buffer(arguments[0], arguments[1], arguments[2]);\n    default: throw new Exception('unexpected call.');\n  }\n};\nvar _BufferAlloc = Buffer.alloc || function(size, fill, encoding) {\n  var buf = new Buffer(size);\n\n  if (fill !== undefined) {\n    if (typeof encoding === \"string\") {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n  }\n\n  return buf;\n};\nvar _BufferAllocUnsafe = Buffer.allocUnsafe || function(size) {\n  return new Buffer(size);\n};\nvar _NewUint8Array = (function() {\n  if (typeof Uint8Array === 'undefined') {\n    return function(size) {\n      return new Array(size);\n    };\n  } else {\n    return function(size) {\n      return new Uint8Array(size);\n    }\n  }\n})();\n\nvar ASCII85_BASE = 85;\nvar ASCII85_CODE_START = 33;\nvar ASCII85_CODE_END = ASCII85_CODE_START + ASCII85_BASE;\nvar ASCII85_NULL = String.fromCharCode(0);\nvar ASCII85_NULL_STRING = ASCII85_NULL + ASCII85_NULL + ASCII85_NULL + ASCII85_NULL;\nvar ASCII85_ZERO = 'z';\nvar ASCII85_ZERO_VALUE = ASCII85_ZERO.charCodeAt(0);\nvar ASCII85_PADDING_VALUE = 'u'.charCodeAt(0);\nvar ASCII85_ENCODING_GROUP_LENGTH = 4;\nvar ASCII85_DECODING_GROUP_LENGTH = 5;\nvar ASCII85_BLOCK_START = '<~';\nvar ASCII85_BLOCK_START_LENGTH = ASCII85_BLOCK_START.length;\nvar ASCII85_BLOCK_START_VALUE = _BufferFrom(ASCII85_BLOCK_START).readUInt16BE(0);\nvar ASCII85_BLOCK_END = '~>';\nvar ASCII85_BLOCK_END_LENGTH = ASCII85_BLOCK_END.length;\nvar ASCII85_BLOCK_END_VALUE = _BufferFrom(ASCII85_BLOCK_END).readUInt16BE(0);\nvar ASCII85_GROUP_SPACE = 'y';\nvar ASCII85_GROUP_SPACE_VALUE = ASCII85_GROUP_SPACE.charCodeAt(0);\nvar ASCII85_GROUP_SPACE_CODE = 0x20202020;\nvar ASCII85_GROUP_SPACE_STRING = '    ';\n\nvar ASCII85_DEFAULT_ENCODING_TABLE = (function() {\n  var arr = new Array(ASCII85_BASE);\n  var i;\n\n  for (i = 0; i < ASCII85_BASE; i++) {\n    arr[i] = String.fromCharCode(ASCII85_CODE_START + i);\n  }\n\n  return arr;\n})();\n\nvar ASCII85_DEFAULT_DECODING_TABLE = (function() {\n  var arr = new Array(1 << 8);\n  var i;\n\n  for (i = 0; i < ASCII85_BASE; i++) {\n    arr[ASCII85_CODE_START + i] = i;\n  }\n\n  return arr;\n})();\n\n\nfunction Ascii85(options) {\n  var decodingTable;\n\n  options = options || {};\n  this._options = options;\n\n  // generate encoding and decoding table.\n  if (Array.isArray(options.table)) {\n    decodingTable = [];\n    options.table.forEach(function(v, i) {\n      decodingTable[v.charCodeAt(0)] = i;\n    });\n\n    options.encodingTable = options.table;\n    options.decodingTable = decodingTable;\n  }\n}\n\nvar defaultCodec = module.exports = new Ascii85();\n\n\nAscii85.prototype.encode = function(data, options) {\n  var bytes = _NewUint8Array(5);\n  var buf = data;\n  var defOptions = this._options;\n  var output, offset, table, delimiter, groupSpace, digits, cur, i, j, r, b, len, padding;\n\n  if (typeof buf === \"string\") {\n    buf = _BufferFrom(buf, 'binary');\n  } else if (!(buf instanceof Buffer)) {\n    buf = _BufferFrom(buf);\n  }\n\n  // prepare options.\n  options = options || {};\n\n  if (Array.isArray(options)) {\n    table = options;\n    delimiter = defOptions.delimiter || false;\n    groupSpace = defOptions.groupSpace || false;\n  } else {\n    table = options.table || defOptions.encodingTable || ASCII85_DEFAULT_ENCODING_TABLE;\n\n    if (options.delimiter === undefined) {\n      delimiter = defOptions.delimiter || false;\n    } else {\n      delimiter = !!options.delimiter;\n    }\n\n    if (options.groupSpace === undefined) {\n      groupSpace = defOptions.groupSpace || false;\n    } else {\n      groupSpace = !!options.groupSpace;\n    }\n  }\n\n  // estimate output length and alloc buffer for it.\n  offset = 0;\n  len = Math.ceil(buf.length * ASCII85_DECODING_GROUP_LENGTH / ASCII85_ENCODING_GROUP_LENGTH) +\n        ASCII85_ENCODING_GROUP_LENGTH +\n        (delimiter? ASCII85_BLOCK_START_LENGTH + ASCII85_BLOCK_END_LENGTH: 0);\n  output = _BufferAllocUnsafe(len);\n\n  if (delimiter) {\n    offset += output.write(ASCII85_BLOCK_START, offset);\n  }\n\n  // iterate over all data bytes.\n  for (i = digits = cur = 0, len = buf.length; i < len; i++) {\n    b = buf.readUInt8(i);\n\n    cur *= 1 << 8;\n    cur += b;\n    digits++;\n\n    if (digits % ASCII85_ENCODING_GROUP_LENGTH) {\n      continue;\n    }\n\n    if (groupSpace && cur === ASCII85_GROUP_SPACE_CODE) {\n      offset += output.write(ASCII85_GROUP_SPACE, offset);\n    } else if (cur) {\n      for (j = ASCII85_ENCODING_GROUP_LENGTH; j >= 0; j--) {\n        r = cur % ASCII85_BASE;\n        bytes[j] = r;\n        cur = (cur - r) / ASCII85_BASE;\n      }\n\n      for (j = 0; j < ASCII85_DECODING_GROUP_LENGTH; j++) {\n        offset += output.write(table[bytes[j]], offset);\n      }\n    } else {\n      offset += output.write(ASCII85_ZERO, offset);\n    }\n\n    cur = 0;\n    digits = 0;\n  }\n\n  // add padding for remaining bytes.\n  if (digits) {\n    if (cur) {\n      padding = ASCII85_ENCODING_GROUP_LENGTH - digits;\n\n      for (i = ASCII85_ENCODING_GROUP_LENGTH - digits; i > 0; i--) {\n        cur *= 1 << 8;\n      }\n\n      for (j = ASCII85_ENCODING_GROUP_LENGTH; j >= 0; j--) {\n        r = cur % ASCII85_BASE;\n        bytes[j] = r;\n        cur = (cur - r) / ASCII85_BASE;\n      }\n\n      for (j = 0; j < ASCII85_DECODING_GROUP_LENGTH; j++) {\n        offset += output.write(table[bytes[j]], offset);\n      }\n\n      offset -= padding;\n    } else {\n      // If remaining bytes are zero, need to insert '!' instead of 'z'.\n      // This is a special case.\n      for (i = 0; i < digits + 1; i++) {\n        offset += output.write(table[0], offset);\n      }\n    }\n  }\n\n  if (delimiter) {\n    offset += output.write(ASCII85_BLOCK_END, offset);\n  }\n\n  return output.slice(0, offset);\n};\n\n\nAscii85.prototype.decode = function(str, table) {\n  var defOptions = this._options;\n  var buf = str;\n  var enableZero = true;\n  var enableGroupSpace = true;\n  var output, offset, digits, cur, i, c, t, len, padding;\n\n  table = table || defOptions.decodingTable || ASCII85_DEFAULT_DECODING_TABLE;\n\n  // convert a key/value format char map to code array.\n  if (!Array.isArray(table)) {\n    table = table.table || table;\n\n    if (!Array.isArray(table)) {\n      t = [];\n      Object.keys(table).forEach(function(v) {\n        t[v.charCodeAt(0)] = table[v];\n      });\n      table = t;\n    }\n  }\n\n  enableZero = !table[ASCII85_ZERO_VALUE];\n  enableGroupSpace = !table[ASCII85_GROUP_SPACE_VALUE];\n\n  if (!(buf instanceof Buffer)) {\n    buf = _BufferFrom(buf);\n  }\n\n  // estimate output length and alloc buffer for it.\n  t = 0;\n\n  if (enableZero || enableGroupSpace) {\n    for (i = 0, len = buf.length; i < len; i++) {\n      c = buf.readUInt8(i);\n\n      if (enableZero && c === ASCII85_ZERO_VALUE) {\n        t++;\n      }\n\n      if (enableGroupSpace && c === ASCII85_GROUP_SPACE_VALUE) {\n        t++;\n      }\n    }\n  }\n\n  offset = 0;\n  len = Math.ceil(buf.length * ASCII85_ENCODING_GROUP_LENGTH / ASCII85_DECODING_GROUP_LENGTH) +\n        t * ASCII85_ENCODING_GROUP_LENGTH +\n        ASCII85_DECODING_GROUP_LENGTH;\n  output = _BufferAllocUnsafe(len);\n\n  // if str starts with delimiter ('<~'), it must end with '~>'.\n  if (buf.length >= ASCII85_BLOCK_START_LENGTH + ASCII85_BLOCK_END_LENGTH && buf.readUInt16BE(0) === ASCII85_BLOCK_START_VALUE) {\n    for (i = buf.length - ASCII85_BLOCK_END_LENGTH; i > ASCII85_BLOCK_START_LENGTH; i--) {\n      if (buf.readUInt16BE(i) === ASCII85_BLOCK_END_VALUE) {\n        break;\n      }\n    }\n\n    if (i <= ASCII85_BLOCK_START_LENGTH) {\n      throw new Error('Invalid ascii85 string delimiter pair.');\n    }\n\n    buf = buf.slice(ASCII85_BLOCK_START_LENGTH, i);\n  }\n\n  for (i = digits = cur = 0, len = buf.length; i < len; i++) {\n    c = buf.readUInt8(i);\n\n    if (enableZero && c === ASCII85_ZERO_VALUE) {\n      offset += output.write(ASCII85_NULL_STRING, offset);\n      continue;\n    }\n\n    if (enableGroupSpace && c === ASCII85_GROUP_SPACE_VALUE) {\n      offset += output.write(ASCII85_GROUP_SPACE_STRING, offset);\n      continue;\n    }\n\n    if (table[c] === undefined) {\n      continue;\n    }\n\n    cur *= ASCII85_BASE;\n    cur += table[c];\n    digits++;\n\n    if (digits % ASCII85_DECODING_GROUP_LENGTH) {\n      continue;\n    }\n\n    offset = output.writeUInt32BE(cur, offset);\n    cur = 0;\n    digits = 0;\n  }\n\n  if (digits) {\n    padding = ASCII85_DECODING_GROUP_LENGTH - digits;\n\n    for (i = 0; i < padding; i++) {\n      cur *= ASCII85_BASE;\n      cur += ASCII85_BASE - 1;\n    }\n\n    for (i = 3, len = padding - 1; i > len; i--) {\n      offset = output.writeUInt8((cur >>> (i * 8)) & 0xFF, offset);\n    }\n  }\n\n  return output.slice(0, offset);\n};\n\n\ndefaultCodec.ZeroMQ = new Ascii85({\n  table: [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    '.', '-', ':', '+', '=', '^', '!', '/', '*', '?', '&', '<', '>', '(', ')', '[', ']', '{', '}', '@', '%', '$', '#'\n  ]\n});\n\n\ndefaultCodec.PostScript = new Ascii85({\n  delimiter: true\n});\n\n\ndefaultCodec.Ascii85 = Ascii85;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(440).Buffer))\n\n/***/ })\n\n}]);","\n'use strict';\n\n// Buffer api is changed since v6.0.0. this wrapper is designed to leverage new\n// api features if possible without breaking old node.\n//\n// it's not a completed polyfill implementation. i just do necessary shims for this\n// package only.\nvar _BufferFrom = Buffer.from || function() {\n  switch (arguments.length) {\n    case 1: return new Buffer(arguments[0]);\n    case 2: return new Buffer(arguments[0], arguments[1]);\n    case 3: return new Buffer(arguments[0], arguments[1], arguments[2]);\n    default: throw new Exception('unexpected call.');\n  }\n};\nvar _BufferAlloc = Buffer.alloc || function(size, fill, encoding) {\n  var buf = new Buffer(size);\n\n  if (fill !== undefined) {\n    if (typeof encoding === \"string\") {\n      buf.fill(fill, encoding);\n    } else {\n      buf.fill(fill);\n    }\n  }\n\n  return buf;\n};\nvar _BufferAllocUnsafe = Buffer.allocUnsafe || function(size) {\n  return new Buffer(size);\n};\nvar _NewUint8Array = (function() {\n  if (typeof Uint8Array === 'undefined') {\n    return function(size) {\n      return new Array(size);\n    };\n  } else {\n    return function(size) {\n      return new Uint8Array(size);\n    }\n  }\n})();\n\nvar ASCII85_BASE = 85;\nvar ASCII85_CODE_START = 33;\nvar ASCII85_CODE_END = ASCII85_CODE_START + ASCII85_BASE;\nvar ASCII85_NULL = String.fromCharCode(0);\nvar ASCII85_NULL_STRING = ASCII85_NULL + ASCII85_NULL + ASCII85_NULL + ASCII85_NULL;\nvar ASCII85_ZERO = 'z';\nvar ASCII85_ZERO_VALUE = ASCII85_ZERO.charCodeAt(0);\nvar ASCII85_PADDING_VALUE = 'u'.charCodeAt(0);\nvar ASCII85_ENCODING_GROUP_LENGTH = 4;\nvar ASCII85_DECODING_GROUP_LENGTH = 5;\nvar ASCII85_BLOCK_START = '<~';\nvar ASCII85_BLOCK_START_LENGTH = ASCII85_BLOCK_START.length;\nvar ASCII85_BLOCK_START_VALUE = _BufferFrom(ASCII85_BLOCK_START).readUInt16BE(0);\nvar ASCII85_BLOCK_END = '~>';\nvar ASCII85_BLOCK_END_LENGTH = ASCII85_BLOCK_END.length;\nvar ASCII85_BLOCK_END_VALUE = _BufferFrom(ASCII85_BLOCK_END).readUInt16BE(0);\nvar ASCII85_GROUP_SPACE = 'y';\nvar ASCII85_GROUP_SPACE_VALUE = ASCII85_GROUP_SPACE.charCodeAt(0);\nvar ASCII85_GROUP_SPACE_CODE = 0x20202020;\nvar ASCII85_GROUP_SPACE_STRING = '    ';\n\nvar ASCII85_DEFAULT_ENCODING_TABLE = (function() {\n  var arr = new Array(ASCII85_BASE);\n  var i;\n\n  for (i = 0; i < ASCII85_BASE; i++) {\n    arr[i] = String.fromCharCode(ASCII85_CODE_START + i);\n  }\n\n  return arr;\n})();\n\nvar ASCII85_DEFAULT_DECODING_TABLE = (function() {\n  var arr = new Array(1 << 8);\n  var i;\n\n  for (i = 0; i < ASCII85_BASE; i++) {\n    arr[ASCII85_CODE_START + i] = i;\n  }\n\n  return arr;\n})();\n\n\nfunction Ascii85(options) {\n  var decodingTable;\n\n  options = options || {};\n  this._options = options;\n\n  // generate encoding and decoding table.\n  if (Array.isArray(options.table)) {\n    decodingTable = [];\n    options.table.forEach(function(v, i) {\n      decodingTable[v.charCodeAt(0)] = i;\n    });\n\n    options.encodingTable = options.table;\n    options.decodingTable = decodingTable;\n  }\n}\n\nvar defaultCodec = module.exports = new Ascii85();\n\n\nAscii85.prototype.encode = function(data, options) {\n  var bytes = _NewUint8Array(5);\n  var buf = data;\n  var defOptions = this._options;\n  var output, offset, table, delimiter, groupSpace, digits, cur, i, j, r, b, len, padding;\n\n  if (typeof buf === \"string\") {\n    buf = _BufferFrom(buf, 'binary');\n  } else if (!(buf instanceof Buffer)) {\n    buf = _BufferFrom(buf);\n  }\n\n  // prepare options.\n  options = options || {};\n\n  if (Array.isArray(options)) {\n    table = options;\n    delimiter = defOptions.delimiter || false;\n    groupSpace = defOptions.groupSpace || false;\n  } else {\n    table = options.table || defOptions.encodingTable || ASCII85_DEFAULT_ENCODING_TABLE;\n\n    if (options.delimiter === undefined) {\n      delimiter = defOptions.delimiter || false;\n    } else {\n      delimiter = !!options.delimiter;\n    }\n\n    if (options.groupSpace === undefined) {\n      groupSpace = defOptions.groupSpace || false;\n    } else {\n      groupSpace = !!options.groupSpace;\n    }\n  }\n\n  // estimate output length and alloc buffer for it.\n  offset = 0;\n  len = Math.ceil(buf.length * ASCII85_DECODING_GROUP_LENGTH / ASCII85_ENCODING_GROUP_LENGTH) +\n        ASCII85_ENCODING_GROUP_LENGTH +\n        (delimiter? ASCII85_BLOCK_START_LENGTH + ASCII85_BLOCK_END_LENGTH: 0);\n  output = _BufferAllocUnsafe(len);\n\n  if (delimiter) {\n    offset += output.write(ASCII85_BLOCK_START, offset);\n  }\n\n  // iterate over all data bytes.\n  for (i = digits = cur = 0, len = buf.length; i < len; i++) {\n    b = buf.readUInt8(i);\n\n    cur *= 1 << 8;\n    cur += b;\n    digits++;\n\n    if (digits % ASCII85_ENCODING_GROUP_LENGTH) {\n      continue;\n    }\n\n    if (groupSpace && cur === ASCII85_GROUP_SPACE_CODE) {\n      offset += output.write(ASCII85_GROUP_SPACE, offset);\n    } else if (cur) {\n      for (j = ASCII85_ENCODING_GROUP_LENGTH; j >= 0; j--) {\n        r = cur % ASCII85_BASE;\n        bytes[j] = r;\n        cur = (cur - r) / ASCII85_BASE;\n      }\n\n      for (j = 0; j < ASCII85_DECODING_GROUP_LENGTH; j++) {\n        offset += output.write(table[bytes[j]], offset);\n      }\n    } else {\n      offset += output.write(ASCII85_ZERO, offset);\n    }\n\n    cur = 0;\n    digits = 0;\n  }\n\n  // add padding for remaining bytes.\n  if (digits) {\n    if (cur) {\n      padding = ASCII85_ENCODING_GROUP_LENGTH - digits;\n\n      for (i = ASCII85_ENCODING_GROUP_LENGTH - digits; i > 0; i--) {\n        cur *= 1 << 8;\n      }\n\n      for (j = ASCII85_ENCODING_GROUP_LENGTH; j >= 0; j--) {\n        r = cur % ASCII85_BASE;\n        bytes[j] = r;\n        cur = (cur - r) / ASCII85_BASE;\n      }\n\n      for (j = 0; j < ASCII85_DECODING_GROUP_LENGTH; j++) {\n        offset += output.write(table[bytes[j]], offset);\n      }\n\n      offset -= padding;\n    } else {\n      // If remaining bytes are zero, need to insert '!' instead of 'z'.\n      // This is a special case.\n      for (i = 0; i < digits + 1; i++) {\n        offset += output.write(table[0], offset);\n      }\n    }\n  }\n\n  if (delimiter) {\n    offset += output.write(ASCII85_BLOCK_END, offset);\n  }\n\n  return output.slice(0, offset);\n};\n\n\nAscii85.prototype.decode = function(str, table) {\n  var defOptions = this._options;\n  var buf = str;\n  var enableZero = true;\n  var enableGroupSpace = true;\n  var output, offset, digits, cur, i, c, t, len, padding;\n\n  table = table || defOptions.decodingTable || ASCII85_DEFAULT_DECODING_TABLE;\n\n  // convert a key/value format char map to code array.\n  if (!Array.isArray(table)) {\n    table = table.table || table;\n\n    if (!Array.isArray(table)) {\n      t = [];\n      Object.keys(table).forEach(function(v) {\n        t[v.charCodeAt(0)] = table[v];\n      });\n      table = t;\n    }\n  }\n\n  enableZero = !table[ASCII85_ZERO_VALUE];\n  enableGroupSpace = !table[ASCII85_GROUP_SPACE_VALUE];\n\n  if (!(buf instanceof Buffer)) {\n    buf = _BufferFrom(buf);\n  }\n\n  // estimate output length and alloc buffer for it.\n  t = 0;\n\n  if (enableZero || enableGroupSpace) {\n    for (i = 0, len = buf.length; i < len; i++) {\n      c = buf.readUInt8(i);\n\n      if (enableZero && c === ASCII85_ZERO_VALUE) {\n        t++;\n      }\n\n      if (enableGroupSpace && c === ASCII85_GROUP_SPACE_VALUE) {\n        t++;\n      }\n    }\n  }\n\n  offset = 0;\n  len = Math.ceil(buf.length * ASCII85_ENCODING_GROUP_LENGTH / ASCII85_DECODING_GROUP_LENGTH) +\n        t * ASCII85_ENCODING_GROUP_LENGTH +\n        ASCII85_DECODING_GROUP_LENGTH;\n  output = _BufferAllocUnsafe(len);\n\n  // if str starts with delimiter ('<~'), it must end with '~>'.\n  if (buf.length >= ASCII85_BLOCK_START_LENGTH + ASCII85_BLOCK_END_LENGTH && buf.readUInt16BE(0) === ASCII85_BLOCK_START_VALUE) {\n    for (i = buf.length - ASCII85_BLOCK_END_LENGTH; i > ASCII85_BLOCK_START_LENGTH; i--) {\n      if (buf.readUInt16BE(i) === ASCII85_BLOCK_END_VALUE) {\n        break;\n      }\n    }\n\n    if (i <= ASCII85_BLOCK_START_LENGTH) {\n      throw new Error('Invalid ascii85 string delimiter pair.');\n    }\n\n    buf = buf.slice(ASCII85_BLOCK_START_LENGTH, i);\n  }\n\n  for (i = digits = cur = 0, len = buf.length; i < len; i++) {\n    c = buf.readUInt8(i);\n\n    if (enableZero && c === ASCII85_ZERO_VALUE) {\n      offset += output.write(ASCII85_NULL_STRING, offset);\n      continue;\n    }\n\n    if (enableGroupSpace && c === ASCII85_GROUP_SPACE_VALUE) {\n      offset += output.write(ASCII85_GROUP_SPACE_STRING, offset);\n      continue;\n    }\n\n    if (table[c] === undefined) {\n      continue;\n    }\n\n    cur *= ASCII85_BASE;\n    cur += table[c];\n    digits++;\n\n    if (digits % ASCII85_DECODING_GROUP_LENGTH) {\n      continue;\n    }\n\n    offset = output.writeUInt32BE(cur, offset);\n    cur = 0;\n    digits = 0;\n  }\n\n  if (digits) {\n    padding = ASCII85_DECODING_GROUP_LENGTH - digits;\n\n    for (i = 0; i < padding; i++) {\n      cur *= ASCII85_BASE;\n      cur += ASCII85_BASE - 1;\n    }\n\n    for (i = 3, len = padding - 1; i > len; i--) {\n      offset = output.writeUInt8((cur >>> (i * 8)) & 0xFF, offset);\n    }\n  }\n\n  return output.slice(0, offset);\n};\n\n\ndefaultCodec.ZeroMQ = new Ascii85({\n  table: [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    '.', '-', ':', '+', '=', '^', '!', '/', '*', '?', '&', '<', '>', '(', ')', '[', ']', '{', '}', '@', '%', '$', '#'\n  ]\n});\n\n\ndefaultCodec.PostScript = new Ascii85({\n  delimiter: true\n});\n\n\ndefaultCodec.Ascii85 = Ascii85;\n"],"mappings":";AAAA;AC6BA;AAsFA;AA8DA;AAiEA;AAmEA;","sourceRoot":""}