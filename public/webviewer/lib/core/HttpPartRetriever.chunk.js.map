{"version":3,"file":"HttpPartRetriever.chunk.js","sources":["webpack:///HttpPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/HttpPartRetriever.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[0],{\n\n/***/ 518:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteRangeRequest\", function() { return ByteRangeRequest; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);\n/* harmony import */ var _PartRetriever__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(113);\n/* harmony import */ var _ZipFile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(294);\n/* harmony import */ var _util_stringUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(88);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85);\n/* harmony import */ var _util_constants_status__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(293);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(195);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(439);\n\n\n\n\n\n\n\n\n\n\n\n// contains the information for requests that have not been sent yet\nvar waitingQueue = [];\n// contains the information for requests that are currently ongoing\nvar ongoingQueue = [];\nvar exports = window;\nvar ChunkRequest = /** @class */ (function () {\n    function ChunkRequest(chunkNum) {\n        this.chunkNum = chunkNum;\n        this.refs = 1;\n    }\n    return ChunkRequest;\n}());\nvar XMLHttpRequestStatus;\n(function (XMLHttpRequestStatus) {\n    XMLHttpRequestStatus[XMLHttpRequestStatus[\"UNSENT\"] = 0] = \"UNSENT\";\n    XMLHttpRequestStatus[XMLHttpRequestStatus[\"DONE\"] = 4] = \"DONE\";\n})(XMLHttpRequestStatus || (XMLHttpRequestStatus = {}));\n/**\n * Construct a new ByteRangeRequest.\n * @name ByteRangeRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param range The range of bytes to load, inclusive.\n * @param range.start Start\n * @param [range.stop] Stop\n * @ignore\n */\nvar ByteRangeRequest = /** @class */ (function () {\n    function ByteRangeRequest(url, range, customHeaders, withCredentials) {\n        var _this = this;\n        this.url = url;\n        this.range = range;\n        this.customHeaders = customHeaders;\n        this.withCredentials = withCredentials;\n        this.XMLHttpRequestStatus = XMLHttpRequestStatus;\n        // this.range = range;\n        this.request = new XMLHttpRequest();\n        this.request.open('GET', this.url, true);\n        if (exports.Uint8Array) {\n            this.request.responseType = 'arraybuffer';\n        }\n        if (withCredentials) {\n            this.request.withCredentials = withCredentials;\n        }\n        // eslint-disable-next-line\n        if (!HttpPartRetriever['DISABLE_RANGE_HEADER']) {\n            if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(range.stop)) {\n                this.request.setRequestHeader('Range', ['bytes=', range.start, '-', range.stop - 1].join(''));\n            }\n            else {\n                this.request.setRequestHeader('Range', \"bytes=\" + range.start);\n            }\n        }\n        if (customHeaders) {\n            Object.keys(customHeaders).forEach(function (header) {\n                _this.request.setRequestHeader(header, customHeaders[header]);\n            });\n        }\n        if (this.request.overrideMimeType) {\n            this.request.overrideMimeType('text/plain; charset=x-user-defined');\n        }\n        else {\n            // Is this required for all servers? Only done for IE\n            this.request.setRequestHeader('Accept-Charset', 'x-user-defined');\n        }\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['NOT_STARTED'];\n    }\n    ByteRangeRequest.prototype.start = function (callback) {\n        var me = this;\n        var request = this.request;\n        request.onreadystatechange = function () {\n            if (me.aborted) {\n                // for some reason IE9 doesn't reliably fire the onreadystatechange handler after a request has been aborted\n                // so the logic has been moved up to the ByteRangeRequest abort function\n                // other browsers can still call the callback function here, though it only prints a warning message\n                // so it's not crucial that IE9 calls it\n                me.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['ABORTED'];\n                return callback({\n                    code: _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['ABORTED'],\n                });\n            }\n            if (this.readyState === me.XMLHttpRequestStatus.DONE) {\n                me.getNextRequest();\n                var isFromFile = window.document.URL.indexOf('file:///') === 0;\n                var isSuccess = request.status === 200 || request.status === 206 || (isFromFile && request.status === 0);\n                if (isSuccess) {\n                    // TODO-TS Fix this once getRequestData is off window\n                    // @ts-ignore\n                    var response = exports.getRequestData(this);\n                    me.success(response, callback);\n                }\n                else {\n                    me.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['ERROR'];\n                    // Return error\n                    callback({\n                        code: me.status,\n                        status: me.status,\n                    });\n                }\n            }\n        };\n        this.request.send(null);\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['STARTED'];\n    };\n    // TODO-TS what data is this\n    ByteRangeRequest.prototype.success = function (data, callback) {\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['SUCCESS'];\n        if (callback) {\n            return callback(false, data);\n        }\n    };\n    ByteRangeRequest.prototype.abort = function () {\n        // moved the getNextRequest call here from onreadystatechange because IE9 is not reliably firing it\n        // after the request is aborted\n        this.getNextRequest();\n        this.aborted = true;\n        this.request.abort();\n    };\n    ByteRangeRequest.prototype.getNextRequest = function () {\n        var idx = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* getIdxFromQueue */ \"c\"])(this.url, this.range, ongoingQueue);\n        if (idx !== -1) {\n            ongoingQueue.splice(idx, 1);\n        }\n        // move next request from the waiting queue to the ongoing queue and start it\n        if (waitingQueue.length > 0) {\n            var requestData = waitingQueue.shift();\n            // create a new object of this object's type (it may be inherited)\n            var nextReq = new ByteRangeRequest(requestData.url, requestData.range, this.customHeaders, this.withCredentials);\n            requestData.request = nextReq;\n            ongoingQueue.push(requestData);\n            nextReq.start(Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* httpErrorHandler */ \"d\"])(requestData));\n        }\n    };\n    // TODO - needed???\n    // use this function to extend from ByteRangeRequest and preserve the constructor property\n    ByteRangeRequest.prototype.extend = function (type) {\n        var extendedPrototype = Object.assign({}, this, type.prototype);\n        extendedPrototype.constructor = type;\n        return extendedPrototype;\n    };\n    return ByteRangeRequest;\n}());\n/**\n * Constructs a new HttpPartRetriever.\n * HttpPartRetriever retrieves Document parts asynchronously from a .xod file hosted on a web server. The server is required to support the HTTP/1.1 protocol.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class\n * @name Core.HttpPartRetriever\n * @extends Core.PartRetrievers.PartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {p: \"pass\", type: \"aes\"} where is p is the password\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @property {boolean} DISABLE_RANGE_HEADER Whether to disable the range header. This should only be used if your server will look at the range query parameters and return the correct bytes.\n * @ignore\n */\nvar HttpPartRetriever = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(HttpPartRetriever, _super);\n    // These have to be optional cuz XOD partretriever below extends this class but doesnt accept the same paramaters :)\n    function HttpPartRetriever(url, cacheHint, decrypt, decryptOptions, customHeaders) {\n        var _this = _super.call(this, url, decrypt, decryptOptions) || this;\n        _this.requestedChunks = {};\n        _this.cacheHint = cacheHint;\n        _this.url = url;\n        _this['DISABLE_RANGE_HEADER'] = false;\n        _this.rangeRequest = ByteRangeRequest;\n        _this.MAX_ONGOING_REQUESTS = 3;\n        _this.customHeaders = customHeaders || {};\n        return _this;\n    }\n    HttpPartRetriever.prototype.createRangeURL = function (url, range, cacheHint) {\n        var questionString = (url.indexOf('?') === -1 ? '?' : '&');\n        // check true and false for backwards compatibility\n        switch (cacheHint) {\n            case false:\n            // TODO-TS remove this CacheHinting\n            // @ts-ignore\n            case _constants__WEBPACK_IMPORTED_MODULE_7__[/* CacheHinting */ \"a\"]['NEVER_CACHE']:\n                // Add a unique id into the URL so the browser never caches\n                url = url + questionString + \"_=\" + Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"uniqueId\"])();\n                break;\n            case true:\n            // TODO-TS remove this CacheHinting\n            // @ts-ignore\n            case _constants__WEBPACK_IMPORTED_MODULE_7__[/* CacheHinting */ \"a\"]['CACHE']:\n                // Add the Range header bytes into the URL so it can cache each unique range\n                url = url + questionString + \"_=\" + range.start + \",\" + (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(range.stop) ? range.stop : '');\n                break;\n        }\n        return url;\n    };\n    HttpPartRetriever.prototype.createRangeRequest = function (url, range, customHeaders, withCredentials) {\n        if (customHeaders === void 0) { customHeaders = {}; }\n        return new this.rangeRequest(url, range, customHeaders, withCredentials);\n    };\n    HttpPartRetriever.prototype.enqueueRequest = function (url, range, cacheHint, callback, customHeaders) {\n        for (var i = 0; i < waitingQueue.length; i++) {\n            if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isEqual\"])(waitingQueue[i].range, range) && Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isEqual\"])(waitingQueue[i].url, url)) {\n                waitingQueue[i].callbacks.push(callback);\n                waitingQueue[i].numRequests++;\n                return null;\n            }\n        }\n        for (var i = 0; i < ongoingQueue.length; i++) {\n            if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isEqual\"])(ongoingQueue[i].range, range) && Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isEqual\"])(ongoingQueue[i].url, url)) {\n                ongoingQueue[i].callbacks.push(callback);\n                ongoingQueue[i].numRequests++;\n                return null;\n            }\n        }\n        // request hasn't been found in the queue\n        var requestData = {\n            url: url,\n            range: range,\n            cacheHint: cacheHint,\n            callbacks: [callback],\n            numRequests: 1,\n        };\n        if (waitingQueue.length === 0 && ongoingQueue.length < this.MAX_ONGOING_REQUESTS) {\n            ongoingQueue.push(requestData);\n            requestData.request = this.createRangeRequest(url, range, customHeaders, this.withCredentials);\n            return requestData;\n        }\n        waitingQueue.push(requestData);\n        return null;\n    };\n    HttpPartRetriever.prototype.getXODPartRetriever = function (part) {\n        if (!this.zipfile.containsFile(part)) {\n            throw new Error(\"File not found: \\\"\" + part + \"\\\"\");\n        }\n        var range = this.zipfile.getFileRange(part);\n        return new XODPartHttpPartRetriever(this, range.start, range.stop);\n    };\n    /**\n     * Loads a range of the remote file using HTTP byte ranges.\n     * @method Core.HttpPartRetriever#loadRange\n     * @param {string} url The URL to read data from.\n     * @param {{start:number,stop:number}} range The start and stop bytes of the range to read.\n     * @param {function(string)} callback The callback for the result.\n     */\n    HttpPartRetriever.prototype.loadRange = function (url, range, callback) {\n        // TODO: disable caching selectively (e.g. on iOS)\n        var rangeURL = this.createRangeURL(url, range, this.cacheHint);\n        var requestData = this.enqueueRequest(rangeURL, range, this.cacheHint, callback, this.customHeaders);\n        if (requestData) {\n            requestData.request.start(Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* httpErrorHandler */ \"d\"])(requestData));\n        }\n        return function cancel() {\n            var idx = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* getIdxFromQueue */ \"c\"])(rangeURL, range, ongoingQueue);\n            var nReq;\n            // if it's in the ongoing queue\n            if (idx !== -1) {\n                nReq = --ongoingQueue[idx].numRequests;\n                // if there are no other requests for this part then abort it\n                if (nReq === 0 && ongoingQueue[idx].request) {\n                    ongoingQueue[idx].request.abort();\n                }\n            }\n            else {\n                idx = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* getIdxFromQueue */ \"c\"])(rangeURL, range, waitingQueue);\n                if (idx === -1) {\n                    // if it's in neither queue then return\n                    return;\n                }\n                nReq = --waitingQueue[idx].numRequests;\n                // remove from waiting queue if there aren't any more requests for it\n                if (nReq === 0) {\n                    waitingQueue.splice(idx, 1);\n                }\n            }\n        };\n    };\n    HttpPartRetriever.prototype.getEndHeaderRange = function () {\n        var zipHeaderSize = _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* EndHeaderSize */ \"a\"];\n        return { start: -zipHeaderSize };\n    };\n    HttpPartRetriever.prototype.getZip64EndHeaderRange = function () {\n        var end = -(_util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* EndHeaderSize */ \"a\"] + _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* ZIP64EndLocatorSize */ \"e\"]);\n        return { start: end - _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* ZIP64EndHeaderSize */ \"d\"], end: end };\n    };\n    HttpPartRetriever.prototype.loadHeaders = function (callback) {\n        var _this = this;\n        this.centralDirectoryLoading = true;\n        var zipHeaderSize = _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* EndHeaderSize */ \"a\"];\n        this.loadRange(this.url, this.getEndHeaderRange(), function (err, data, request) {\n            if (err) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])(\"Error loading end header: \" + err);\n                return callback(err, data, request);\n            }\n            data = Object(_util_stringUtils__WEBPACK_IMPORTED_MODULE_6__[/* getBinaryString */ \"a\"])(data);\n            if (data.length !== zipHeaderSize) {\n                return callback('Invalid XOD file: Zip end header data is wrong size!');\n            }\n            try {\n                _this.zipfile = new _ZipFile__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"](data);\n            }\n            catch (ex) {\n                return callback(ex);\n            }\n            var loadCentralDirectory = function () {\n                var range = _this.zipfile.getDirectoryRange();\n                _this.loadRange(_this.url, range, function (err, data) {\n                    if (err) {\n                        Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])(\"Error loading central directory: \" + err);\n                        return callback(err);\n                    }\n                    data = Object(_util_stringUtils__WEBPACK_IMPORTED_MODULE_6__[/* getBinaryString */ \"a\"])(data);\n                    if (data.length !== (range.stop - range.start)) {\n                        return callback(\"Invalid XOD file: Zip central directory data is wrong size! Should be \" + (range.stop - range.start) + \" but is \" + data.length);\n                    }\n                    _this.zipfile.readCentralDirectory(data);\n                    _this.centralDirectoryLoaded = true;\n                    _this.centralDirectoryLoading = false;\n                    return callback(false);\n                });\n            };\n            if (_this.zipfile.isZip64) {\n                _this.loadRange(_this.url, _this.getZip64EndHeaderRange(), function (err, data) {\n                    if (err) {\n                        Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])(\"Error loading zip64 header: \" + err);\n                        return callback(err);\n                    }\n                    data = Object(_util_stringUtils__WEBPACK_IMPORTED_MODULE_6__[/* getBinaryString */ \"a\"])(data);\n                    _this.zipfile.loadZip64EndHeader(data);\n                    loadCentralDirectory();\n                });\n            }\n            else {\n                loadCentralDirectory();\n            }\n        });\n    };\n    HttpPartRetriever.prototype.getPartsList = function (callback) {\n        callback(Object.keys(this.zipfile.fileHeaders));\n    };\n    HttpPartRetriever.prototype.readPart = function (part, callback) {\n        var _this = this;\n        if (!this.zipfile.containsFile(part)) {\n            delete this.requests[part];\n            return callback(new Error(\"File not found: \\\"\" + part + \"\\\"\"), part);\n        }\n        var chunkNum = this.zipfile.getFileChunkNum(part);\n        if (chunkNum in this.requestedChunks) {\n            // if this part belongs to a chunk that has already been requested then we should\n            // increase the reference count on the chunk\n            // we will only come into this function if this part is being requested for the first time\n            // so we don't have to increase the reference count on the part, that's done elsewhere\n            var rq = this.requests[part];\n            rq.chunkRequest = this.requestedChunks[chunkNum];\n            rq.chunkRequest.refs++;\n            // all the parts in the same chunk should have the same cancel functions\n            rq.cancel = rq.chunkRequest.cancel;\n            return;\n        }\n        var range = this.zipfile.getFileChunk(part);\n        var cancel = this.loadRange(this.url, range, function (err, data) {\n            if (err) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])(\"Error loading part \\\"\" + part + \"\\\": \" + err);\n                // retry the request once, there was a Chrome bug that caused this to happen sometimes when it shouldn't have\n                // https://groups.google.com/forum/#!topic/pdfnet-webviewer/Mt1oYtDy2Qg\n                _this.loadRange(_this.url, range, function (err, data) {\n                    if (err) {\n                        return callback(err, part);\n                    }\n                    _this.readRangeData(data, range, chunkNum, part, callback);\n                });\n                return;\n            }\n            _this.readRangeData(data, range, chunkNum, part, callback);\n        });\n        var request = this.requests[part];\n        if (request) {\n            request.started = true;\n            request.cancel = function () {\n                request.chunkRequest.refs--;\n                // if we are here then the part request has already been deleted so we just need to\n                // check if any other parts still reference this chunk\n                if (request.chunkRequest.refs === 0) {\n                    cancel();\n                    delete _this.requestedChunks[chunkNum];\n                }\n            };\n            // if we are here then this is the first part request that belongs to this chunk\n            this.requestedChunks[chunkNum] = new ChunkRequest(chunkNum);\n            request.chunkRequest = this.requestedChunks[chunkNum];\n            // save a reference to the cancel function on the chunk request so that it can be used by the other parts in the chunk\n            request.chunkRequest.cancel = request.cancel;\n        }\n    };\n    HttpPartRetriever.prototype.readRangeData = function (data, range, chunkNum, part, callback) {\n        if (data.length !== (range.stop - range.start)) {\n            return callback(new Error('Part data is wrong size!'), part);\n        }\n        var refs;\n        do {\n            if (!this.requestedChunks[chunkNum]) {\n                return;\n            }\n            refs = this.requestedChunks[chunkNum].refs;\n            var numFiles = range.ranges.length;\n            for (var i = 0; i < numFiles; ++i) {\n                var current = range.ranges[i];\n                // @ts-ignore typescript cant parse this\n                callback(false, current.partName, data[typeof data === 'string' ? 'substring' : 'subarray'](current.start, current.stop), this.zipfile.isCompressed(current.partName));\n                if (current.partName in this.requests) {\n                    delete this.requests[current.partName];\n                }\n            }\n            // if refs has increased then we already have the data, so run the loop again\n        } while (refs !== this.requestedChunks[chunkNum].refs);\n        delete this.requestedChunks[chunkNum];\n    };\n    HttpPartRetriever['DISABLE_RANGE_HEADER'] = false;\n    HttpPartRetriever.MAX_ONGOING_REQUESTS = 3;\n    return HttpPartRetriever;\n}(_PartRetriever__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]));\nvar XODPartHttpPartRetriever = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(XODPartHttpPartRetriever, _super);\n    function XODPartHttpPartRetriever(partRetriever, start, end) {\n        var _this = _super.call(this) || this;\n        // eslint-disable-next-line\n        for (var prop in partRetriever) {\n            // @ts-ignore ???????? AGGGHHHHHH\n            _this[prop] = partRetriever[prop];\n        }\n        _this.parentRetriever = partRetriever;\n        _this.startOffset = start;\n        _this.endOffset = end;\n        // need to override the createRangeRequest function on the prototype\n        _this.createRangeRequest = function (url, range, customHeaders, withCredentials) {\n            if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isUndefined\"])(range.stop)) {\n                range.start += _this.endOffset;\n                range.stop = _this.endOffset;\n            }\n            else {\n                range.start += _this.startOffset;\n                range.stop += _this.startOffset;\n            }\n            // update the url, possibly necessary for part retrievers that extend HttpPartRetriever\n            var updatedUrl = _this.createRangeURL(_this.url, range, _this.cacheHint);\n            return new partRetriever.rangeRequest(updatedUrl, range, customHeaders, withCredentials);\n        };\n        return _this;\n    }\n    return XODPartHttpPartRetriever;\n}(HttpPartRetriever));\n\nObject(_Exports__WEBPACK_IMPORTED_MODULE_10__[/* exportEventHandler */ \"a\"])(HttpPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_10__[/* exportPartRetrieverFunctions */ \"b\"])(HttpPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (HttpPartRetriever);\n\n\n/***/ })\n\n}]);","import { isEqual, isUndefined, uniqueId } from 'lodash';\nimport { warn } from 'logger';\nimport { ZIP64EndHeaderSize, ZIP64EndLocatorSize, EndHeaderSize } from '../../util/constants/zipfile';\nimport PartRetriever, { PartRetrieverRange, PartRetrieverHeaders, PartRetrieverDecrypt, PartRetrieverDecryptOptions } from './PartRetriever';\nimport Zipfile from './ZipFile';\nimport { getBinaryString } from '../../util/stringUtils';\nimport { CacheHinting } from './constants';\nimport { RequestStatus } from '../../util/constants/status';\nimport { httpErrorHandler, getIdxFromQueue } from './utils';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\n\n// TODO-TS what does err and data types look like\nexport type ByteRequestCallback = (err: Error | boolean | string, partName?: string, data?: any, isCompressed?: boolean) => void\n\nexport interface ByteRequest {\n  request?: ByteRangeRequest;\n  url?: string;\n  range?: PartRetrieverRange;\n  callbacks?: Array<ByteRequestCallback>;\n  numRequests?: number;\n  cacheHint: CacheHinting;\n}\n\nexport type ByteRequestQueue = Array<ByteRequest>\n\n// contains the information for requests that have not been sent yet\nconst waitingQueue: ByteRequestQueue = [];\n// contains the information for requests that are currently ongoing\nconst ongoingQueue: ByteRequestQueue = [];\n\nconst exports = window;\n\nclass ChunkRequest {\n  chunkNum: number;\n\n  refs: number;\n\n  constructor(chunkNum: number) {\n    this.chunkNum = chunkNum;\n    this.refs = 1;\n  }\n}\n\nenum XMLHttpRequestStatus {\n  UNSENT = 0,\n  DONE = 4,\n}\n\nexport type HttpPartRetrieverCallback = (err: { code: RequestStatus; status?: RequestStatus } | boolean, data?: any) => void;\n\n/**\n * Construct a new ByteRangeRequest.\n * @name ByteRangeRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param range The range of bytes to load, inclusive.\n * @param range.start Start\n * @param [range.stop] Stop\n * @ignore\n */\nclass ByteRangeRequest {\n  url: string;\n\n  range: PartRetrieverRange;\n\n  customHeaders: PartRetrieverHeaders;\n\n  withCredentials: boolean;\n\n  request: XMLHttpRequest;\n\n  status: RequestStatus;\n\n  XMLHttpRequestStatus: typeof XMLHttpRequestStatus;\n\n  aborted?: boolean;\n\n\n  constructor(url: string, range: PartRetrieverRange, customHeaders?: PartRetrieverHeaders, withCredentials?: boolean) {\n    this.url = url;\n    this.range = range;\n    this.customHeaders = customHeaders;\n    this.withCredentials = withCredentials;\n\n    this.XMLHttpRequestStatus = XMLHttpRequestStatus;\n\n    // this.range = range;\n    this.request = new XMLHttpRequest();\n    this.request.open('GET', this.url, true);\n    if (exports.Uint8Array) {\n      this.request.responseType = 'arraybuffer';\n    }\n\n    if (withCredentials) {\n      this.request.withCredentials = withCredentials;\n    }\n\n    // eslint-disable-next-line\n    if (!HttpPartRetriever['DISABLE_RANGE_HEADER']) {\n      if (!isUndefined(range.stop)) {\n        this.request.setRequestHeader('Range', ['bytes=', range.start, '-', range.stop - 1].join(''));\n      } else {\n        this.request.setRequestHeader('Range', `bytes=${range.start}`);\n      }\n    }\n\n    if (customHeaders) {\n      Object.keys(customHeaders).forEach((header) => {\n        this.request.setRequestHeader(header, customHeaders[header]);\n      });\n    }\n\n    if (this.request.overrideMimeType) {\n      this.request.overrideMimeType('text/plain; charset=x-user-defined');\n    } else {\n      // Is this required for all servers? Only done for IE\n      this.request.setRequestHeader('Accept-Charset', 'x-user-defined');\n    }\n    this.status = RequestStatus['NOT_STARTED'];\n  }\n\n  start(callback: HttpPartRetrieverCallback) {\n    const me = this;\n    const request = this.request;\n    request.onreadystatechange = function() {\n      if (me.aborted) {\n        // for some reason IE9 doesn't reliably fire the onreadystatechange handler after a request has been aborted\n        // so the logic has been moved up to the ByteRangeRequest abort function\n        // other browsers can still call the callback function here, though it only prints a warning message\n        // so it's not crucial that IE9 calls it\n\n        me.status = RequestStatus['ABORTED'];\n        return callback({\n          code: RequestStatus['ABORTED'],\n        });\n      }\n      if (this.readyState === me.XMLHttpRequestStatus.DONE) {\n        me.getNextRequest();\n\n        const isFromFile = window.document.URL.indexOf('file:///') === 0;\n        const isSuccess = request.status === 200 || request.status === 206 || (isFromFile && request.status === 0);\n        if (isSuccess) {\n          // TODO-TS Fix this once getRequestData is off window\n          // @ts-ignore\n          const response = exports.getRequestData(this);\n          me.success(response, callback);\n        } else {\n          me.status = RequestStatus['ERROR'];\n          // Return error\n          callback({\n            code: me.status,\n            status: me.status,\n          });\n        }\n      }\n    };\n\n    this.request.send(null);\n    this.status = RequestStatus['STARTED'];\n  }\n\n  // TODO-TS what data is this\n  success(data: any, callback: HttpPartRetrieverCallback) {\n    this.status = RequestStatus['SUCCESS'];\n    if (callback) {\n      return callback(false, data);\n    }\n  }\n\n  abort() {\n    // moved the getNextRequest call here from onreadystatechange because IE9 is not reliably firing it\n    // after the request is aborted\n    this.getNextRequest();\n\n    this.aborted = true;\n    this.request.abort();\n  }\n\n  getNextRequest() {\n    const idx = getIdxFromQueue(this.url, this.range, ongoingQueue);\n    if (idx !== -1) {\n      ongoingQueue.splice(idx, 1);\n    }\n    // move next request from the waiting queue to the ongoing queue and start it\n    if (waitingQueue.length > 0) {\n      const requestData = waitingQueue.shift();\n      // create a new object of this object's type (it may be inherited)\n      const nextReq = new ByteRangeRequest(requestData.url, requestData.range, this.customHeaders, this.withCredentials);\n      requestData.request = nextReq;\n      ongoingQueue.push(requestData);\n      nextReq.start(httpErrorHandler(requestData));\n    }\n  }\n\n  // TODO - needed???\n  // use this function to extend from ByteRangeRequest and preserve the constructor property\n  extend(type: any) {\n    const extendedPrototype = Object.assign({}, this, type.prototype);\n    extendedPrototype.constructor = type;\n    return extendedPrototype;\n  }\n}\n\n/**\n * Constructs a new HttpPartRetriever.\n * HttpPartRetriever retrieves Document parts asynchronously from a .xod file hosted on a web server. The server is required to support the HTTP/1.1 protocol.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class\n * @name Core.HttpPartRetriever\n * @extends Core.PartRetrievers.PartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {p: \"pass\", type: \"aes\"} where is p is the password\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @property {boolean} DISABLE_RANGE_HEADER Whether to disable the range header. This should only be used if your server will look at the range query parameters and return the correct bytes.\n * @ignore\n */\n\nclass HttpPartRetriever extends PartRetriever {\n  url: string;\n\n  cacheHint: CacheHinting;\n\n  requestedChunks: {[id: number]: any};\n\n  DISABLE_RANGE_HEADER: false;\n\n  rangeRequest: typeof ByteRangeRequest;\n\n  MAX_ONGOING_REQUESTS: number;\n\n  zipfile?: Zipfile;\n\n  static 'DISABLE_RANGE_HEADER' = false;\n\n  static MAX_ONGOING_REQUESTS = 3;\n\n  // These have to be optional cuz XOD partretriever below extends this class but doesnt accept the same paramaters :)\n  constructor(url?: string, cacheHint?: CacheHinting, decrypt?: PartRetrieverDecrypt, decryptOptions?: PartRetrieverDecryptOptions, customHeaders?: PartRetrieverHeaders) {\n    super(url, decrypt, decryptOptions);\n\n    this.requestedChunks = {};\n    this.cacheHint = cacheHint;\n    this.url = url;\n    this['DISABLE_RANGE_HEADER'] = false;\n    this.rangeRequest = ByteRangeRequest;\n    this.MAX_ONGOING_REQUESTS = 3;\n    this.customHeaders = customHeaders || {};\n  }\n\n  createRangeURL(url: string, range: PartRetrieverRange, cacheHint: CacheHinting|boolean) {\n    const questionString = (url.indexOf('?') === -1 ? '?' : '&');\n    // check true and false for backwards compatibility\n    switch (cacheHint) {\n      case false:\n      // TODO-TS remove this CacheHinting\n      // @ts-ignore\n      case CacheHinting['NEVER_CACHE']:\n      // Add a unique id into the URL so the browser never caches\n        url = `${url + questionString}_=${uniqueId()}`;\n        break;\n\n      case true:\n      // TODO-TS remove this CacheHinting\n      // @ts-ignore\n      case CacheHinting['CACHE']:\n      // Add the Range header bytes into the URL so it can cache each unique range\n        url = `${url + questionString}_=${range.start},${!isUndefined(range.stop) ? range.stop : ''}`;\n        break;\n    }\n\n    return url;\n  }\n\n  createRangeRequest(url: string, range: PartRetrieverRange, customHeaders: PartRetrieverHeaders = {}, withCredentials?: boolean) {\n    return new this.rangeRequest(url, range, customHeaders, withCredentials);\n  }\n\n  enqueueRequest(url: string, range: PartRetrieverRange, cacheHint: CacheHinting, callback: ByteRequestCallback, customHeaders: PartRetrieverHeaders) {\n    for (let i = 0; i < waitingQueue.length; i++) {\n      if (isEqual(waitingQueue[i].range, range) && isEqual(waitingQueue[i].url, url)) {\n        waitingQueue[i].callbacks.push(callback);\n        waitingQueue[i].numRequests++;\n        return null;\n      }\n    }\n\n    for (let i = 0; i < ongoingQueue.length; i++) {\n      if (isEqual(ongoingQueue[i].range, range) && isEqual(ongoingQueue[i].url, url)) {\n        ongoingQueue[i].callbacks.push(callback);\n        ongoingQueue[i].numRequests++;\n        return null;\n      }\n    }\n\n    // request hasn't been found in the queue\n    const requestData: ByteRequest = {\n      url: url,\n      range: range,\n      cacheHint: cacheHint,\n      callbacks: [callback],\n      numRequests: 1,\n      // request: null\n    };\n    if (waitingQueue.length === 0 && ongoingQueue.length < this.MAX_ONGOING_REQUESTS) {\n      ongoingQueue.push(requestData);\n      requestData.request = this.createRangeRequest(url, range, customHeaders, this.withCredentials);\n      return requestData;\n    }\n    waitingQueue.push(requestData);\n    return null;\n  }\n\n  getXODPartRetriever(part: string) {\n    if (!this.zipfile.containsFile(part)) {\n      throw new Error(`File not found: \"${part}\"`);\n    }\n    const range = this.zipfile.getFileRange(part);\n    return new XODPartHttpPartRetriever(this, range.start, range.stop);\n  }\n\n  /**\n   * Loads a range of the remote file using HTTP byte ranges.\n   * @method Core.HttpPartRetriever#loadRange\n   * @param {string} url The URL to read data from.\n   * @param {{start:number,stop:number}} range The start and stop bytes of the range to read.\n   * @param {function(string)} callback The callback for the result.\n   */\n  loadRange(url: string, range: PartRetrieverRange, callback: ByteRequestCallback) {\n    // TODO: disable caching selectively (e.g. on iOS)\n    const rangeURL = this.createRangeURL(url, range, this.cacheHint);\n    const requestData = this.enqueueRequest(rangeURL, range, this.cacheHint, callback, this.customHeaders);\n\n    if (requestData) {\n      requestData.request.start(httpErrorHandler(requestData));\n    }\n\n    return function cancel() {\n      let idx = getIdxFromQueue(rangeURL, range, ongoingQueue);\n      let nReq;\n      // if it's in the ongoing queue\n      if (idx !== -1) {\n        nReq = --ongoingQueue[idx].numRequests;\n        // if there are no other requests for this part then abort it\n        if (nReq === 0 && ongoingQueue[idx].request) {\n          ongoingQueue[idx].request.abort();\n        }\n      } else {\n        idx = getIdxFromQueue(rangeURL, range, waitingQueue);\n        if (idx === -1) {\n          // if it's in neither queue then return\n          return;\n        }\n        nReq = --waitingQueue[idx].numRequests;\n        // remove from waiting queue if there aren't any more requests for it\n        if (nReq === 0) {\n          waitingQueue.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  getEndHeaderRange() {\n    const zipHeaderSize = EndHeaderSize;\n    return { start: -zipHeaderSize };\n  }\n\n  getZip64EndHeaderRange() {\n    const end = -(EndHeaderSize + ZIP64EndLocatorSize);\n    return { start: end - ZIP64EndHeaderSize, end: end };\n  }\n\n  loadHeaders(callback: ByteRequestCallback) {\n    this.centralDirectoryLoading = true;\n\n    const zipHeaderSize = EndHeaderSize;\n\n    this.loadRange(this.url, this.getEndHeaderRange(), (err: any, data: any, request: XMLHttpRequest) => {\n      if (err) {\n        warn(`Error loading end header: ${err}`);\n        return callback(err, data, request);\n      }\n      data = getBinaryString(data);\n\n      if (data.length !== zipHeaderSize) {\n        return callback('Invalid XOD file: Zip end header data is wrong size!');\n      }\n\n      try {\n        this.zipfile = new Zipfile(data);\n      } catch (ex) {\n        return callback(ex);\n      }\n\n      const loadCentralDirectory = () => {\n        const range = this.zipfile.getDirectoryRange();\n\n        this.loadRange(this.url, range, (err, data) => {\n          if (err) {\n            warn(`Error loading central directory: ${err}`);\n            return callback(err);\n          }\n          data = getBinaryString(data);\n          if (data.length !== (range.stop - range.start)) {\n            return callback(`Invalid XOD file: Zip central directory data is wrong size! Should be ${range.stop - range.start} but is ${data.length}`);\n          }\n\n          this.zipfile.readCentralDirectory(data);\n          this.centralDirectoryLoaded = true;\n          this.centralDirectoryLoading = false;\n          return callback(false);\n        });\n      };\n\n\n      if (this.zipfile.isZip64) {\n        this.loadRange(this.url, this.getZip64EndHeaderRange(), (err, data) => {\n          if (err) {\n            warn(`Error loading zip64 header: ${err}`);\n            return callback(err);\n          }\n          data = getBinaryString(data);\n          this.zipfile.loadZip64EndHeader(data);\n          loadCentralDirectory();\n        });\n      } else {\n        loadCentralDirectory();\n      }\n    });\n  }\n\n  getPartsList(callback: (parts: Array<string>) => void) {\n    callback(Object.keys(this.zipfile.fileHeaders));\n  }\n\n  readPart(part: string, callback: ByteRequestCallback) {\n    if (!this.zipfile.containsFile(part)) {\n      delete this.requests[part];\n      return callback(new Error(`File not found: \"${part}\"`), part);\n    }\n\n    const chunkNum: number = this.zipfile.getFileChunkNum(part);\n    if (chunkNum in this.requestedChunks) {\n      // if this part belongs to a chunk that has already been requested then we should\n      // increase the reference count on the chunk\n      // we will only come into this function if this part is being requested for the first time\n      // so we don't have to increase the reference count on the part, that's done elsewhere\n      const rq = this.requests[part];\n      rq.chunkRequest = this.requestedChunks[chunkNum];\n      rq.chunkRequest.refs++;\n      // all the parts in the same chunk should have the same cancel functions\n      rq.cancel = rq.chunkRequest.cancel;\n      return;\n    }\n\n    const range = this.zipfile.getFileChunk(part);\n    const cancel = this.loadRange(this.url, range, (err, data) => {\n      if (err) {\n        warn(`Error loading part \"${part}\": ${err}`);\n        // retry the request once, there was a Chrome bug that caused this to happen sometimes when it shouldn't have\n        // https://groups.google.com/forum/#!topic/pdfnet-webviewer/Mt1oYtDy2Qg\n        this.loadRange(this.url, range, (err: any, data: any) => {\n          if (err) {\n            return callback(err, part);\n          }\n\n          this.readRangeData(data, range, chunkNum, part, callback);\n        });\n        return;\n      }\n\n      this.readRangeData(data, range, chunkNum, part, callback);\n    });\n\n    const request = this.requests[part];\n    if (request) {\n      request.started = true;\n      request.cancel = () => {\n        request.chunkRequest.refs--;\n\n        // if we are here then the part request has already been deleted so we just need to\n        // check if any other parts still reference this chunk\n        if (request.chunkRequest.refs === 0) {\n          cancel();\n          delete this.requestedChunks[chunkNum];\n        }\n      };\n\n      // if we are here then this is the first part request that belongs to this chunk\n      this.requestedChunks[chunkNum] = new ChunkRequest(chunkNum);\n      request.chunkRequest = this.requestedChunks[chunkNum];\n      // save a reference to the cancel function on the chunk request so that it can be used by the other parts in the chunk\n      request.chunkRequest.cancel = request.cancel;\n    }\n  }\n\n  readRangeData(data: string | Array<any>, range: PartRetrieverRange, chunkNum: number, part: string, callback: ByteRequestCallback) {\n    if (data.length !== (range.stop - range.start)) {\n      return callback(new Error('Part data is wrong size!'), part);\n    }\n\n    let refs;\n    do {\n      if (!this.requestedChunks[chunkNum]) {\n        return;\n      }\n\n      refs = this.requestedChunks[chunkNum].refs;\n      const numFiles = range.ranges.length;\n\n      for (let i = 0; i < numFiles; ++i) {\n        const current = range.ranges[i];\n        // @ts-ignore typescript cant parse this\n        callback(false, current.partName, data[typeof data === 'string' ? 'substring' : 'subarray'](current.start, current.stop), this.zipfile.isCompressed(current.partName));\n        if (current.partName in this.requests) {\n          delete this.requests[current.partName];\n        }\n      }\n      // if refs has increased then we already have the data, so run the loop again\n    } while (refs !== this.requestedChunks[chunkNum].refs);\n\n    delete this.requestedChunks[chunkNum];\n  }\n}\n\nclass XODPartHttpPartRetriever extends HttpPartRetriever {\n  parentRetriever: HttpPartRetriever;\n\n  startOffset: number;\n\n  endOffset: number;\n\n  constructor(partRetriever: HttpPartRetriever, start: number, end: number) {\n    super();\n\n    // eslint-disable-next-line\n    for (let prop in partRetriever) {\n      // @ts-ignore ???????? AGGGHHHHHH\n      this[prop] = partRetriever[prop];\n    }\n\n    this.parentRetriever = partRetriever;\n    this.startOffset = start;\n    this.endOffset = end;\n\n    // need to override the createRangeRequest function on the prototype\n    this.createRangeRequest = (url, range, customHeaders, withCredentials) => {\n      if (isUndefined(range.stop)) {\n        range.start += this.endOffset;\n        range.stop = this.endOffset;\n      } else {\n        range.start += this.startOffset;\n        range.stop += this.startOffset;\n      }\n\n      // update the url, possibly necessary for part retrievers that extend HttpPartRetriever\n      const updatedUrl = this.createRangeURL(this.url, range, this.cacheHint);\n\n      return new partRetriever.rangeRequest(updatedUrl, range, customHeaders, withCredentials);\n    };\n  }\n}\n\nexport {\n  ByteRangeRequest,\n};\n\nexportEventHandler(HttpPartRetriever);\nexportPartRetrieverFunctions(HttpPartRetriever);\n\nexport default HttpPartRetriever;"],"mappings":";AAAA;ACiFA;AA+BA;AAkCA;AAiDA;AA0EA;AAqCA;AA+DA;AAyCA;AA2BA;AAyDA;AAnQA;","sourceRoot":""}