{"version":3,"file":"StreamingPartRetriever.chunk.js","sources":["webpack:///StreamingPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/StreamingPartRetriever.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[11],{\n\n/***/ 527:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(177);\n/* harmony import */ var _util_events_EventHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(51);\n/* harmony import */ var _PartRetriever__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(113);\n/* harmony import */ var _ZipFile__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(294);\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(85);\n/* harmony import */ var _util_constants_status__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(293);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(439);\n\n\n\n\n\n\n\n\n\n\nvar exports = window;\nvar INCREMENTAL_READ_AMOUNT = 3000000;\n/**\n * Construct a new StreamingRequest.\n * @name StreamingRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nvar StreamingRequest = /** @class */ (function () {\n    function StreamingRequest(url, cacheHint, customHeaders) {\n        var questionString = (url.indexOf('?') === -1 ? '?' : '&');\n        switch (cacheHint) {\n            case _constants__WEBPACK_IMPORTED_MODULE_7__[/* CacheHinting */ \"a\"]['NEVER_CACHE']:\n                // Add a unique id into the URL so the browser never caches\n                this.url = url + questionString + \"_=\" + Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"uniqueId\"])();\n                break;\n            // other types of caching just use the url\n            default:\n                this.url = url;\n                break;\n        }\n        this.customHeaders = customHeaders;\n        this.request = new XMLHttpRequest();\n        this.request.open('GET', this.url, true);\n        this.request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n        if (this.request.overrideMimeType) {\n            this.request.overrideMimeType('text/plain; charset=x-user-defined');\n        }\n        else {\n            // Is this required for all servers? Only done for IE\n            this.request.setRequestHeader('Accept-Charset', 'x-user-defined');\n        }\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['NOT_STARTED'];\n    }\n    StreamingRequest.prototype.start = function (customHeaders, withCredentials) {\n        var _this = this;\n        var self = this;\n        var request = this.request;\n        var data;\n        self.lastRead = 0;\n        if (customHeaders) {\n            Object.keys(customHeaders).forEach(function (header) {\n                _this.request.setRequestHeader(header, customHeaders[header]);\n            });\n        }\n        if (withCredentials) {\n            this.request.withCredentials = withCredentials;\n        }\n        var timerFunction = function () {\n            var isFromFile = window.document.URL.indexOf('file:///') === 0;\n            var isSuccess = request.status === 200 || (isFromFile && request.status === 0);\n            if (request.readyState === _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* XHRStatus */ \"b\"].DONE && !isSuccess) {\n                clearInterval(self.pollTimer);\n                self.trigger(StreamingRequest['Events']['DONE'], [\"Error received return status \" + request.status]);\n                return;\n            }\n            try {\n                // it's possible for IE9 to get here and throw an error if the responseText property\n                // (and a few other properties) are simply accessed\n                // in this case we can just catch the error and return\n                // the function will be called again later since it's on a setInterval\n                // eslint-disable-next-line no-unused-expressions\n                request.responseText;\n            }\n            catch (e) {\n                return;\n            }\n            if (self.lastRead < request.responseText.length) {\n                data = self.readBody();\n                if (data) {\n                    self.trigger(StreamingRequest['Events']['DATA'], [data]);\n                }\n            }\n            if (request.readyState === 0) {\n                clearInterval(self.pollTimer);\n                self.trigger(StreamingRequest['Events']['DONE']);\n            }\n        };\n        // @ts-ignore\n        this.pollTimer = setInterval(timerFunction, 1000);\n        this.request.send(null);\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['STARTED'];\n    };\n    /**\n     * Parses the body in chunks by keeping track of the last read position.\n     * @method StreamingRequest#readBody\n     * @ignore\n     */\n    StreamingRequest.prototype.readBody = function () {\n        var request = this.request;\n        var text = request.responseText;\n        if (text.length === 0) {\n            return;\n        }\n        if (this.lastRead === text.length) {\n            clearInterval(this.pollTimer);\n            this.trigger(StreamingRequest['Events']['DONE']);\n            return;\n        }\n        var endLocation = Math.min(this.lastRead + INCREMENTAL_READ_AMOUNT, text.length);\n        // @ts-ignore TODO-TS change this once getRequestData is exported\n        var result = exports.getRequestData(request, this.lastRead, true, endLocation);\n        this.lastRead = endLocation;\n        return result;\n    };\n    StreamingRequest.prototype.abort = function () {\n        clearInterval(this.pollTimer);\n        var self = this;\n        // Override normal handler to catch aborted request\n        this.request.onreadystatechange = function () {\n            Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])('StreamingRequest aborted');\n            self.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['ABORTED'];\n            return self.trigger(StreamingRequest['Events']['ABORTED']);\n        };\n        this.request.abort();\n    };\n    StreamingRequest.prototype.finish = function () {\n        var self = this;\n        // Override normal handler to catch last callback\n        this.request.onreadystatechange = function () {\n            self.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_8__[/* RequestStatus */ \"a\"]['SUCCESS'];\n            return self.trigger(StreamingRequest['Events']['DONE']);\n        };\n        this.request.abort();\n    };\n    StreamingRequest['Events'] = {\n        'DONE': 'done',\n        'DATA': 'data',\n        'ABORTED': 'aborted'\n    };\n    return StreamingRequest;\n}());\nObject(_util_events_EventHandler__WEBPACK_IMPORTED_MODULE_4__[/* useEventHandler */ \"a\"])(StreamingRequest);\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"LOCAL_HEADER\"] = 0] = \"LOCAL_HEADER\";\n    ReadState[ReadState[\"FILE\"] = 1] = \"FILE\";\n    ReadState[ReadState[\"CENTRAL_DIR\"] = 2] = \"CENTRAL_DIR\";\n})(ReadState || (ReadState = {}));\n/**\n * A Zipfile that buffers partial data and parses the local file headers\n * instead of the central directory.\n * @constructor\n */\nvar StreamingZipfile = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(StreamingZipfile, _super);\n    function StreamingZipfile() {\n        var _this = \n        // @ts-ignore TODO-TS come back once done\n        _super.call(this) || this;\n        // TODO: make this into an array of chunks for performance?\n        _this.buffer = '';\n        _this.state = ReadState['LOCAL_HEADER'];\n        _this.sigSize = 4;\n        // The last local header that was read\n        _this.lastHeader = null;\n        // The size of the next block of data\n        _this.nextBlockSize = _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* LocalHeaderSize */ \"c\"];\n        _this.fileHeaders = {};\n        return _this;\n    }\n    /**\n     * Processes a new chunk of data from the zipfile, buffering it if necessary.\n     * @method StreamingZipfile#processData\n     * @param {string} data The chunk of data.\n     * @return {boolean} true if all useful data has been read from the zipfile\n     * (i.e. central directory has been reached)\n     */\n    StreamingZipfile.prototype.processData = function (data) {\n        var buffer;\n        var header;\n        buffer = this.buffer + data;\n        while (buffer.length >= this.nextBlockSize) {\n            switch (this.state) {\n                case ReadState['LOCAL_HEADER']:\n                    header = this.readLocalHeader(buffer.slice(0, this.nextBlockSize));\n                    this.lastHeader = header;\n                    if (header.signature !== _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* localHeaderSig */ \"g\"]) {\n                        throw new Error(\"Wrong signature in local header: \" + header.signature);\n                    }\n                    buffer = buffer.slice(this.nextBlockSize);\n                    this.state = ReadState['FILE'];\n                    // add the sig size since we're going to try to read the next header sig\n                    this.nextBlockSize = header.cSize + header.nameLen + header.extraLen + this.sigSize;\n                    this.trigger(StreamingZipfile['Events']['HEADER'], [header]);\n                    break;\n                case ReadState['FILE']:\n                    this.lastHeader.name = buffer.slice(0, this.lastHeader.nameLen);\n                    this.fileHeaders[this.lastHeader.name] = this.lastHeader;\n                    // subtract the sig size to get the data size because the data doesn't include the next sig\n                    var dataSize = this.nextBlockSize - this.sigSize;\n                    var fileOffset = this.lastHeader.nameLen + this.lastHeader.extraLen;\n                    var fileData = buffer.slice(fileOffset, dataSize);\n                    this.trigger(StreamingZipfile['Events']['FILE'], [this.lastHeader.name, fileData, this.lastHeader.compression]);\n                    buffer = buffer.slice(dataSize);\n                    var sig = buffer.slice(0, this.sigSize);\n                    if (sig === _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* localHeaderSigStr */ \"h\"]) {\n                        this.state = ReadState['LOCAL_HEADER'];\n                        this.nextBlockSize = _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_3__[/* LocalHeaderSize */ \"c\"];\n                    }\n                    else {\n                        this.state = ReadState['CENTRAL_DIR'];\n                        return true;\n                    }\n                    break;\n                case ReadState['CENTRAL_DIR']:\n                    break;\n            }\n        }\n        // Store in buffer for next callback\n        this.buffer = buffer;\n        return false;\n    };\n    StreamingZipfile['Events'] = {\n        'HEADER': 'header',\n        'FILE': 'file',\n    };\n    return StreamingZipfile;\n}(_ZipFile__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"]));\nObject(_util_events_EventHandler__WEBPACK_IMPORTED_MODULE_4__[/* useEventHandler */ \"a\"])(StreamingZipfile);\n/**\n * Constructs a new StreamingPartRetriever.\n * StreamingPartRetriever streams a .xod file hosted on a web server and display pages as they are available.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a streaming part retriever.\n * @name StreamingPartRetriever\n * @extends Core.PartRetrievers.PartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {password: \"pass\", type: \"aes\"}\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nvar StreamingPartRetriever = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(StreamingPartRetriever, _super);\n    function StreamingPartRetriever(url, cacheHint, decrypt, decryptOptions, customHeaders) {\n        var _this = _super.call(this, url, decrypt, decryptOptions) || this;\n        _this.url = url;\n        _this.stream = new StreamingRequest(url, cacheHint);\n        _this.zipfile = new StreamingZipfile();\n        _this.partsLoadedPromise = window.createPromiseCapability();\n        _this.receivedMap = {};\n        _this.customHeaders = customHeaders;\n        return _this;\n    }\n    /**\n     * Requests the information necessary to initialize the Document.\n     * @method StreamingPartRetriever#requestDocument\n     */\n    StreamingPartRetriever.prototype.requestDocument = function (callback) {\n        var self = this;\n        this.request([this.FDOC, this.CORE_XML, this.DOCSTRUCT_STRUCT]);\n        this.stream.addEventListener(StreamingRequest['Events']['DATA'], function (data) {\n            try {\n                var finished = self.zipfile.processData(data);\n                if (finished) {\n                    return self.stream.finish();\n                }\n            }\n            catch (err) {\n                self.stream.abort();\n                self.errorCallback(err);\n                callback(err);\n                throw err;\n            }\n        });\n        this.stream.addEventListener(StreamingRequest['Events']['DONE'], function (err) {\n            self.partsLoaded = true;\n            self.partsLoadedPromise.resolve();\n            if (err) {\n                self.errorCallback(err);\n                callback(err);\n            }\n        });\n        this.zipfile.addEventListener(StreamingZipfile['Events']['HEADER'], Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"bind\"])(this.receivedHeader, this));\n        this.zipfile.addEventListener(StreamingZipfile['Events']['FILE'], Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"bind\"])(this.receivedFile, this));\n        return this.stream.start(this.customHeaders, this.withCredentials);\n    };\n    StreamingPartRetriever.prototype.getPartsList = function (callback) {\n        // we need to wait until all the parts are loaded so that we know their names\n        var me = this;\n        this.partsLoadedPromise.promise.then(function () {\n            callback(Object.keys(me.zipfile.fileHeaders));\n        });\n    };\n    StreamingPartRetriever.prototype.requiresCache = function () {\n        return true;\n    };\n    StreamingPartRetriever.prototype.request = function (parts) {\n        // We're not going to actually request the data here because we just\n        // emit the parts as they come in. Instead we keep track of the requests\n        // and if everything has already been loaded and we haven't received data\n        // for the part then this is an error\n        var me = this;\n        if (this.partsLoaded) {\n            parts.forEach(function (part) {\n                if (!me.receivedMap[part]) {\n                    me.triggerError(part);\n                }\n            });\n        }\n    };\n    StreamingPartRetriever.prototype.receivedHeader = function () {\n        // NOOP\n    };\n    StreamingPartRetriever.prototype.abort = function () {\n        if (this.stream) {\n            this.stream.abort();\n        }\n    };\n    StreamingPartRetriever.prototype.triggerError = function (partName) {\n        this.trigger(_PartRetriever__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]['Events']['PART_READY'], [{\n                part: partName,\n                error: 'Requested part not found',\n                completedSynchronously: false,\n                cancelled: false,\n            }]);\n    };\n    StreamingPartRetriever.prototype.receivedFile = function (fileName, fileData, compressed) {\n        this.receivedMap[fileName] = true;\n        this.trigger(_PartRetriever__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]['Events']['PART_READY'], [{\n                part: fileName,\n                data: fileData,\n                completedSynchronously: false,\n                cancelled: false,\n                error: null,\n                compressed: compressed,\n            }]);\n    };\n    return StreamingPartRetriever;\n}(_PartRetriever__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]));\nObject(_Exports__WEBPACK_IMPORTED_MODULE_9__[/* exportEventHandler */ \"a\"])(StreamingPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_9__[/* exportPartRetrieverFunctions */ \"b\"])(StreamingPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (StreamingPartRetriever);\n\n\n/***/ })\n\n}]);","import { uniqueId, bind } from 'lodash';\nimport { warn } from 'logger';\nimport { LocalHeaderSize, localHeaderSigStr, localHeaderSig } from '../../util/constants/zipfile';\nimport { PromiseCapability } from '../../global';\nimport EventHandler, { useEventHandler } from '../../util/events/EventHandler';\nimport PartRetriever, { PartRetrieverHeaders, PartRetrieverDecrypt, PartRetrieverDecryptOptions } from './PartRetriever';\nimport Zipfile, { LocalHeader } from './ZipFile';\nimport { CacheHinting } from './constants';\nimport { RequestStatus, XHRStatus } from '../../util/constants/status';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\n\nconst exports = window;\n\nconst INCREMENTAL_READ_AMOUNT = 3000000;\n\n/**\n * Construct a new StreamingRequest.\n * @name StreamingRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nclass StreamingRequest {\n  status: RequestStatus;\n\n  url: string;\n\n  request: XMLHttpRequest;\n\n  lastRead: number;\n\n  pollTimer: number;\n\n  customHeaders: PartRetrieverHeaders;\n\n  static 'Events' = {\n    'DONE': 'done',\n    'DATA': 'data',\n    'ABORTED': 'aborted'\n  } as const;\n\n  constructor(url: string, cacheHint: CacheHinting, customHeaders?: PartRetrieverHeaders) {\n    const questionString = (url.indexOf('?') === -1 ? '?' : '&');\n\n    switch (cacheHint) {\n      case CacheHinting['NEVER_CACHE']:\n      // Add a unique id into the URL so the browser never caches\n        this.url = `${url + questionString}_=${uniqueId()}`;\n        break;\n\n      // other types of caching just use the url\n      default:\n        this.url = url;\n        break;\n    }\n\n    this.customHeaders = customHeaders;\n    this.request = new XMLHttpRequest();\n    this.request.open('GET', this.url, true);\n    this.request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n    if (this.request.overrideMimeType) {\n      this.request.overrideMimeType('text/plain; charset=x-user-defined');\n    } else {\n      // Is this required for all servers? Only done for IE\n      this.request.setRequestHeader('Accept-Charset', 'x-user-defined');\n    }\n    this.status = RequestStatus['NOT_STARTED'];\n  }\n\n  start(customHeaders: PartRetrieverHeaders, withCredentials: boolean) {\n    const self = this;\n    const request = this.request;\n    let data: string;\n    self.lastRead = 0;\n\n    if (customHeaders) {\n      Object.keys(customHeaders).forEach((header) => {\n        this.request.setRequestHeader(header, customHeaders[header]);\n      });\n    }\n\n    if (withCredentials) {\n      this.request.withCredentials = withCredentials;\n    }\n\n    const timerFunction = function() {\n      const isFromFile = window.document.URL.indexOf('file:///') === 0;\n      const isSuccess = request.status === 200 || (isFromFile && request.status === 0);\n\n      if (request.readyState === XHRStatus.DONE && !isSuccess) {\n        clearInterval(self.pollTimer);\n        self.trigger(StreamingRequest['Events']['DONE'], [`Error received return status ${request.status}`]);\n        return;\n      }\n\n      try {\n        // it's possible for IE9 to get here and throw an error if the responseText property\n        // (and a few other properties) are simply accessed\n        // in this case we can just catch the error and return\n        // the function will be called again later since it's on a setInterval\n        // eslint-disable-next-line no-unused-expressions\n        request.responseText;\n      } catch (e) {\n        return;\n      }\n\n      if (self.lastRead < request.responseText.length) {\n        data = self.readBody();\n        if (data) {\n          self.trigger(StreamingRequest['Events']['DATA'], [data]);\n        }\n      }\n\n      if (request.readyState === 0) {\n        clearInterval(self.pollTimer);\n        self.trigger(StreamingRequest['Events']['DONE']);\n      }\n    };\n\n    // @ts-ignore\n    this.pollTimer = setInterval(timerFunction, 1000);\n\n    this.request.send(null);\n    this.status = RequestStatus['STARTED'];\n  }\n\n  /**\n   * Parses the body in chunks by keeping track of the last read position.\n   * @method StreamingRequest#readBody\n   * @ignore\n   */\n  readBody() {\n    const request = this.request;\n    const text = request.responseText;\n    if (text.length === 0) {\n      return;\n    }\n\n    if (this.lastRead === text.length) {\n      clearInterval(this.pollTimer);\n      this.trigger(StreamingRequest['Events']['DONE']);\n      return;\n    }\n    const endLocation = Math.min(this.lastRead + INCREMENTAL_READ_AMOUNT, text.length);\n    // @ts-ignore TODO-TS change this once getRequestData is exported\n    const result: string = exports.getRequestData(request, this.lastRead, true, endLocation);\n    this.lastRead = endLocation;\n\n    return result;\n  }\n\n  abort() {\n    clearInterval(this.pollTimer);\n    const self = this;\n    // Override normal handler to catch aborted request\n    this.request.onreadystatechange = function() {\n      warn('StreamingRequest aborted');\n      self.status = RequestStatus['ABORTED'];\n      return self.trigger(StreamingRequest['Events']['ABORTED']);\n    };\n    this.request.abort();\n  }\n\n  finish() {\n    const self = this;\n    // Override normal handler to catch last callback\n    this.request.onreadystatechange = function() {\n      self.status = RequestStatus['SUCCESS'];\n      return self.trigger(StreamingRequest['Events']['DONE']);\n    };\n    this.request.abort();\n  }\n}\n\ntype StreamingRequestEvents = {\n  [StreamingRequest.Events.DONE]: [string?];\n  [StreamingRequest.Events.ABORTED]: [];\n  [StreamingRequest.Events.DATA]: [string];\n}\ninterface StreamingRequest extends EventHandler<StreamingRequestEvents> { }\nuseEventHandler(StreamingRequest);\n\nenum ReadState {\n  LOCAL_HEADER = 0,\n  FILE = 1,\n  CENTRAL_DIR = 2,\n}\n\n/**\n * A Zipfile that buffers partial data and parses the local file headers\n * instead of the central directory.\n * @constructor\n */\nclass StreamingZipfile extends Zipfile {\n  buffer: string;\n\n  state: ReadState;\n\n  sigSize: number;\n\n  lastHeader: LocalHeader;\n\n  nextBlockSize: number;\n\n  fileHeaders: {\n    [name: string]: any;\n  }\n\n  static 'Events' = {\n    'HEADER': 'header',\n    'FILE': 'file',\n  } as const\n\n  constructor() {\n    // @ts-ignore TODO-TS come back once done\n    super();\n\n    // TODO: make this into an array of chunks for performance?\n    this.buffer = '';\n    this.state = ReadState['LOCAL_HEADER'];\n    this.sigSize = 4;\n\n    // The last local header that was read\n    this.lastHeader = null;\n\n    // The size of the next block of data\n    this.nextBlockSize = LocalHeaderSize;\n\n    this.fileHeaders = {};\n  }\n\n  /**\n   * Processes a new chunk of data from the zipfile, buffering it if necessary.\n   * @method StreamingZipfile#processData\n   * @param {string} data The chunk of data.\n   * @return {boolean} true if all useful data has been read from the zipfile\n   * (i.e. central directory has been reached)\n   */\n  processData(data: string) {\n    let buffer;\n    let header;\n\n    buffer = this.buffer + data;\n\n    while (buffer.length >= this.nextBlockSize) {\n      switch (this.state) {\n        case ReadState['LOCAL_HEADER']:\n\n          header = this.readLocalHeader(buffer.slice(0, this.nextBlockSize));\n          this.lastHeader = header;\n\n          if (header.signature !== localHeaderSig) {\n            throw new Error(`Wrong signature in local header: ${header.signature}`);\n          }\n\n          buffer = buffer.slice(this.nextBlockSize);\n          this.state = ReadState['FILE'];\n          // add the sig size since we're going to try to read the next header sig\n          this.nextBlockSize = header.cSize + header.nameLen + header.extraLen + this.sigSize;\n          this.trigger(StreamingZipfile['Events']['HEADER'], [header]);\n          break;\n\n        case ReadState['FILE']:\n          this.lastHeader.name = buffer.slice(0, this.lastHeader.nameLen);\n          this.fileHeaders[this.lastHeader.name] = this.lastHeader;\n\n          // subtract the sig size to get the data size because the data doesn't include the next sig\n          const dataSize = this.nextBlockSize - this.sigSize;\n          const fileOffset = this.lastHeader.nameLen + this.lastHeader.extraLen;\n          const fileData = buffer.slice(fileOffset, dataSize);\n\n          this.trigger(StreamingZipfile['Events']['FILE'], [this.lastHeader.name, fileData, this.lastHeader.compression]);\n\n          buffer = buffer.slice(dataSize);\n          const sig = buffer.slice(0, this.sigSize);\n          if (sig === localHeaderSigStr) {\n            this.state = ReadState['LOCAL_HEADER'];\n            this.nextBlockSize = LocalHeaderSize;\n          } else {\n            this.state = ReadState['CENTRAL_DIR'];\n            return true;\n          }\n          break;\n\n        case ReadState['CENTRAL_DIR']:\n\n          break;\n      }\n    }\n\n    // Store in buffer for next callback\n    this.buffer = buffer;\n\n    return false;\n  }\n}\n\ntype StreamingZipfileEvents = {\n  [StreamingZipfile.Events.FILE]: [string, string, number];\n  [StreamingZipfile.Events.HEADER]: [LocalHeader];\n}\n\ninterface StreamingZipfile extends EventHandler<StreamingZipfileEvents> { }\nuseEventHandler(StreamingZipfile);\n\n/**\n * Constructs a new StreamingPartRetriever.\n * StreamingPartRetriever streams a .xod file hosted on a web server and display pages as they are available.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a streaming part retriever.\n * @name StreamingPartRetriever\n * @extends Core.PartRetrievers.PartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {password: \"pass\", type: \"aes\"}\n * @param {Object} [customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nclass StreamingPartRetriever extends PartRetriever {\n  url: string;\n\n  stream: StreamingRequest;\n\n  zipfile: StreamingZipfile;\n\n  partsLoadedPromise: PromiseCapability<any>;\n\n  receivedMap: {\n    [name: string]: boolean;\n  };\n\n  partsLoaded?: boolean;\n\n  constructor(url: string, cacheHint: CacheHinting, decrypt: PartRetrieverDecrypt, decryptOptions: PartRetrieverDecryptOptions, customHeaders?: PartRetrieverHeaders) {\n    super(url, decrypt, decryptOptions);\n\n    this.url = url;\n    this.stream = new StreamingRequest(url, cacheHint);\n    this.zipfile = new StreamingZipfile();\n    this.partsLoadedPromise = window.createPromiseCapability();\n    this.receivedMap = {};\n    this.customHeaders = customHeaders;\n  }\n\n  /**\n   * Requests the information necessary to initialize the Document.\n   * @method StreamingPartRetriever#requestDocument\n   */\n  requestDocument(callback: (err: string) => void) {\n    const self = this;\n    this.request([this.FDOC, this.CORE_XML, this.DOCSTRUCT_STRUCT]);\n\n    this.stream.addEventListener(StreamingRequest['Events']['DATA'], function(data) {\n      try {\n        const finished = self.zipfile.processData(data);\n\n        if (finished) {\n          return self.stream.finish();\n        }\n      } catch (err) {\n        self.stream.abort();\n        self.errorCallback(err);\n        callback(err);\n        throw err;\n      }\n    });\n\n    this.stream.addEventListener(StreamingRequest['Events']['DONE'], function(err) {\n      self.partsLoaded = true;\n      self.partsLoadedPromise.resolve();\n      if (err) {\n        self.errorCallback(err);\n        callback(err);\n      }\n    });\n\n    this.zipfile.addEventListener(StreamingZipfile['Events']['HEADER'], bind(this.receivedHeader, this));\n    this.zipfile.addEventListener(StreamingZipfile['Events']['FILE'], bind(this.receivedFile, this));\n\n    return this.stream.start(this.customHeaders, this.withCredentials);\n  }\n\n  getPartsList(callback: (parts: Array<string>) => void) {\n    // we need to wait until all the parts are loaded so that we know their names\n    const me = this;\n    this.partsLoadedPromise.promise.then(function() {\n      callback(Object.keys(me.zipfile.fileHeaders));\n    });\n  }\n\n  requiresCache() {\n    return true;\n  }\n\n\n  request(parts: Array<string>) {\n    // We're not going to actually request the data here because we just\n    // emit the parts as they come in. Instead we keep track of the requests\n    // and if everything has already been loaded and we haven't received data\n    // for the part then this is an error\n    const me = this;\n    if (this.partsLoaded) {\n      parts.forEach(function(part) {\n        if (!me.receivedMap[part]) {\n          me.triggerError(part);\n        }\n      });\n    }\n  }\n\n  receivedHeader() {\n    // NOOP\n  }\n\n  abort() {\n    if (this.stream) {\n      this.stream.abort();\n    }\n  }\n\n  triggerError(partName: string) {\n    this.trigger(PartRetriever['Events']['PART_READY'], [{\n      part: partName,\n      error: 'Requested part not found',\n      completedSynchronously: false,\n      cancelled: false,\n    }]);\n  }\n\n  receivedFile(fileName: string, fileData: any, compressed?: boolean) {\n    this.receivedMap[fileName] = true;\n\n    this.trigger(PartRetriever['Events']['PART_READY'], [{\n      part: fileName,\n      data: fileData,\n      completedSynchronously: false,\n      cancelled: false,\n      error: null,\n      compressed: compressed,\n    }]);\n  }\n}\n\nexportEventHandler(StreamingPartRetriever);\nexportPartRetrieverFunctions(StreamingPartRetriever);\n\nexport default StreamingPartRetriever;"],"mappings":";AAAA;AC4DA;AA6BA;AAqDA;AA1GA;AAyNA;AA3CA;AAkKA;AAqCA;","sourceRoot":""}