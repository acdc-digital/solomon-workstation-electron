{"version":3,"file":"LocalPartRetriever.chunk.js","sources":["webpack:///LocalPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/LocalPartRetriever.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[7],{\n\n/***/ 520:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);\n/* harmony import */ var _PartRetriever__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(113);\n/* harmony import */ var _ZipFile__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(294);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(439);\n\n\n\n\n\n\nvar exports = window;\n// Limit the number of ongoing requests because iOS11 seems to have limit on the number of threads at a time\n// Each request is handled by a separate iOS native thread\nvar MAX_ONGOING_REQUESTS = 50;\n/**\n * Constructs a new LocalPartRetriever.\n * LocalPartRetriever retrieves {@link Core.Document} parts asynchronously from locally hosted .xod file. Requires a fully-functional file API.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers.getPartRetriever} function instead.\n * @class Represents a local part retriever.\n * @name LocalPartRetriever\n * @memberof Core.PartRetrievers\n * @param {File} file The local file reference to read data from.\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {password: \"pass\", type: \"aes\"}\n * @ignore\n */\nvar LocalPartRetriever = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(LocalPartRetriever, _super);\n    function LocalPartRetriever(file, decrypt, decryptOptions) {\n        var _this = _super.call(this, file, decrypt, decryptOptions) || this;\n        // the name property may not be set in the case of blobs\n        if (file.name && file.name.toLowerCase().split('.').pop() !== 'xod') {\n            throw new Error('Not an XOD file');\n        }\n        if (!exports.FileReader || !exports.File || !exports.Blob) {\n            throw new Error('File API is not supported in this browser');\n        }\n        _this.file = file;\n        _this.chunkQueue = [];\n        _this.currentOngoingRequests = 0;\n        return _this;\n    }\n    /**\n     * Loads a chunk of the given local file using the File API.\n     * @method LocalPartRetriever#loadChunk\n     * @param {File} file The local file reference to read data from.\n     * @param {{start:number,stop:number}} slice The start and stop index of the slice to read.\n     * @param {function(err, string)} callback The callback for the result.\n     */\n    LocalPartRetriever.prototype.loadChunk = function (file, slice, callback) {\n        var self = this;\n        var reader = new FileReader();\n        reader.onloadend = function (evt) {\n            if (self.chunkQueue.length > 0) {\n                var chunk = self.chunkQueue.shift();\n                chunk.reader.readAsBinaryString(chunk.file);\n            }\n            else {\n                self.currentOngoingRequests--;\n            }\n            if (reader.error) {\n                var err = reader.error;\n                if (err.code === err.ABORT_ERR) {\n                    // Ignore aborted errors\n                    Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])(\"Request for chunk \" + slice.start + \"-\" + slice.stop + \" was aborted\");\n                    return;\n                }\n                return callback(err);\n            }\n            // result && reader.content do not exist on file reader api\n            // @ts-ignore TODO-TS ready.content should be documented\n            var data = reader.content || evt.target.result;\n            if (!data) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])('No data was returned from FileReader.');\n                return;\n            }\n            return callback(false, data);\n        };\n        if (slice) {\n            file = (file.slice || file.webkitSlice || file.mozSlice || file.fakeSlice).call(file, slice.start, slice.stop);\n        }\n        if (self.chunkQueue.length === 0 && self.currentOngoingRequests < MAX_ONGOING_REQUESTS) {\n            reader.readAsBinaryString(file);\n            self.currentOngoingRequests++;\n        }\n        else {\n            self.chunkQueue.push({ reader: reader, file: file });\n        }\n        return function cancel() {\n            reader.abort();\n        };\n    };\n    LocalPartRetriever.prototype.loadHeaders = function (callback) {\n        var self = this;\n        self.centralDirectoryLoading = true;\n        var zipHeaderSize = _util_constants_zipfile__WEBPACK_IMPORTED_MODULE_2__[/* EndHeaderSize */ \"a\"];\n        self.loadChunk(self.file, { start: -zipHeaderSize, stop: self.file.size }, function (err, data) {\n            if (err) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])(\"Error loading end header: %s \" + err);\n                return callback(err);\n            }\n            if (data.length !== zipHeaderSize) {\n                throw new Error('Zip end header data is wrong size!');\n            }\n            self.zipfile = new _ZipFile__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"](data);\n            var range = self.zipfile.getDirectoryRange();\n            self.loadChunk(self.file, range, function (err, data) {\n                if (err) {\n                    Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])(\"Error loading central directory: %s \" + err);\n                    return callback(err);\n                }\n                if (data.length !== (range.stop - range.start)) {\n                    throw new Error('Zip central directory data is wrong size!');\n                }\n                self.zipfile.readCentralDirectory(data);\n                self.centralDirectoryLoaded = true;\n                self.centralDirectoryLoading = false;\n                return callback(false);\n            });\n        });\n    };\n    LocalPartRetriever.prototype.readPart = function (part, callback) {\n        var self = this;\n        var request = self.requests[part];\n        if (!self.zipfile.containsFile(part)) {\n            return callback(new Error(\"File not found: \\\"\" + part + \"\\\"\"), part);\n        }\n        var range = self.zipfile.getFileRange(part);\n        var cancel = self.loadChunk(self.file, range, function (err, data) {\n            delete self.requests[part];\n            if (err) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])(\"Error loading part \\\"%s\\\": %s, \" + part + \", \" + err);\n                return callback(err);\n            }\n            if (data.length !== (range.stop - range.start)) {\n                throw new Error('Part data is wrong size!');\n            }\n            var compressed = self.zipfile.isCompressed(part);\n            callback(false, part, data, compressed);\n        });\n        request.started = true;\n        request.cancel = cancel;\n    };\n    return LocalPartRetriever;\n}(_PartRetriever__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"]));\nObject(_Exports__WEBPACK_IMPORTED_MODULE_5__[/* exportEventHandler */ \"a\"])(LocalPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_5__[/* exportPartRetrieverFunctions */ \"b\"])(LocalPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (LocalPartRetriever);\n\n\n/***/ })\n\n}]);","import { warn } from 'logger';\nimport { EndHeaderSize } from '../../util/constants/zipfile';\nimport PartRetriever, { PartRetrieverDecrypt, PartRetrieverDecryptOptions, PartRetrieverRange } from './PartRetriever';\nimport Zipfile from './ZipFile';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\n\nconst exports = window;\n\n// Limit the number of ongoing requests because iOS11 seems to have limit on the number of threads at a time\n// Each request is handled by a separate iOS native thread\nconst MAX_ONGOING_REQUESTS = 50;\n\n/**\n * Constructs a new LocalPartRetriever.\n * LocalPartRetriever retrieves {@link Core.Document} parts asynchronously from locally hosted .xod file. Requires a fully-functional file API.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers.getPartRetriever} function instead.\n * @class Represents a local part retriever.\n * @name LocalPartRetriever\n * @memberof Core.PartRetrievers\n * @param {File} file The local file reference to read data from.\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {password: \"pass\", type: \"aes\"}\n * @ignore\n */\n\nclass LocalPartRetriever extends PartRetriever {\n  file: File;\n\n  chunkQueue: Array<any>\n\n  currentOngoingRequests: number;\n\n  zipfile: Zipfile;\n\n  constructor(file: File, decrypt: PartRetrieverDecrypt, decryptOptions: PartRetrieverDecryptOptions) {\n    super(file, decrypt, decryptOptions);\n\n    // the name property may not be set in the case of blobs\n    if (file.name && file.name.toLowerCase().split('.').pop() !== 'xod') {\n      throw new Error('Not an XOD file');\n    }\n\n    if (!exports.FileReader || !exports.File || !exports.Blob) {\n      throw new Error('File API is not supported in this browser');\n    }\n\n    this.file = file;\n    this.chunkQueue = [];\n    this.currentOngoingRequests = 0;\n  }\n\n  /**\n   * Loads a chunk of the given local file using the File API.\n   * @method LocalPartRetriever#loadChunk\n   * @param {File} file The local file reference to read data from.\n   * @param {{start:number,stop:number}} slice The start and stop index of the slice to read.\n   * @param {function(err, string)} callback The callback for the result.\n   */\n  loadChunk(file: File, slice: PartRetrieverRange, callback: (err: Error|DOMException|boolean, data?: string|ArrayBuffer) => void) {\n    const self = this;\n    const reader = new FileReader();\n\n    reader.onloadend = function(evt) {\n      if (self.chunkQueue.length > 0) {\n        const chunk = self.chunkQueue.shift();\n        chunk.reader.readAsBinaryString(chunk.file);\n      } else {\n        self.currentOngoingRequests--;\n      }\n\n      if (reader.error) {\n        const err = reader.error;\n        if (err.code === err.ABORT_ERR) {\n          // Ignore aborted errors\n          warn(`Request for chunk ${slice.start}-${slice.stop} was aborted`);\n          return;\n        }\n        return callback(err);\n      }\n\n      // result && reader.content do not exist on file reader api\n      // @ts-ignore TODO-TS ready.content should be documented\n      const data = reader.content || evt.target.result;\n      if (!data) {\n        warn('No data was returned from FileReader.');\n        return;\n      }\n\n      return callback(false, data);\n    };\n\n    if (slice) {\n      file = (file.slice || file.webkitSlice || file.mozSlice || file.fakeSlice).call(file, slice.start, slice.stop);\n    }\n\n    if (self.chunkQueue.length === 0 && self.currentOngoingRequests < MAX_ONGOING_REQUESTS) {\n      reader.readAsBinaryString(file);\n      self.currentOngoingRequests++;\n    } else {\n      self.chunkQueue.push({ reader: reader, file: file });\n    }\n\n    return function cancel() {\n      reader.abort();\n    };\n  }\n\n  loadHeaders(callback: (err: Error|DOMException|boolean) => void) {\n    const self = this;\n\n    self.centralDirectoryLoading = true;\n\n    const zipHeaderSize = EndHeaderSize;\n\n    self.loadChunk(self.file, { start: -zipHeaderSize, stop: self.file.size }, function(err, data) {\n      if (err) {\n        warn(`Error loading end header: %s ${err}`);\n        return callback(err);\n      }\n\n      if ((data as string).length !== zipHeaderSize) {\n        throw new Error('Zip end header data is wrong size!');\n      }\n\n      self.zipfile = new Zipfile(data as string);\n      const range = self.zipfile.getDirectoryRange();\n\n      self.loadChunk(self.file, range, function(err, data) {\n        if (err) {\n          warn(`Error loading central directory: %s ${err}`);\n          return callback(err);\n        }\n        if ((data as string).length !== (range.stop - range.start)) {\n          throw new Error('Zip central directory data is wrong size!');\n        }\n\n        self.zipfile.readCentralDirectory(data as string);\n        self.centralDirectoryLoaded = true;\n        self.centralDirectoryLoading = false;\n        return callback(false);\n      });\n    });\n  }\n\n  readPart(part: string, callback: (err: Error|DOMException|boolean, part?: string, data?: any, compressed?: boolean) => void) {\n    const self = this;\n    const request = self.requests[part];\n\n    if (!self.zipfile.containsFile(part)) {\n      return callback(new Error(`File not found: \"${part}\"`), part);\n    }\n\n    const range = self.zipfile.getFileRange(part);\n    const cancel = self.loadChunk(self.file, range, function(err, data) {\n      delete self.requests[part];\n      if (err) {\n        warn(`Error loading part \"%s\": %s, ${part}, ${err}`);\n        return callback(err);\n      }\n      if ((data as string).length !== (range.stop - range.start)) {\n        throw new Error('Part data is wrong size!');\n      }\n      const compressed = self.zipfile.isCompressed(part);\n      callback(false, part, data, compressed);\n    });\n\n    request.started = true;\n    request.cancel = cancel;\n  }\n}\n\nexportEventHandler(LocalPartRetriever);\nexportPartRetrieverFunctions(LocalPartRetriever);\n\nexport default LocalPartRetriever;\n"],"mappings":";AAAA;AC2DA;AAyCA;AAqCA;","sourceRoot":""}