{"version":3,"file":"PDFInfoVersion1.chunk.js","sources":["webpack:///PDFInfoVersion1.chunk.js","webpack:///./src/core/src/namespaces/PDFInfo/PDFInfoVersion1.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[9],{\n\n/***/ 532:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Annotations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(140);\n/* harmony import */ var _Core_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);\n/* harmony import */ var _Annotations_Color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);\n/* harmony import */ var _util_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(22);\n/* harmony import */ var _PDFInfo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(122);\n/* harmony import */ var _Annotations_Widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(17);\n\n\n\n\n\n\n\n\nfunction parseFieldReference(parser) {\n    return String(parser.findAttribute('name'));\n}\nfunction parseValueElement(parser) {\n    parser.increaseDepth();\n    parser.advance();\n    var value = parser.getCharData();\n    parser.decreaseDepth();\n    return value;\n}\nfunction parseFieldList(parser) {\n    var result = [];\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        if (elementName === 'field') {\n            result.push(parseFieldReference(parser));\n        }\n        else {\n            Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised field list element: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseOptionalBoolean(attr, def) {\n    if (def) {\n        return attr !== 'false';\n    }\n    return attr === 'true';\n}\nfunction parseJavaScriptAction(parser) {\n    return {\n        'name': 'JavaScript',\n        'javascript': parser.getCharData(),\n    };\n}\nfunction parseURIAction(parser) {\n    return {\n        'name': 'URI',\n        'uri': parser.findAttribute('uri'),\n    };\n}\nfunction parseDest(parser, getPageMatrix) {\n    var fit = parser.findAttribute('fit');\n    var result = {\n        'page': parser.findAttribute('page'),\n        'fit': fit,\n    };\n    if (result['page'] === '0') {\n        Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])('null page encountered in dest');\n        return result;\n    }\n    var pageMatrix = getPageMatrix(Number(result['page']));\n    var pt1;\n    var pt2;\n    switch (fit) {\n        case 'Fit':\n        case 'FitB':\n            // no extra properties\n            break;\n        case 'FitH':\n        case 'FitBH':\n            result['top'] = pageMatrix.mult({\n                x: 0,\n                y: (parser.findAttribute('top') || 0)\n            }).y;\n            break;\n        case 'FitV':\n        case 'FitBV':\n            result['left'] = pageMatrix.mult({\n                x: (parser.findAttribute('left') || 0),\n                y: 0\n            }).x;\n            break;\n        case 'FitR':\n            pt1 = pageMatrix.mult({\n                x: (parser.findAttribute('left') || 0),\n                y: (parser.findAttribute('top') || 0),\n            });\n            pt2 = pageMatrix.mult({\n                x: (parser.findAttribute('right') || 0),\n                y: (parser.findAttribute('bottom') || 0),\n            });\n            var tmp = new _Core_Math__WEBPACK_IMPORTED_MODULE_3__[/* Rect */ \"d\"](pt1.x, pt1.y, pt2.x, pt2.y);\n            result['top'] = tmp.y1;\n            result['left'] = tmp.x1;\n            result['bottom'] = tmp.y2;\n            result['right'] = tmp.x2;\n            break;\n        case 'XYZ':\n            pt1 = pageMatrix.mult({\n                x: (parser.findAttribute('left') || 0),\n                y: (parser.findAttribute('top') || 0),\n            });\n            result['top'] = pt1.y;\n            result['left'] = pt1.x;\n            result['zoom'] = parser.findAttribute('zoom') || 0;\n            break;\n        default:\n            Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unknown dest fit: \" + fit);\n    }\n    return result;\n}\nfunction parseGoToAction(parser, getPageMatrix) {\n    var result = null;\n    parser.increaseDepth();\n    if (parser.advance()) {\n        result = {\n            'name': 'GoTo',\n            'dest': parseDest(parser, getPageMatrix),\n        };\n    }\n    else {\n        Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])('missing dest in GoTo action');\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseSubmitFormAction(parser) {\n    var result = {\n        'name': 'SubmitForm',\n        'url': parser.findAttribute('url'),\n        'format': parser.findAttribute('format'),\n        'method': parser.findAttribute('method') || 'POST',\n        'exclude': parseOptionalBoolean(parser.findAttribute('exclude'), false),\n    };\n    var flags = parser.findAttribute('flags');\n    if (flags) {\n        result['flags'] = flags.split(' ');\n    }\n    else {\n        result['flags'] = [];\n    }\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'fields':\n                result['fields'] = parseFieldList(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised submit-form child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseResetFormAction(parser) {\n    var result = {\n        'name': 'ResetForm',\n        'exclude': parseOptionalBoolean(parser.findAttribute('exclude'), false),\n    };\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'fields':\n                result['fields'] = parseFieldList(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised reset-form child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseHideAction(parser) {\n    var result = {\n        'name': 'Hide',\n        'hide': parseOptionalBoolean(parser.findAttribute('hide'), true),\n    };\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'fields':\n                result['fields'] = parseFieldList(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised hide child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseNamedAction(parser) {\n    return {\n        'name': 'Named',\n        'action': parser.findAttribute('name'),\n    };\n}\nfunction parseAction(parser, getPageMatrix) {\n    var elementName = parser.getElementName();\n    switch (elementName) {\n        case 'javascript':\n            return parseJavaScriptAction(parser);\n        case 'uri':\n            return parseURIAction(parser);\n        case 'goto':\n            return parseGoToAction(parser, getPageMatrix);\n        case 'submit-form':\n            return parseSubmitFormAction(parser);\n        case 'reset-form':\n            return parseResetFormAction(parser);\n        case 'hide':\n            return parseHideAction(parser);\n        case 'named':\n            return parseNamedAction(parser);\n        default:\n            Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"Encountered unexpected action type: \" + elementName);\n    }\n    return null;\n}\nfunction parseActions(parser, triggers, getPageMatrix) {\n    var result = {};\n    function isValidTrigger(t) {\n        if (triggers) {\n            return triggers.indexOf(t) !== -1;\n        }\n        return true;\n    }\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'action':\n                var trigger = parser.findAttribute('trigger');\n                if (isValidTrigger(trigger)) {\n                    result[trigger] = [];\n                    parser.increaseDepth();\n                    while (parser.advance()) {\n                        var tmp = parseAction(parser, getPageMatrix);\n                        if (!Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isNull\"])(tmp)) {\n                            result[trigger].push(tmp);\n                        }\n                    }\n                    parser.decreaseDepth();\n                }\n                else {\n                    Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"encountered unexpected trigger on field: \" + trigger);\n                }\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"encountered unknown action child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseCalculationOrder(parser) {\n    var elementName = parser.getElementName();\n    if (elementName === 'calculation-order') {\n        return parseFieldList(parser);\n    }\n    return [];\n}\nfunction parseRect(parser, pageMatrix) {\n    var pt1 = pageMatrix.mult({\n        x: (parser.findAttribute('x1') || 0),\n        y: (parser.findAttribute('y1') || 0),\n    });\n    var pt2 = pageMatrix.mult({\n        x: (parser.findAttribute('x2') || 0),\n        y: (parser.findAttribute('y2') || 0),\n    });\n    var rect = new _Core_Math__WEBPACK_IMPORTED_MODULE_3__[/* Rect */ \"d\"](pt1.x, pt1.y, pt2.x, pt2.y);\n    rect.normalize();\n    return {\n        'x1': rect['x1'],\n        'y1': rect['y1'],\n        'x2': rect['x2'],\n        'y2': rect['y2'],\n    };\n}\nfunction parseColor(parser) {\n    return new _Annotations_Color__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"](parser.findAttribute('r') || 0, parser.findAttribute('g') || 0, parser.findAttribute('b') || 0, parser.findAttribute('a') || 1);\n}\nfunction parseBorder(parser) {\n    var result = {\n        'style': parser.findAttribute('style') || 'Solid',\n        'width': parser.findAttribute('width') || 1,\n        'color': [0, 0, 0],\n    };\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'color':\n                result['color'] = parseColor(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised border child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\n// TODO-TS what is this\nfunction parseAppearance(parser, currentAppearance) {\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'Normal':\n                Object(_PDFInfo__WEBPACK_IMPORTED_MODULE_6__[/* getOrSetKeyFromObj */ \"b\"])(currentAppearance, 'Normal').data = parser.getCharData();\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])('unexpected appearance state: ', elementName);\n        }\n    }\n    parser.decreaseDepth();\n}\nfunction parseAppearances(parser, annot) {\n    var appearancesObj = Object(_PDFInfo__WEBPACK_IMPORTED_MODULE_6__[/* getOrSetKeyFromObj */ \"b\"])(annot, 'appearances');\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        if (elementName === 'appearance') {\n            var name = parser.findAttribute('name');\n            var currentAppearance = Object(_PDFInfo__WEBPACK_IMPORTED_MODULE_6__[/* getOrSetKeyFromObj */ \"b\"])(appearancesObj, name);\n            parseAppearance(parser, currentAppearance);\n        }\n        else {\n            Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unexpected appearances child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n}\nfunction parseFont(parser, pageMatrix) {\n    function fixSize(s) {\n        var pt1 = pageMatrix.mult({\n            x: 0,\n            y: 0,\n        });\n        var pt2 = pageMatrix.mult({\n            x: Number(s),\n            y: 0,\n        });\n        var dx = pt1.x - pt2.x;\n        var dy = pt1.y - pt2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    var result = {\n        'name': parser.findAttribute('name'),\n        'type': parser.findAttribute('type') || 'Type1',\n        'size': fixSize(parser.findAttribute('size')) || 0,\n        'strokeColor': [0, 0, 0],\n        'fillColor': [0, 0, 0],\n    };\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'stroke-color':\n                result['strokeColor'] = parseColor(parser);\n                break;\n            case 'fill-color':\n                result['fillColor'] = parseColor(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised font child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseExtra(parser, getPageMatrix) {\n    var result = {};\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'font':\n                result.font = parseFont(parser, getPageMatrix(1));\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised extra child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseCaptions(parser) {\n    var result = {};\n    var normal = parser.findAttribute('Normal');\n    if (normal) {\n        result['Normal'] = normal;\n    }\n    var rollover = parser.findAttribute('Rollover');\n    if (rollover) {\n        result['Rollover'] = rollover;\n    }\n    var down = parser.findAttribute('Down');\n    if (down) {\n        result['Down'] = down;\n    }\n    return result;\n}\nfunction parseWidget(parser, getPageMatrix) {\n    var result = {\n        'border': {\n            'style': 'Solid',\n            'width': 1,\n        },\n        'backgroundColor': [],\n        'fieldName': parser.findAttribute('field'),\n        'page': parser.findAttribute('page'),\n        'index': parser.findAttribute('index') || 0,\n        'rotation': parser.findAttribute('rotation') || 0,\n        'flags': [],\n        'isImporting': true,\n    };\n    var appearance = parser.findAttribute('appearance');\n    if (appearance) {\n        result['appearance'] = appearance;\n    }\n    var flags = parser.findAttribute('flags');\n    if (flags) {\n        result['flags'] = flags.split(' ');\n    }\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'rect':\n                result['rect'] = parseRect(parser, getPageMatrix(Number(result['page'])));\n                break;\n            case 'border':\n                result['border'] = parseBorder(parser);\n                break;\n            case 'background-color':\n                result['backgroundColor'] = parseColor(parser);\n                break;\n            case 'actions':\n                result['actions'] = parseActions(parser, ['E', 'X', 'D', 'U', 'Fo', 'Bl', 'PO', 'PC', 'PV', 'PI'], getPageMatrix);\n                break;\n            case 'appearances':\n                parseAppearances(parser, result);\n                break;\n            case 'extra':\n                var extra = parseExtra(parser, getPageMatrix);\n                if (extra.font) {\n                    result['font'] = extra.font;\n                }\n                break;\n            case 'captions':\n                result['captions'] = parseCaptions(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised widget child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseOption(parser) {\n    return {\n        'value': parser.findAttribute('value'),\n        'displayValue': parser.findAttribute('display-value') || undefined\n    };\n}\nfunction parseOptions(parser) {\n    var result = [];\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'option':\n                result.push(parseOption(parser));\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised options child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parseField(parser, pageMatrix) {\n    var name = parser.findAttribute('name');\n    var type = parser.findAttribute('type');\n    var properties = {\n        'type': type,\n        'quadding': parser.findAttribute('quadding') || 'Left-justified',\n        'maxLen': parser.findAttribute('max-len') || -1,\n    };\n    var flags = parser.findAttribute('flags');\n    if (Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isString\"])(flags)) {\n        properties['flags'] = flags.split(' ');\n    }\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'actions':\n                properties['actions'] = parseActions(parser, ['C', 'F', 'K', 'V'], function () { return pageMatrix; });\n                break;\n            case 'default-value':\n                properties['defaultValue'] = parseValueElement(parser);\n                break;\n            case 'font':\n                properties['font'] = parseFont(parser, pageMatrix);\n                break;\n            case 'options':\n                properties['options'] = parseOptions(parser);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unknown field child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return new window.Core.Annotations.Forms.Field(name, properties);\n}\n// TODO-TS what is options (probably some kind of Widget options)\nfunction createWidget(field, options) {\n    switch (field['type']) {\n        case 'Tx':\n            try {\n                if (Object(_PDFInfo__WEBPACK_IMPORTED_MODULE_6__[/* isDateField */ \"c\"])(field['actions'])) {\n                    return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['DatePickerWidgetAnnotation'](field, options);\n                }\n            }\n            catch (error) {\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(error);\n            }\n            return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['TextWidgetAnnotation'](field, options);\n        case 'Ch':\n            if (field['flags'].get(_Annotations_Widgets__WEBPACK_IMPORTED_MODULE_7__[\"WidgetFlags\"]['COMBO'])) {\n                return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['ChoiceWidgetAnnotation'](field, options);\n            }\n            return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['ListWidgetAnnotation'](field, options);\n        case 'Btn':\n            if (field['flags'].get(_Annotations_Widgets__WEBPACK_IMPORTED_MODULE_7__[\"WidgetFlags\"]['PUSH_BUTTON'])) {\n                return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['PushButtonWidgetAnnotation'](field, options);\n            }\n            if (field['flags'].get(_Annotations_Widgets__WEBPACK_IMPORTED_MODULE_7__[\"WidgetFlags\"]['RADIO'])) {\n                return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['RadioButtonWidgetAnnotation'](field, options);\n            }\n            return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['CheckButtonWidgetAnnotation'](field, options);\n        case 'Sig':\n            return new _Annotations__WEBPACK_IMPORTED_MODULE_2__[/* Widgets */ \"a\"]['SignatureWidgetAnnotation'](field, options);\n        default:\n            Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"Unrecognised field type: \" + field['type']);\n    }\n    return null;\n}\nfunction parsePage(parser, getPageMatrix) {\n    var result = {\n        'number': parser.findAttribute('number'),\n    };\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'actions':\n                result['actions'] = parseActions(parser, ['O', 'C'], getPageMatrix);\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised page child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\nfunction parsePages(parser, getPageMatrix) {\n    var result = [];\n    parser.increaseDepth();\n    while (parser.advance()) {\n        var elementName = parser.getElementName();\n        switch (elementName) {\n            case 'page':\n                result.push(parsePage(parser, getPageMatrix));\n                break;\n            default:\n                Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"unrecognised page child: \" + elementName);\n        }\n    }\n    parser.decreaseDepth();\n    return result;\n}\n/*\n * Parses version 1 of PDFInfo using a recursive descent parser. See parse*() for individual parts of PDFInfo version 1.\n * @ignore\n */\nfunction parse(parser, getPageMatrix, finished, sync) {\n    var widgetList = [];\n    // TODO-TS: any is a Field\n    var fields = {};\n    parser.increaseDepth();\n    var calculationOrder = [];\n    var documentActions = {};\n    // TODO-TS: fix parse argument types.\n    var pages = [];\n    Object(_util_helpers__WEBPACK_IMPORTED_MODULE_5__[/* busyLoop */ \"a\"])(function () {\n        var field;\n        var widget;\n        var widgetSpec;\n        if (parser.advance()) {\n            var elementName = parser.getElementName();\n            switch (elementName) {\n                case 'calculation-order':\n                    calculationOrder = parseCalculationOrder(parser);\n                    break;\n                case 'document-actions':\n                    documentActions = parseActions(parser, ['Init', 'Open'], getPageMatrix);\n                    break;\n                case 'pages':\n                    pages = parsePages(parser, getPageMatrix);\n                    break;\n                case 'field':\n                    // the page matrix is only used for scaling font sizes in fields, so we currently assume any will do and pick page 1\n                    field = parseField(parser, getPageMatrix(1));\n                    fields[field['name']] = field;\n                    break;\n                case 'widget':\n                    widgetSpec = parseWidget(parser, getPageMatrix);\n                    field = fields[widgetSpec['fieldName']];\n                    if (field) {\n                        widget = createWidget(field, widgetSpec);\n                        widgetList.push(widget);\n                    }\n                    else {\n                        Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"ignoring widget with no corresponding field data: \" + widgetSpec['fieldName']);\n                    }\n                    break;\n                default:\n                    Object(logger__WEBPACK_IMPORTED_MODULE_0__[/* warn */ \"j\"])(\"Unknown element encountered in PDFInfo: \" + elementName);\n            }\n            return true;\n        }\n        return false;\n    }, function () {\n        parser.decreaseDepth();\n        finished({\n            'calculationOrder': calculationOrder,\n            'widgets': widgetList,\n            'fields': fields,\n            'documentActions': documentActions,\n            'pages': pages,\n            'custom': [],\n        });\n    }, sync);\n}\n\n\n/***/ })\n\n}]);","import { warn } from 'logger';\nimport { HideShape } from '../Actions/Hide';\nimport { DestShape } from '../Actions/Dest';\nimport { PageMatrixGetter, ParsedPDFInfo, ParserResult, Field, ActionShape, RectShape, Caption, ParsedWidget } from './PDFInfoTypes';\nimport XMLParser from '../XMLParser/XMLParser';\nimport { isNull, isString } from 'lodash';\nimport { Widgets } from '../Annotations';\nimport { Rect } from '../Core/Math';\nimport Color from '../Annotations/Color';\nimport { busyLoop } from '../../util/helpers';\nimport { Matrix2D } from '../../util/textSelection';\nimport { getOrSetKeyFromObj, isDateField } from './PDFInfo';\nimport { WidgetFlags } from '../Annotations/Widgets';\n\nfunction parseFieldReference(parser: XMLParser) {\n  return String(parser.findAttribute('name'));\n}\n\nfunction parseValueElement(parser: XMLParser) {\n  parser.increaseDepth();\n  parser.advance();\n  const value = parser.getCharData();\n  parser.decreaseDepth();\n  return value;\n}\n\nfunction parseFieldList(parser: XMLParser) {\n  const result = [];\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    if (elementName === 'field') {\n      result.push(parseFieldReference(parser));\n    } else {\n      warn(`unrecognised field list element: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseOptionalBoolean(attr: string, def: boolean) {\n  if (def) {\n    return attr !== 'false';\n  }\n\n  return attr === 'true';\n}\n\nfunction parseJavaScriptAction(parser: XMLParser) {\n  return {\n    'name': 'JavaScript',\n    'javascript': parser.getCharData(),\n  };\n}\n\nfunction parseURIAction(parser: XMLParser) {\n  return {\n    'name': 'URI',\n    'uri': parser.findAttribute('uri'),\n  };\n}\n\nfunction parseDest(parser: XMLParser, getPageMatrix: PageMatrixGetter): DestShape {\n  const fit = parser.findAttribute('fit');\n  const result: DestShape = {\n    'page': parser.findAttribute('page'),\n    'fit': fit,\n  };\n\n  if (result['page'] === '0') {\n    warn('null page encountered in dest');\n    return result;\n  }\n  const pageMatrix = getPageMatrix(Number(result['page']));\n\n  let pt1;\n  let pt2;\n\n  switch (fit) {\n    case 'Fit':\n    case 'FitB':\n    // no extra properties\n      break;\n    case 'FitH':\n    case 'FitBH':\n      result['top'] = pageMatrix.mult({\n        x: 0,\n        y: (parser.findAttribute('top') || 0) as number\n      }).y;\n      break;\n    case 'FitV':\n    case 'FitBV':\n      result['left'] = pageMatrix.mult({\n        x: (parser.findAttribute('left') || 0) as number,\n        y: 0\n      }).x;\n      break;\n    case 'FitR':\n      pt1 = pageMatrix.mult({\n        x: (parser.findAttribute('left') || 0) as number,\n        y: (parser.findAttribute('top') || 0) as number,\n      });\n      pt2 = pageMatrix.mult({\n        x: (parser.findAttribute('right') || 0) as number,\n        y: (parser.findAttribute('bottom') || 0) as number,\n      });\n      const tmp = new Rect(pt1.x, pt1.y, pt2.x, pt2.y);\n      result['top'] = tmp.y1;\n      result['left'] = tmp.x1;\n      result['bottom'] = tmp.y2;\n      result['right'] = tmp.x2;\n      break;\n    case 'XYZ':\n      pt1 = pageMatrix.mult({\n        x: (parser.findAttribute('left') || 0) as number,\n        y: (parser.findAttribute('top') || 0) as number,\n      });\n      result['top'] = pt1.y;\n      result['left'] = pt1.x;\n      result['zoom'] = parser.findAttribute('zoom') || 0;\n      break;\n    default:\n      warn(`unknown dest fit: ${fit}`);\n  }\n  return result;\n}\n\nfunction parseGoToAction(parser: XMLParser, getPageMatrix: PageMatrixGetter): ActionShape {\n  let result: ActionShape = null;\n  parser.increaseDepth();\n  if (parser.advance()) {\n    result = {\n      'name': 'GoTo',\n      'dest': parseDest(parser, getPageMatrix),\n    };\n  } else {\n    warn('missing dest in GoTo action');\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseSubmitFormAction(parser: XMLParser): ActionShape {\n  const result: ActionShape = {\n    'name': 'SubmitForm',\n    'url': parser.findAttribute('url'),\n    'format': parser.findAttribute('format'),\n    'method': parser.findAttribute('method') || 'POST',\n    'exclude': parseOptionalBoolean(parser.findAttribute('exclude'), false),\n  };\n  const flags = parser.findAttribute('flags');\n  if (flags) {\n    result['flags'] = flags.split(' ');\n  } else {\n    result['flags'] = [];\n  }\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'fields':\n        result['fields'] = parseFieldList(parser);\n        break;\n      default:\n        warn(`unrecognised submit-form child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseResetFormAction(parser: XMLParser): ActionShape {\n  const result: ActionShape = {\n    'name': 'ResetForm',\n    'exclude': parseOptionalBoolean(parser.findAttribute('exclude'), false),\n  };\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'fields':\n        result['fields'] = parseFieldList(parser);\n        break;\n      default:\n        warn(`unrecognised reset-form child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseHideAction(parser: XMLParser): HideShape {\n  const result: HideShape = {\n    'name': 'Hide',\n    'hide': parseOptionalBoolean(parser.findAttribute('hide'), true),\n  };\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'fields':\n        result['fields'] = parseFieldList(parser);\n        break;\n      default:\n        warn(`unrecognised hide child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseNamedAction(parser: XMLParser) {\n  return {\n    'name': 'Named',\n    'action': parser.findAttribute('name'),\n  };\n}\n\nfunction parseAction(parser: XMLParser, getPageMatrix: PageMatrixGetter): ActionShape {\n  const elementName = parser.getElementName();\n  switch (elementName) {\n    case 'javascript':\n      return parseJavaScriptAction(parser) as ActionShape;\n    case 'uri':\n      return parseURIAction(parser) as ActionShape;\n    case 'goto':\n      return parseGoToAction(parser, getPageMatrix);\n    case 'submit-form':\n      return parseSubmitFormAction(parser);\n    case 'reset-form':\n      return parseResetFormAction(parser);\n    case 'hide':\n      return parseHideAction(parser) as ActionShape;\n    case 'named':\n      return parseNamedAction(parser) as ActionShape;\n    default:\n      warn(`Encountered unexpected action type: ${elementName}`);\n  }\n  return null;\n}\n\nfunction parseActions(parser: XMLParser, triggers: Array<string>, getPageMatrix: PageMatrixGetter) {\n  const result: Record<string, Array<ActionShape>> = {};\n\n  function isValidTrigger(t: string) {\n    if (triggers) {\n      return triggers.indexOf(t) !== -1;\n    }\n    return true;\n  }\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'action':\n        const trigger = parser.findAttribute('trigger');\n        if (isValidTrigger(trigger)) {\n          result[trigger] = [];\n          parser.increaseDepth();\n          while (parser.advance()) {\n            const tmp = parseAction(parser, getPageMatrix);\n            if (!isNull(tmp)) {\n              result[trigger].push(tmp);\n            }\n          }\n          parser.decreaseDepth();\n        } else {\n          warn(`encountered unexpected trigger on field: ${trigger}`);\n        }\n        break;\n      default:\n        warn(`encountered unknown action child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseCalculationOrder(parser: XMLParser) {\n  const elementName = parser.getElementName();\n  if (elementName === 'calculation-order') {\n    return parseFieldList(parser);\n  }\n  return [];\n}\n\nfunction parseRect(parser: XMLParser, pageMatrix: Matrix2D): RectShape {\n  const pt1 = pageMatrix.mult({\n    x: (parser.findAttribute('x1') || 0) as number,\n    y: (parser.findAttribute('y1') || 0) as number,\n  });\n  const pt2 = pageMatrix.mult({\n    x: (parser.findAttribute('x2') || 0) as number,\n    y: (parser.findAttribute('y2') || 0) as number,\n  });\n  const rect = new Rect(pt1.x, pt1.y, pt2.x, pt2.y);\n  rect.normalize();\n  return {\n    'x1': rect['x1'],\n    'y1': rect['y1'],\n    'x2': rect['x2'],\n    'y2': rect['y2'],\n  };\n}\n\nfunction parseColor(parser: XMLParser) {\n  return new Color(\n    parser.findAttribute('r') || 0,\n    parser.findAttribute('g') || 0,\n    parser.findAttribute('b') || 0,\n    parser.findAttribute('a') || 1,\n  );\n}\n\nfunction parseBorder(parser: XMLParser) {\n  const result: ParserResult['border'] = {\n    'style': parser.findAttribute('style') || 'Solid',\n    'width': parser.findAttribute('width') || 1,\n    'color': [0, 0, 0],\n  };\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'color':\n        result['color'] = parseColor(parser);\n        break;\n      default:\n        warn(`unrecognised border child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\n// TODO-TS what is this\nfunction parseAppearance(parser: XMLParser, currentAppearance: any) {\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'Normal':\n        getOrSetKeyFromObj(currentAppearance, 'Normal').data = parser.getCharData();\n        break;\n      default:\n        warn('unexpected appearance state: ', elementName);\n    }\n  }\n  parser.decreaseDepth();\n}\n\nfunction parseAppearances(parser: XMLParser, annot: ParserResult) {\n  const appearancesObj = getOrSetKeyFromObj(annot, 'appearances');\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    if (elementName === 'appearance') {\n      const name = parser.findAttribute('name');\n      const currentAppearance = getOrSetKeyFromObj(appearancesObj, name);\n      parseAppearance(parser, currentAppearance);\n    } else {\n      warn(`unexpected appearances child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n}\n\nfunction parseFont(parser: XMLParser, pageMatrix: Matrix2D) {\n  function fixSize(s: string) {\n    const pt1 = pageMatrix.mult({\n      x: 0,\n      y: 0,\n    });\n    const pt2 = pageMatrix.mult({\n      x: Number(s),\n      y: 0,\n    });\n    const dx = pt1.x - pt2.x;\n    const dy = pt1.y - pt2.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  const result: ParserResult['font'] = {\n    'name': parser.findAttribute('name'),\n    'type': parser.findAttribute('type') || 'Type1',\n    'size': fixSize(parser.findAttribute('size')) || 0,\n    'strokeColor': [0, 0, 0], // default font color to black\n    'fillColor': [0, 0, 0],\n  };\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'stroke-color':\n        result['strokeColor'] = parseColor(parser);\n        break;\n      case 'fill-color':\n        result['fillColor'] = parseColor(parser);\n        break;\n      default:\n        warn(`unrecognised font child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseExtra(parser: XMLParser, getPageMatrix: PageMatrixGetter) {\n  const result: Partial<ParserResult> = {};\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'font':\n        result.font = parseFont(parser, getPageMatrix(1));\n        break;\n      default:\n        warn(`unrecognised extra child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseCaptions(parser: XMLParser) {\n  const result: Caption = {};\n  const normal = parser.findAttribute('Normal');\n  if (normal) {\n    result['Normal'] = normal;\n  }\n  const rollover = parser.findAttribute('Rollover');\n  if (rollover) {\n    result['Rollover'] = rollover;\n  }\n  const down = parser.findAttribute('Down');\n  if (down) {\n    result['Down'] = down;\n  }\n  return result;\n}\n\nfunction parseWidget(parser: XMLParser, getPageMatrix: PageMatrixGetter) {\n  const result: ParserResult = {\n    'border': {\n      'style': 'Solid',\n      'width': 1,\n    },\n    'backgroundColor': [],\n    'fieldName': parser.findAttribute('field'),\n    'page': parser.findAttribute('page'),\n    'index': parser.findAttribute('index') || 0,\n    'rotation': parser.findAttribute('rotation') || 0,\n    'flags': [],\n    'isImporting': true,\n  };\n  const appearance = parser.findAttribute('appearance');\n  if (appearance) {\n    result['appearance'] = appearance;\n  }\n  const flags = parser.findAttribute('flags');\n  if (flags) {\n    result['flags'] = flags.split(' ');\n  }\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'rect':\n        result['rect'] = parseRect(parser, getPageMatrix(Number(result['page'])));\n        break;\n      case 'border':\n        result['border'] = parseBorder(parser);\n        break;\n      case 'background-color':\n        result['backgroundColor'] = parseColor(parser);\n        break;\n      case 'actions':\n        result['actions'] = parseActions(parser, ['E', 'X', 'D', 'U', 'Fo', 'Bl', 'PO', 'PC', 'PV', 'PI'], getPageMatrix);\n        break;\n      case 'appearances':\n        parseAppearances(parser, result);\n        break;\n      case 'extra':\n        const extra = parseExtra(parser, getPageMatrix);\n        if (extra.font) {\n          result['font'] = extra.font;\n        }\n        break;\n      case 'captions':\n        result['captions'] = parseCaptions(parser);\n        break;\n      default:\n        warn(`unrecognised widget child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parseOption(parser: XMLParser) {\n  return {\n    'value': parser.findAttribute('value'),\n    'displayValue': parser.findAttribute('display-value') || undefined\n  };\n}\n\nfunction parseOptions(parser: XMLParser) {\n  const result = [];\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'option':\n        result.push(parseOption(parser));\n        break;\n      default:\n        warn(`unrecognised options child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\n\nfunction parseField(parser: XMLParser, pageMatrix: Matrix2D) {\n  const name = parser.findAttribute('name');\n  const type = parser.findAttribute('type');\n  const properties: Record<string, any> = {\n    'type': type,\n    'quadding': parser.findAttribute('quadding') || 'Left-justified',\n    'maxLen': parser.findAttribute('max-len') || -1,\n  };\n\n  const flags = parser.findAttribute('flags');\n  if (isString(flags)) {\n    properties['flags'] = flags.split(' ');\n  }\n\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'actions':\n        properties['actions'] = parseActions(parser, ['C', 'F', 'K', 'V'], () => pageMatrix);\n        break;\n      case 'default-value':\n        properties['defaultValue'] = parseValueElement(parser);\n        break;\n      case 'font':\n        properties['font'] = parseFont(parser, pageMatrix);\n        break;\n      case 'options':\n        properties['options'] = parseOptions(parser);\n        break;\n      default:\n        warn(`unknown field child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return new window.Core.Annotations.Forms.Field(name, properties);\n}\n\n// TODO-TS what is options (probably some kind of Widget options)\nfunction createWidget(field: Field, options: any) {\n  switch (field['type']) {\n    case 'Tx':\n      try {\n        if (isDateField(field['actions'])) {\n          return new Widgets['DatePickerWidgetAnnotation'](field, options);\n        }\n      } catch (error) {\n        warn(error);\n      }\n      return new Widgets['TextWidgetAnnotation'](field, options);\n    case 'Ch':\n      if (field['flags'].get(WidgetFlags['COMBO'])) {\n        return new Widgets['ChoiceWidgetAnnotation'](field, options);\n      }\n      return new Widgets['ListWidgetAnnotation'](field, options);\n    case 'Btn':\n      if (field['flags'].get(WidgetFlags['PUSH_BUTTON'])) {\n        return new Widgets['PushButtonWidgetAnnotation'](field, options);\n      } if (field['flags'].get(WidgetFlags['RADIO'])) {\n        return new Widgets['RadioButtonWidgetAnnotation'](field, options);\n      }\n      return new Widgets['CheckButtonWidgetAnnotation'](field, options);\n    case 'Sig':\n      return new Widgets['SignatureWidgetAnnotation'](field, options);\n    default:\n      warn(`Unrecognised field type: ${field['type']}`);\n  }\n  return null;\n}\n\nfunction parsePage(parser: XMLParser, getPageMatrix: PageMatrixGetter) {\n  const result: Partial<ParserResult> = {\n    'number': parser.findAttribute('number'),\n  };\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'actions':\n        result['actions'] = parseActions(parser, ['O', 'C'], getPageMatrix);\n        break;\n      default:\n        warn(`unrecognised page child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\nfunction parsePages(parser: XMLParser, getPageMatrix: PageMatrixGetter) {\n  const result = [];\n  parser.increaseDepth();\n  while (parser.advance()) {\n    const elementName = parser.getElementName();\n    switch (elementName) {\n      case 'page':\n        result.push(parsePage(parser, getPageMatrix));\n        break;\n      default:\n        warn(`unrecognised page child: ${elementName}`);\n    }\n  }\n  parser.decreaseDepth();\n  return result;\n}\n\n/*\n * Parses version 1 of PDFInfo using a recursive descent parser. See parse*() for individual parts of PDFInfo version 1.\n * @ignore\n */\nexport function parse(parser: XMLParser, getPageMatrix: PageMatrixGetter, finished: (info: ParsedPDFInfo) => void, sync?: boolean) {\n  const widgetList: Array<ParsedWidget> = [];\n\n  // TODO-TS: any is a Field\n  const fields: Record<string, Field> = {};\n\n  parser.increaseDepth();\n\n  let calculationOrder: Array<string> = [];\n\n  let documentActions = {};\n\n  // TODO-TS: fix parse argument types.\n  let pages: Partial<ParserResult>[] = [];\n\n  busyLoop(function() {\n    let field;\n    let widget;\n    let widgetSpec;\n    if (parser.advance()) {\n      const elementName = parser.getElementName();\n      switch (elementName) {\n        case 'calculation-order':\n          calculationOrder = parseCalculationOrder(parser);\n          break;\n        case 'document-actions':\n          documentActions = parseActions(parser, ['Init', 'Open'], getPageMatrix);\n          break;\n        case 'pages':\n          pages = parsePages(parser, getPageMatrix);\n          break;\n        case 'field':\n        // the page matrix is only used for scaling font sizes in fields, so we currently assume any will do and pick page 1\n          field = parseField(parser, getPageMatrix(1));\n          fields[field['name']] = field;\n          break;\n        case 'widget':\n          widgetSpec = parseWidget(parser, getPageMatrix);\n          field = fields[widgetSpec['fieldName']];\n          if (field) {\n            widget = createWidget(field, widgetSpec);\n            widgetList.push(widget);\n          } else {\n            warn(`ignoring widget with no corresponding field data: ${widgetSpec['fieldName']}`);\n          }\n          break;\n        default:\n          warn(`Unknown element encountered in PDFInfo: ${elementName}`);\n      }\n      return true;\n    }\n    return false;\n  }, function() {\n    parser.decreaseDepth();\n    finished({\n      'calculationOrder': calculationOrder,\n      'widgets': widgetList,\n      'fields': fields,\n      'documentActions': documentActions,\n      'pages': pages,\n      'custom': [],\n    });\n  }, sync);\n}"],"mappings":";AAAA;ACoDA;AAiDA;AA+CA;AA+CA;AAkEA;AA6HA;AAmIA;AAuCA;AA4BA;AAgFA;AAvNA;AA+NA;AAzTA;AAyTA;AAsBA;","sourceRoot":""}