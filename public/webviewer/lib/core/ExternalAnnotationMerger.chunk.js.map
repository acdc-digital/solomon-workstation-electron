{"version":3,"file":"ExternalAnnotationMerger.chunk.js","sources":["webpack:///ExternalAnnotationMerger.chunk.js","webpack:///./src/core/src/namespaces/Core/ExternalAnnotationMerger/index.ts","webpack:///./src/core/src/namespaces/Core/ExternalAnnotationMerger/Parser.ts","webpack:///./src/core/src/namespaces/Core/ExternalAnnotationMerger/CommandXFDFParser.ts","webpack:///./src/core/src/namespaces/Core/ExternalAnnotationMerger/RegularXFDFParser.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[4],{\n\n/***/ 534:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _CommandXFDFParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(556);\n/* harmony import */ var _RegularXFDFParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(557);\n\n\n\nvar States;\n(function (States) {\n    // The external XFDF hasn't been requested for the current document\n    States[States[\"EXTERNAL_XFDF_NOT_REQUESTED\"] = 0] = \"EXTERNAL_XFDF_NOT_REQUESTED\";\n    // The external XFDF has been requested, but it doesn't contain any XFDF data for external annotations\n    States[States[\"EXTERNAL_XFDF_NOT_AVAILABLE\"] = 1] = \"EXTERNAL_XFDF_NOT_AVAILABLE\";\n    // The external XFDF has been requested, and it contains external XFDF data that we want to merge into the document\n    States[States[\"EXTERNAL_XFDF_AVAILABLE\"] = 2] = \"EXTERNAL_XFDF_AVAILABLE\";\n})(States || (States = {}));\nvar ExternalAnnotationMerger = /** @class */ (function () {\n    function ExternalAnnotationMerger(docViewer) {\n        this.docViewer = docViewer;\n        this.state = States['EXTERNAL_XFDF_NOT_REQUESTED'];\n    }\n    // Returns a function that will be called by the docViewer after the internal XFDF of some pages has been extracted and before it is imported.\n    // When the returned function is called, it will merge the external XFDF string into the internal XFDF string\n    ExternalAnnotationMerger.prototype.getTransformFunction = function () {\n        var _this = this;\n        var transform = function (internalXFDFString, pageIndexes, callback) { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(_this, void 0, void 0, function () {\n            var documentId, externalXFDFString, parser_1, parser, internalXFDF, serializer, transformedInternalXFDFString;\n            var _this = this;\n            var _a;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this.state === States['EXTERNAL_XFDF_NOT_REQUESTED'])) return [3 /*break*/, 2];\n                        documentId = this.docViewer.getDocument().getDocumentId();\n                        return [4 /*yield*/, this.getExternalXFDF(documentId)];\n                    case 1:\n                        externalXFDFString = _b.sent();\n                        parser_1 = this.createParser(externalXFDFString);\n                        this.externalXFDF = (_a = parser_1 === null || parser_1 === void 0 ? void 0 : parser_1.parse()) !== null && _a !== void 0 ? _a : null;\n                        if (this.externalXFDF === null) {\n                            this.state = States['EXTERNAL_XFDF_NOT_AVAILABLE'];\n                        }\n                        else {\n                            this.state = States['EXTERNAL_XFDF_AVAILABLE'];\n                        }\n                        _b.label = 2;\n                    case 2:\n                        if (this.state === States['EXTERNAL_XFDF_NOT_AVAILABLE']) {\n                            callback(internalXFDFString);\n                            return [2 /*return*/];\n                        }\n                        parser = new DOMParser();\n                        internalXFDF = parser.parseFromString(internalXFDFString, 'text/xml');\n                        pageIndexes.forEach(function (pageNumber) {\n                            _this.merge(internalXFDF, _this.externalXFDF, pageNumber - 1);\n                        });\n                        serializer = new XMLSerializer();\n                        transformedInternalXFDFString = serializer.serializeToString(internalXFDF);\n                        callback(transformedInternalXFDFString);\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        return transform;\n    };\n    ExternalAnnotationMerger.prototype.setDocumentXFDFRetriever = function (getExternalXFDF) {\n        this.getExternalXFDF = getExternalXFDF;\n    };\n    ExternalAnnotationMerger.prototype.dispose = function () {\n        this.externalXFDF = undefined;\n        this.state = States['EXTERNAL_XFDF_NOT_REQUESTED'];\n    };\n    ExternalAnnotationMerger.prototype.createParser = function (externalXFDFString) {\n        if (!externalXFDFString) {\n            return null;\n        }\n        if (Array.isArray(externalXFDFString)) {\n            return new _CommandXFDFParser__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](externalXFDFString);\n        }\n        if (typeof externalXFDFString !== 'string') {\n            return null;\n        }\n        var parser = new DOMParser();\n        var externalXFDF = parser.parseFromString(externalXFDFString, 'text/xml');\n        var isCommandString = externalXFDF.querySelector('xfdf > add');\n        if (isCommandString) {\n            return new _CommandXFDFParser__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](externalXFDFString);\n        }\n        return new _RegularXFDFParser__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](externalXFDFString);\n    };\n    // Merge externalXFDF into internalXFDF in a given pageIndex\n    ExternalAnnotationMerger.prototype.merge = function (internalXFDF, externalXFDFData, pageIndex) {\n        var _this = this;\n        if (pageIndex === 0) {\n            // external calculation orders and document actions will just override the internal ones\n            // and we assume that internal ones always show in the first page's XFDF string\n            this.mergeCalculationOrder(internalXFDF, externalXFDFData.calculationOrder);\n            this.mergeDocumentActions(internalXFDF, externalXFDFData.documentActions);\n        }\n        var page = externalXFDFData.pages[pageIndex];\n        if (page) {\n            this.mergeMarkupAnnotations(internalXFDF, page.annots);\n            this.mergeWidgetsAndFields(internalXFDF, page.widgets, externalXFDFData.fields);\n            this.mergePDFInfoPage(internalXFDF, page.page, pageIndex);\n            this.mergeDeletedAnnotations(internalXFDF, page.deletedAnnotIds);\n        }\n        var pageCount = this.docViewer.getPageCount();\n        var isLastPage = pageIndex === pageCount - 1;\n        if (isLastPage) {\n            var fields_1 = externalXFDFData.fields;\n            Object.keys(fields_1).forEach(function (fieldName) {\n                if (!fields_1[fieldName].hasMerged) {\n                    _this.mergeField(internalXFDF, fieldName, fields_1[fieldName]);\n                }\n            });\n        }\n    };\n    ExternalAnnotationMerger.prototype.mergeCalculationOrder = function (internalXFDF, externalCalculationOrder) {\n        if (externalCalculationOrder === null) {\n            return;\n        }\n        var pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n        this.putElement(pdfInfoElement, 'calculation-order', externalCalculationOrder);\n    };\n    ExternalAnnotationMerger.prototype.mergeDocumentActions = function (internalXFDF, externalDocumentActions) {\n        if (externalDocumentActions === null) {\n            return;\n        }\n        var pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n        this.putElement(pdfInfoElement, 'document-actions', externalDocumentActions);\n    };\n    ExternalAnnotationMerger.prototype.mergeMarkupAnnotations = function (internalXFDF, annots) {\n        var _this = this;\n        var xfdfElement = internalXFDF.querySelector('xfdf');\n        var annotsElement = this.appendElementIfAbsent(xfdfElement, 'annots');\n        Object.keys(annots).forEach(function (annotId) {\n            _this.putElement(annotsElement, \"[name=\\\"\" + annotId + \"\\\"]\", annots[annotId]);\n        });\n    };\n    ExternalAnnotationMerger.prototype.mergeWidgetsAndFields = function (internalXFDF, widgets, fields) {\n        var _this = this;\n        if (widgets.length === 0) {\n            return;\n        }\n        var pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n        widgets.forEach(function (widgetElement) {\n            var associatedFieldName = widgetElement.getAttribute('field');\n            var field = fields[associatedFieldName];\n            if (field) {\n                _this.mergeField(internalXFDF, associatedFieldName, field);\n                _this.putElement(pdfInfoElement, 'null', widgetElement);\n            }\n        });\n    };\n    ExternalAnnotationMerger.prototype.mergeField = function (internalXFDF, fieldName, field) {\n        var pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n        // merge <ffield> in <pdf-info>\n        // Check if the ffield already exists in <pdf-info>, if not, add it\n        var ffield = pdfInfoElement.querySelector(\"ffield[name=\\\"\" + fieldName + \"\\\"]\");\n        if (field.ffield !== null && ffield === null) {\n            this.putElement(pdfInfoElement, \"ffield[name=\\\"\" + fieldName + \"\\\"]\", field.ffield);\n        }\n        // merge <field> in <fields>\n        var xfdfElement = internalXFDF.querySelector('xfdf');\n        var fieldsElement = this.appendElementIfAbsent(xfdfElement, 'xfdf > fields', 'fields');\n        var nameParts = fieldName.split('.');\n        this.putFieldElementRecursively(fieldsElement, nameParts, 0, field.value);\n        field.hasMerged = true;\n    };\n    ExternalAnnotationMerger.prototype.mergePDFInfoPage = function (internalXFDF, page, pageIndex) {\n        if (page === null) {\n            return;\n        }\n        var pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n        var pagesElement = this.appendElementIfAbsent(pdfInfoElement, 'pages');\n        var pageNum = pageIndex + 1;\n        this.putElement(pagesElement, \"[number=\\\"\" + pageNum + \"\\\"]\", page);\n    };\n    ExternalAnnotationMerger.prototype.mergeDeletedAnnotations = function (internalXFDF, deletedAnnotIds) {\n        Object.keys(deletedAnnotIds).forEach(function (id) {\n            var annotElement = internalXFDF.querySelector(\"annots [name=\\\"\" + id + \"\\\"]\");\n            if (annotElement) {\n                annotElement.parentElement.removeChild(annotElement);\n            }\n        });\n    };\n    ExternalAnnotationMerger.prototype.putFieldElementRecursively = function (parentElement, fieldNames, nameIndex, fieldValue) {\n        if (nameIndex === fieldNames.length) {\n            var valueElement = document.createElementNS('', 'value');\n            valueElement.textContent = fieldValue;\n            this.putElement(parentElement, 'value', valueElement);\n            return;\n        }\n        var fieldName = fieldNames[nameIndex];\n        var fieldElement = this.appendElementIfAbsent(parentElement, \"[name=\\\"\" + fieldName + \"\\\"]\", 'field');\n        fieldElement.setAttribute('name', fieldName);\n        var childElements = parentElement.querySelectorAll(\"[name=\\\"\" + fieldName + \"\\\"]\");\n        if (childElements.length === 1) {\n            this.putFieldElementRecursively(childElements[0], fieldNames, nameIndex + 1, fieldValue);\n            return;\n        }\n        // it's possible to have multiple children that have the same field name. For example:\n        //\n        // <field name=\"Feld\">\n        //   <field name=\"7\">\n        //     <value>Off</value>\n        //   </field>\n        //   <field name=\"7\">\n        //     <field name=\"1\">\n        //       <value>On</value>\n        //     </field>\n        //   </field>\n        // </field>\n        //\n        // in this case, when the current field name is \"7\", we need to pick the correct child element to continue our recursion\n        var isLeaf = nameIndex === fieldNames.length - 1;\n        // we made an assumption here that a leaf element always exists if there're two <field> elements with the same name attribute\n        var leafFieldElement = this.findLeafFieldElement(childElements);\n        var childElement = isLeaf ? leafFieldElement : this.theOther(childElements, leafFieldElement);\n        this.putFieldElementRecursively(childElement, fieldNames, nameIndex + 1, fieldValue);\n    };\n    ExternalAnnotationMerger.prototype.findLeafFieldElement = function (childElements) {\n        var leafElement = null;\n        for (var i = 0; i < childElements.length; i++) {\n            var element = childElements[i];\n            if (element.childElementCount === 0 ||\n                (element.childElementCount === 1 && element.children[0].tagName === 'value')) {\n                leafElement = element;\n                break;\n            }\n        }\n        return leafElement;\n    };\n    // Returns the element that is not equal to the given element in a list of two elements\n    ExternalAnnotationMerger.prototype.theOther = function (elements, e) {\n        for (var i = 0; i < elements.length; i++) {\n            if (elements[i] !== e) {\n                return elements[i];\n            }\n        }\n        return null;\n    };\n    // Override the targetSelector element with the externalElement in the parent element\n    // if the targetSelector element doesn't exist then just append the externalElement\n    ExternalAnnotationMerger.prototype.putElement = function (parentElement, targetSelector, externalElement) {\n        var internalElement = parentElement.querySelector(targetSelector);\n        if (internalElement !== null) {\n            parentElement.removeChild(internalElement);\n        }\n        parentElement.appendChild(externalElement);\n    };\n    ExternalAnnotationMerger.prototype.appendPDFInfoElementIfAbsent = function (internalXFDF) {\n        var pdfInfoElement = internalXFDF.querySelector('pdf-info');\n        if (pdfInfoElement !== null) {\n            return pdfInfoElement;\n        }\n        var xfdfElement = internalXFDF.querySelector('xfdf');\n        pdfInfoElement = this.appendElementIfAbsent(xfdfElement, 'pdf-info');\n        pdfInfoElement.setAttribute('xmlns', 'http://www.pdftron.com/pdfinfo');\n        pdfInfoElement.setAttribute('version', '2');\n        pdfInfoElement.setAttribute('import-version', '4');\n        return pdfInfoElement;\n    };\n    // Append an element in the parentElement if targetSelector can't be found in it\n    // The element's tag name is determined by targetTagName, or targetSelector if targetTagName is undefined\n    ExternalAnnotationMerger.prototype.appendElementIfAbsent = function (parentElement, targetSelector, targetTagName) {\n        var targetElement = parentElement.querySelector(targetSelector);\n        if (targetElement !== null) {\n            return targetElement;\n        }\n        targetElement = document.createElementNS('', targetTagName || targetSelector);\n        parentElement.appendChild(targetElement);\n        return targetElement;\n    };\n    return ExternalAnnotationMerger;\n}());\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExternalAnnotationMerger);\n\n\n/***/ }),\n\n/***/ 545:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar Parser = /** @class */ (function () {\n    function Parser() {\n    }\n    Parser.prototype._parse = function (externalXFDFString) {\n        var result = {\n            calculationOrder: null,\n            documentActions: null,\n            fields: {},\n            pages: {},\n        };\n        var parser = new DOMParser();\n        var rootElement = parser.parseFromString(externalXFDFString, 'text/xml');\n        result.calculationOrder = rootElement.querySelector('pdf-info calculation-order');\n        result.documentActions = rootElement.querySelector('pdf-info document-actions');\n        result.fields = this.parseFields(rootElement);\n        result.pages = this.parsePages(rootElement);\n        return result;\n    };\n    Parser.prototype.parseFields = function (rootElement) {\n        var fieldsElement = rootElement.querySelector('fields');\n        var ffieldElements = rootElement.querySelectorAll('pdf-info > ffield');\n        if (fieldsElement === null && ffieldElements === null) {\n            return {};\n        }\n        var fields = {};\n        this.addFieldsByBFS(fields, fieldsElement);\n        this.addFFields(fields, ffieldElements);\n        return fields;\n    };\n    /**\n     * Gets the information of <field> elements in the <fields> element and add them to the fields object using breadth-first search\n     */\n    Parser.prototype.addFieldsByBFS = function (fields, fieldsElement) {\n        if (fieldsElement === null || !fieldsElement.children) {\n            return;\n        }\n        // <field> elements are represented as a n-ary tree with <fields> being the root node\n        // Each <field> element may have multiple <field> elements as its children and the leaf node contains the value of the field\n        //\n        // The following example shows the result of this traversal.\n        // Input:\n        //  <fields>\n        //    <field name=\"a\">\n        //      <field name=\"b\">\n        //        <value>1</value>\n        //      </field>\n        //    </field>\n        //    <field name=\"c\">\n        //      <value>2</value>\n        //    </field>\n        //  </fields>\n        // Output:\n        // {\n        //   'a.b': { value: 1, ffield: null, hasMerged: false }\n        //   'c': { value: 2, ffield: null, hasMerged: false }\n        // }\n        var queue = [];\n        for (var i = 0; i < fieldsElement.children.length; i++) {\n            var rootField = fieldsElement.children[i];\n            queue.push({\n                name: rootField.getAttribute('name'),\n                element: rootField,\n            });\n        }\n        while (queue.length !== 0) {\n            var field = queue.shift();\n            for (var i = 0; i < field.element.children.length; i++) {\n                var child = field.element.children[i];\n                if (child.tagName === 'value') {\n                    fields[field.name] = {\n                        value: child.textContent,\n                        ffield: null,\n                        hasMerged: false,\n                    };\n                    continue;\n                }\n                if (child.children) {\n                    queue.push({\n                        name: field.name + \".\" + child.getAttribute('name'),\n                        element: child,\n                    });\n                }\n            }\n        }\n    };\n    /**\n     * Gets the information of <ffield> elements and add them to the fields object\n     */\n    Parser.prototype.addFFields = function (fields, ffieldElements) {\n        ffieldElements.forEach(function (ffieldElement) {\n            var name = ffieldElement.getAttribute('name');\n            if (!fields[name]) {\n                fields[name] = {\n                    value: null,\n                    ffield: ffieldElement,\n                    hasMerged: false,\n                };\n                return;\n            }\n            fields[name].ffield = ffieldElement;\n        });\n    };\n    /**\n     * Gets elements that have associated page numbers(or indexes) in the rootElement and add them to the returned page object\n     */\n    Parser.prototype.parsePages = function (rootElement) {\n        var _this = this;\n        var pages = {};\n        var widgetElements = rootElement.querySelectorAll('pdf-info widget');\n        widgetElements.forEach(function (widgetElement) {\n            var pageNum = parseInt(widgetElement.getAttribute('page'), 10);\n            var pageIndex = pageNum - 1;\n            _this.initializePageIfAbsent(pages, pageIndex);\n            pages[pageIndex].widgets.push(widgetElement);\n        });\n        var pageElements = rootElement.querySelectorAll('pdf-info page');\n        pageElements.forEach(function (pageElement) {\n            var pageNum = parseInt(pageElement.getAttribute('number'), 10);\n            var pageIndex = pageNum - 1;\n            _this.initializePageIfAbsent(pages, pageIndex);\n            pages[pageIndex].page = pageElement;\n        });\n        var markupAnnotElements = this.getMarkupAnnotElements(rootElement);\n        markupAnnotElements.forEach(function (markupAnnotElement) {\n            var pageIndex = parseInt(markupAnnotElement.getAttribute('page'), 10);\n            var id = markupAnnotElement.getAttribute('name');\n            _this.initializePageIfAbsent(pages, pageIndex);\n            pages[pageIndex].annots[id] = markupAnnotElement;\n        });\n        var deletedAnnotElements = this.getDeletedAnnotElements(rootElement);\n        deletedAnnotElements.forEach(function (deletedAnnotElement) {\n            var pageIndex = parseInt(deletedAnnotElement.getAttribute('page'), 10);\n            var id = deletedAnnotElement.textContent;\n            _this.initializePageIfAbsent(pages, pageIndex);\n            pages[pageIndex].deletedAnnotIds[id] = true;\n        });\n        return pages;\n    };\n    Parser.prototype.initializePageIfAbsent = function (pages, pageIndex) {\n        if (!pages[pageIndex]) {\n            pages[pageIndex] = {\n                annots: {},\n                deletedAnnotIds: {},\n                widgets: [],\n                page: null,\n            };\n        }\n    };\n    return Parser;\n}());\n/* harmony default export */ __webpack_exports__[\"a\"] = (Parser);\n\n\n/***/ }),\n\n/***/ 556:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(545);\n\n\n\nvar CommandXFDFParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(CommandXFDFParser, _super);\n    function CommandXFDFParser(externalXFDFCommands) {\n        var _this = _super.call(this) || this;\n        _this.externalXFDFCommands = Array.isArray(externalXFDFCommands)\n            ? externalXFDFCommands\n            : [externalXFDFCommands];\n        return _this;\n    }\n    CommandXFDFParser.prototype.parse = function () {\n        var _this = this;\n        var result = {\n            calculationOrder: null,\n            documentActions: null,\n            fields: {},\n            pages: {},\n        };\n        this.externalXFDFCommands.forEach(function (command) {\n            result = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"merge\"])(result, _this._parse(command));\n        });\n        return result;\n    };\n    CommandXFDFParser.prototype.getMarkupAnnotElements = function (rootElement) {\n        var elements = [];\n        rootElement.querySelectorAll('add > *').forEach(function (element) {\n            elements.push(element);\n        });\n        rootElement.querySelectorAll('modify > *').forEach(function (element) {\n            elements.push(element);\n        });\n        return elements;\n    };\n    CommandXFDFParser.prototype.getDeletedAnnotElements = function (rootElement) {\n        return rootElement.querySelectorAll('delete > *');\n    };\n    return CommandXFDFParser;\n}(_Parser__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]));\n/* harmony default export */ __webpack_exports__[\"a\"] = (CommandXFDFParser);\n\n\n/***/ }),\n\n/***/ 557:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _Parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(545);\n\n\nvar ExternalRegularXFDFParser = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(ExternalRegularXFDFParser, _super);\n    function ExternalRegularXFDFParser(externalXFDFString) {\n        var _this = _super.call(this) || this;\n        _this.externalXFDFString = externalXFDFString;\n        return _this;\n    }\n    ExternalRegularXFDFParser.prototype.parse = function () {\n        return this._parse(this.externalXFDFString);\n    };\n    ExternalRegularXFDFParser.prototype.getMarkupAnnotElements = function (rootElement) {\n        return rootElement.querySelectorAll('annots > *');\n    };\n    ExternalRegularXFDFParser.prototype.getDeletedAnnotElements = function () {\n        // XFDF string that's exported from exportAnnotations doesn't contain any information for deleted annotations\n        // so just return an empty array\n        return [];\n    };\n    return ExternalRegularXFDFParser;\n}(_Parser__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]));\n/* harmony default export */ __webpack_exports__[\"a\"] = (ExternalRegularXFDFParser);\n\n\n/***/ })\n\n}]);","import { DocumentViewer } from '../DocumentViewer';\nimport CommandXFDFParser from './CommandXFDFParser';\nimport RegularXFDFParser from './RegularXFDFParser';\nimport Parser, { Field, ParsedExternalXFDF } from './Parser';\n\nexport type XFDFType = string | string[] | undefined | null;\nexport type DocumentXFDFRetriever = (documentId: string) => Promise<XFDFType>;\ntype InternalAnnotationsTransformFunction = (\n  internalXFDFString: string,\n  pageIndexes: number[],\n  callback: (transformedInternalXFDFString: string) => void\n) => void;\n\nenum States {\n   // The external XFDF hasn't been requested for the current document\n  'EXTERNAL_XFDF_NOT_REQUESTED',\n\n   // The external XFDF has been requested, but it doesn't contain any XFDF data for external annotations\n  'EXTERNAL_XFDF_NOT_AVAILABLE',\n\n   // The external XFDF has been requested, and it contains external XFDF data that we want to merge into the document\n  'EXTERNAL_XFDF_AVAILABLE',\n}\n\nclass ExternalAnnotationMerger {\n  private docViewer: DocumentViewer;\n\n  // A function that is provided by our customers.\n  // The function returns a Promise that will be resolved with the internal XFDF string that needs to be merged into the current document\n  private getExternalXFDF: DocumentXFDFRetriever;\n\n  // The result of parsing the external XFDF string from the getExternalXFDF function\n  private externalXFDF: ParsedExternalXFDF | null | undefined;\n\n  // The state of externalXFDF in the merger\n  private state: States;\n\n  constructor(docViewer: DocumentViewer) {\n    this.docViewer = docViewer;\n    this.state = States['EXTERNAL_XFDF_NOT_REQUESTED'];\n  }\n\n  // Returns a function that will be called by the docViewer after the internal XFDF of some pages has been extracted and before it is imported.\n  // When the returned function is called, it will merge the external XFDF string into the internal XFDF string\n  public getTransformFunction(): InternalAnnotationsTransformFunction {\n    const transform = async (\n      internalXFDFString: string,\n      pageIndexes: number[],\n      callback: (transformedInternalXFDFString: string) => void\n    ) => {\n      // parse both external and internal XFDF string, merge the external one into the internal one, serialize\n      // the internal one, and pass it back to docViewer for importing\n\n      if (this.state === States['EXTERNAL_XFDF_NOT_REQUESTED']) {\n        const documentId = this.docViewer.getDocument().getDocumentId();\n        const externalXFDFString = await this.getExternalXFDF(documentId);\n        const parser = this.createParser(externalXFDFString);\n\n        this.externalXFDF = parser?.parse() ?? null;\n        if (this.externalXFDF === null) {\n          this.state = States['EXTERNAL_XFDF_NOT_AVAILABLE'];\n        } else {\n          this.state = States['EXTERNAL_XFDF_AVAILABLE'];\n        }\n      }\n\n      if (this.state === States['EXTERNAL_XFDF_NOT_AVAILABLE']) {\n        callback(internalXFDFString);\n        return;\n      }\n\n      const parser = new DOMParser();\n      const internalXFDF = parser.parseFromString(internalXFDFString, 'text/xml');\n\n      pageIndexes.forEach((pageNumber) => {\n        this.merge(internalXFDF, this.externalXFDF, pageNumber - 1);\n      });\n\n      const serializer = new XMLSerializer();\n      const transformedInternalXFDFString = serializer.serializeToString(internalXFDF);\n      callback(transformedInternalXFDFString);\n    };\n\n    return transform;\n  }\n\n  public setDocumentXFDFRetriever(getExternalXFDF: DocumentXFDFRetriever): void {\n    this.getExternalXFDF = getExternalXFDF;\n  }\n\n  public dispose(): void {\n    this.externalXFDF = undefined;\n    this.state = States['EXTERNAL_XFDF_NOT_REQUESTED'];\n  }\n\n  private createParser(externalXFDFString: XFDFType): Parser {\n    if (!externalXFDFString) {\n      return null;\n    }\n\n    if (Array.isArray(externalXFDFString)) {\n      return new CommandXFDFParser(externalXFDFString);\n    }\n\n    if (typeof externalXFDFString !== 'string') {\n      return null;\n    }\n\n    const parser = new DOMParser();\n    const externalXFDF = parser.parseFromString(externalXFDFString, 'text/xml');\n    const isCommandString = externalXFDF.querySelector('xfdf > add');\n    if (isCommandString) {\n      return new CommandXFDFParser(externalXFDFString);\n    }\n\n    return new RegularXFDFParser(externalXFDFString);\n  }\n\n  // Merge externalXFDF into internalXFDF in a given pageIndex\n  private merge(internalXFDF: Document, externalXFDFData: ParsedExternalXFDF, pageIndex: number): void {\n    if (pageIndex === 0) {\n      // external calculation orders and document actions will just override the internal ones\n      // and we assume that internal ones always show in the first page's XFDF string\n      this.mergeCalculationOrder(internalXFDF, externalXFDFData.calculationOrder);\n      this.mergeDocumentActions(internalXFDF, externalXFDFData.documentActions);\n    }\n\n    const page = externalXFDFData.pages[pageIndex];\n    if (page) {\n      this.mergeMarkupAnnotations(internalXFDF, page.annots);\n      this.mergeWidgetsAndFields(internalXFDF, page.widgets, externalXFDFData.fields);\n      this.mergePDFInfoPage(internalXFDF, page.page, pageIndex);\n      this.mergeDeletedAnnotations(internalXFDF, page.deletedAnnotIds);\n    }\n\n    const pageCount = this.docViewer.getPageCount();\n    const isLastPage = pageIndex === pageCount - 1;\n    if (isLastPage) {\n      const fields = externalXFDFData.fields;\n      Object.keys(fields).forEach((fieldName) => {\n        if (!fields[fieldName].hasMerged) {\n          this.mergeField(internalXFDF, fieldName, fields[fieldName]);\n        }\n      });\n    }\n  }\n\n  private mergeCalculationOrder(\n    internalXFDF: Document,\n    externalCalculationOrder: Element | null\n  ): void {\n    if (externalCalculationOrder === null) {\n      return;\n    }\n\n    const pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n    this.putElement(pdfInfoElement, 'calculation-order', externalCalculationOrder);\n  }\n\n  private mergeDocumentActions(\n    internalXFDF: Document,\n    externalDocumentActions: Element | null\n  ): void {\n    if (externalDocumentActions === null) {\n      return;\n    }\n\n    const pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n    this.putElement(pdfInfoElement, 'document-actions', externalDocumentActions);\n  }\n\n  private mergeMarkupAnnotations(internalXFDF: Document, annots: Record<string, Element>): void {\n    const xfdfElement = internalXFDF.querySelector('xfdf');\n    const annotsElement = this.appendElementIfAbsent(xfdfElement, 'annots');\n\n    Object.keys(annots).forEach((annotId) => {\n      this.putElement(annotsElement, `[name=\"${annotId}\"]`, annots[annotId]);\n    });\n  }\n\n  private mergeWidgetsAndFields(\n    internalXFDF: Document,\n    widgets: Element[],\n    fields: Record<string, Field>\n  ): void {\n    if (widgets.length === 0) {\n      return;\n    }\n\n    const pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n\n    widgets.forEach((widgetElement) => {\n      const associatedFieldName = widgetElement.getAttribute('field');\n      const field = fields[associatedFieldName];\n\n      if (field) {\n        this.mergeField(internalXFDF, associatedFieldName, field);\n        this.putElement(pdfInfoElement, 'null', widgetElement);\n      }\n    });\n  }\n\n  private mergeField(internalXFDF: Document, fieldName: string, field: Field): void {\n    const pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n    // merge <ffield> in <pdf-info>\n    // Check if the ffield already exists in <pdf-info>, if not, add it\n    const ffield = pdfInfoElement.querySelector(`ffield[name=\"${fieldName}\"]`);\n    if (field.ffield !== null && ffield === null) {\n      this.putElement(pdfInfoElement, `ffield[name=\"${fieldName}\"]`, field.ffield);\n    }\n\n    // merge <field> in <fields>\n    const xfdfElement = internalXFDF.querySelector('xfdf');\n    const fieldsElement = this.appendElementIfAbsent(xfdfElement, 'xfdf > fields', 'fields');\n    const nameParts = fieldName.split('.');\n\n    this.putFieldElementRecursively(fieldsElement, nameParts, 0, field.value);\n\n    field.hasMerged = true;\n  }\n\n  private mergePDFInfoPage(internalXFDF: Document, page: Element | null, pageIndex: number): void {\n    if (page === null) {\n      return;\n    }\n\n    const pdfInfoElement = this.appendPDFInfoElementIfAbsent(internalXFDF);\n    const pagesElement = this.appendElementIfAbsent(pdfInfoElement, 'pages');\n\n    const pageNum = pageIndex + 1;\n    this.putElement(pagesElement, `[number=\"${pageNum}\"]`, page);\n  }\n\n  private mergeDeletedAnnotations(\n    internalXFDF: Document,\n    deletedAnnotIds: Record<string, boolean>\n  ): void {\n    Object.keys(deletedAnnotIds).forEach((id) => {\n      const annotElement = internalXFDF.querySelector(`annots [name=\"${id}\"]`);\n      if (annotElement) {\n        annotElement.parentElement.removeChild(annotElement);\n      }\n    });\n  }\n\n  private putFieldElementRecursively(\n    parentElement: Element,\n    fieldNames: string[],\n    nameIndex: number,\n    fieldValue: string\n  ): void {\n    if (nameIndex === fieldNames.length) {\n      const valueElement = document.createElementNS('', 'value');\n      valueElement.textContent = fieldValue;\n      this.putElement(parentElement, 'value', valueElement);\n\n      return;\n    }\n\n    const fieldName = fieldNames[nameIndex];\n\n    const fieldElement = this.appendElementIfAbsent(\n      parentElement,\n      `[name=\"${fieldName}\"]`,\n      'field'\n    );\n    fieldElement.setAttribute('name', fieldName);\n\n    const childElements = parentElement.querySelectorAll(`[name=\"${fieldName}\"]`);\n    if (childElements.length === 1) {\n      this.putFieldElementRecursively(childElements[0], fieldNames, nameIndex + 1, fieldValue);\n      return;\n    }\n\n    // it's possible to have multiple children that have the same field name. For example:\n    //\n    // <field name=\"Feld\">\n    //   <field name=\"7\">\n    //     <value>Off</value>\n    //   </field>\n    //   <field name=\"7\">\n    //     <field name=\"1\">\n    //       <value>On</value>\n    //     </field>\n    //   </field>\n    // </field>\n    //\n    // in this case, when the current field name is \"7\", we need to pick the correct child element to continue our recursion\n\n    const isLeaf = nameIndex === fieldNames.length - 1;\n    // we made an assumption here that a leaf element always exists if there're two <field> elements with the same name attribute\n    const leafFieldElement = this.findLeafFieldElement(childElements);\n    const childElement = isLeaf ? leafFieldElement : this.theOther(childElements, leafFieldElement);\n\n    this.putFieldElementRecursively(childElement, fieldNames, nameIndex + 1, fieldValue);\n  }\n\n  private findLeafFieldElement(childElements: NodeListOf<Element>): Element {\n    let leafElement = null;\n\n    for (let i = 0; i < childElements.length; i++) {\n      const element = childElements[i];\n\n      if (\n        element.childElementCount === 0 ||\n        (element.childElementCount === 1 && element.children[0].tagName === 'value')\n      ) {\n        leafElement = element;\n        break;\n      }\n    }\n\n    return leafElement;\n  }\n\n  // Returns the element that is not equal to the given element in a list of two elements\n  private theOther(elements: NodeListOf<Element>, e: Element): Element {\n    for (let i = 0; i < elements.length; i++) {\n      if (elements[i] !== e) {\n        return elements[i];\n      }\n    }\n\n    return null;\n  }\n\n  // Override the targetSelector element with the externalElement in the parent element\n  // if the targetSelector element doesn't exist then just append the externalElement\n  private putElement(\n    parentElement: Element,\n    targetSelector: string,\n    externalElement: Element\n  ): void {\n    const internalElement = parentElement.querySelector(targetSelector);\n\n    if (internalElement !== null) {\n      parentElement.removeChild(internalElement);\n    }\n\n    parentElement.appendChild(externalElement);\n  }\n\n  private appendPDFInfoElementIfAbsent(internalXFDF: Document): Element {\n    let pdfInfoElement = internalXFDF.querySelector('pdf-info');\n\n    if (pdfInfoElement !== null) {\n      return pdfInfoElement;\n    }\n\n    const xfdfElement = internalXFDF.querySelector('xfdf');\n    pdfInfoElement = this.appendElementIfAbsent(xfdfElement, 'pdf-info');\n\n    pdfInfoElement.setAttribute('xmlns', 'http://www.pdftron.com/pdfinfo');\n    pdfInfoElement.setAttribute('version', '2');\n    pdfInfoElement.setAttribute('import-version', '4');\n\n    return pdfInfoElement;\n  }\n\n  // Append an element in the parentElement if targetSelector can't be found in it\n  // The element's tag name is determined by targetTagName, or targetSelector if targetTagName is undefined\n  private appendElementIfAbsent(\n    parentElement: Element,\n    targetSelector: string,\n    targetTagName?: string\n  ): Element {\n    let targetElement = parentElement.querySelector(targetSelector);\n\n    if (targetElement !== null) {\n      return targetElement;\n    }\n\n    targetElement = document.createElementNS('', targetTagName || targetSelector);\n    parentElement.appendChild(targetElement);\n\n    return targetElement;\n  }\n}\n\nexport default ExternalAnnotationMerger;\n","export type ParsedExternalXFDF = {\n  /**\n   * The <calculation-order> element that is found in the <pdf-info> element\n   */\n  calculationOrder: Element | null;\n  /**\n   * The <document-actions> element that is found in the <document-actions> element\n   */\n  documentActions: Element | null;\n  /**\n   * A record where the key is the field name, and the value is an Field object that contains the field information\n   */\n  fields: Record<string, Field>;\n  /**\n   * A record where the key is the page index, and the value is an Page object that contains the information for the page\n   */\n  pages: Record<number, Page>;\n};\nexport type Field = {\n  /**\n   * The value of a <field> that is found in the <fields> element\n   */\n  value: string | null;\n  /**\n   * The <ffield> element of a field that is found in the <pdf-info> element\n   * This is a custom XFDF element that's made up, and is used to store necessary field information\n   * that can not be found in the <field> element\n   */\n  ffield: any;\n  /**\n   * A boolean flag indicates whether the field has been merged into the document\n   * This boolean flag is used to make sure that all external field will be merged into the document\n   * even if the field doesn't any widgets\n   */\n  hasMerged: boolean;\n};\nexport type Page = {\n  /**\n   * A record where the key is the id of the annotation, and the value is the annotation's XFDF\n   * For example, { '8a203791-7b84-8ec6-be2f-dd69a256b7ef': <highlight color=\"..\">...</highlight> }\n   */\n  annots: Record<string, Element>;\n  /**\n   * A record where the key is the id of the annotation that should be deleted from the internal annotations\n   */\n  deletedAnnotIds: Record<string, boolean>;\n  /**\n   * An array of widget elements that are found in the <pdf-info> element\n   */\n  widgets: Element[];\n  /**\n   * The <page> element that is found in the <pdf-info> element\n   */\n  page: Element | null;\n};\n\nabstract class Parser {\n  abstract parse(): ParsedExternalXFDF;\n\n  abstract getMarkupAnnotElements(rootElement: Document): NodeListOf<Element> | Element[];\n\n  abstract getDeletedAnnotElements(rootElement: Document): NodeListOf<Element> | Element[];\n\n  protected _parse(externalXFDFString: string): ParsedExternalXFDF {\n    const result: ParsedExternalXFDF = {\n      calculationOrder: null,\n      documentActions: null,\n      fields: {},\n      pages: {},\n    };\n\n    const parser = new DOMParser();\n    const rootElement = parser.parseFromString(externalXFDFString, 'text/xml');\n\n    result.calculationOrder = rootElement.querySelector('pdf-info calculation-order');\n    result.documentActions = rootElement.querySelector('pdf-info document-actions');\n    result.fields = this.parseFields(rootElement);\n    result.pages = this.parsePages(rootElement);\n\n    return result;\n  }\n\n  private parseFields(rootElement: Document): Record<string, Field> {\n    const fieldsElement = rootElement.querySelector('fields');\n    const ffieldElements = rootElement.querySelectorAll('pdf-info > ffield');\n\n    if (fieldsElement === null && ffieldElements === null) {\n      return {};\n    }\n\n    const fields: Record<string, Field> = {};\n\n    this.addFieldsByBFS(fields, fieldsElement);\n    this.addFFields(fields, ffieldElements);\n\n    return fields;\n  }\n\n  /**\n   * Gets the information of <field> elements in the <fields> element and add them to the fields object using breadth-first search\n   */\n  private addFieldsByBFS(fields: Record<string, Field>, fieldsElement: Element | null): void {\n    if (fieldsElement === null || !fieldsElement.children) {\n      return;\n    }\n\n    // <field> elements are represented as a n-ary tree with <fields> being the root node\n    // Each <field> element may have multiple <field> elements as its children and the leaf node contains the value of the field\n    //\n    // The following example shows the result of this traversal.\n    // Input:\n    //  <fields>\n    //    <field name=\"a\">\n    //      <field name=\"b\">\n    //        <value>1</value>\n    //      </field>\n    //    </field>\n    //    <field name=\"c\">\n    //      <value>2</value>\n    //    </field>\n    //  </fields>\n    // Output:\n    // {\n    //   'a.b': { value: 1, ffield: null, hasMerged: false }\n    //   'c': { value: 2, ffield: null, hasMerged: false }\n    // }\n    const queue: Array<{ name: string; element: Element }> = [];\n\n    for (let i = 0; i < fieldsElement.children.length; i++) {\n      const rootField = fieldsElement.children[i];\n      queue.push({\n        name: rootField.getAttribute('name'),\n        element: rootField,\n      });\n    }\n\n    while (queue.length !== 0) {\n      const field = queue.shift();\n\n      for (let i = 0; i < field.element.children.length; i++) {\n        const child = field.element.children[i];\n\n        if (child.tagName === 'value') {\n          fields[field.name] = {\n            value: child.textContent,\n            ffield: null,\n            hasMerged: false,\n          };\n          continue;\n        }\n\n        if (child.children) {\n          queue.push({\n            name: `${field.name}.${child.getAttribute('name')}`,\n            element: child,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the information of <ffield> elements and add them to the fields object\n   */\n  private addFFields(fields: Record<string, Field>, ffieldElements: NodeListOf<Element>): void {\n    ffieldElements.forEach((ffieldElement) => {\n      const name = ffieldElement.getAttribute('name');\n\n      if (!fields[name]) {\n        fields[name] = {\n          value: null,\n          ffield: ffieldElement,\n          hasMerged: false,\n        };\n\n        return;\n      }\n\n      fields[name].ffield = ffieldElement;\n    });\n  }\n\n  /**\n   * Gets elements that have associated page numbers(or indexes) in the rootElement and add them to the returned page object\n   */\n  private parsePages(rootElement: Document): Record<number, Page> {\n    const pages: Record<number, Page> = {};\n\n    const widgetElements = rootElement.querySelectorAll('pdf-info widget');\n    widgetElements.forEach((widgetElement) => {\n      const pageNum = parseInt(widgetElement.getAttribute('page'), 10);\n      const pageIndex = pageNum - 1;\n\n      this.initializePageIfAbsent(pages, pageIndex);\n      pages[pageIndex].widgets.push(widgetElement);\n    });\n\n    const pageElements = rootElement.querySelectorAll('pdf-info page');\n    pageElements.forEach((pageElement) => {\n      const pageNum = parseInt(pageElement.getAttribute('number'), 10);\n      const pageIndex = pageNum - 1;\n\n      this.initializePageIfAbsent(pages, pageIndex);\n      pages[pageIndex].page = pageElement;\n    });\n\n    const markupAnnotElements = this.getMarkupAnnotElements(rootElement);\n    markupAnnotElements.forEach((markupAnnotElement: Element) => {\n      const pageIndex = parseInt(markupAnnotElement.getAttribute('page'), 10);\n      const id = markupAnnotElement.getAttribute('name');\n\n      this.initializePageIfAbsent(pages, pageIndex);\n      pages[pageIndex].annots[id] = markupAnnotElement;\n    });\n\n    const deletedAnnotElements = this.getDeletedAnnotElements(rootElement);\n    deletedAnnotElements.forEach((deletedAnnotElement: Element) => {\n      const pageIndex = parseInt(deletedAnnotElement.getAttribute('page'), 10);\n      const id = deletedAnnotElement.textContent;\n\n      this.initializePageIfAbsent(pages, pageIndex);\n      pages[pageIndex].deletedAnnotIds[id] = true;\n    });\n\n    return pages;\n  }\n\n  private initializePageIfAbsent(pages: Record<number, Page>, pageIndex: number): void {\n    if (!pages[pageIndex]) {\n      pages[pageIndex] = {\n        annots: {},\n        deletedAnnotIds: {},\n        widgets: [],\n        page: null,\n      };\n    }\n  }\n}\n\nexport default Parser;","import { merge } from 'lodash';\nimport Parser, { ParsedExternalXFDF } from './Parser';\n\nclass CommandXFDFParser extends Parser {\n  private externalXFDFCommands: string[];\n\n  constructor(externalXFDFCommands: string | string[]) {\n    super();\n    this.externalXFDFCommands = Array.isArray(externalXFDFCommands)\n      ? externalXFDFCommands\n      : [externalXFDFCommands];\n  }\n\n  parse(): ParsedExternalXFDF {\n    let result: ParsedExternalXFDF = {\n      calculationOrder: null,\n      documentActions: null,\n      fields: {},\n      pages: {},\n    };\n\n    this.externalXFDFCommands.forEach((command) => {\n      result = merge(result, this._parse(command));\n    });\n\n    return result;\n  }\n\n  getMarkupAnnotElements(rootElement: Document): NodeListOf<Element> | Element[] {\n    const elements: Element[] = [];\n\n    rootElement.querySelectorAll('add > *').forEach((element) => {\n      elements.push(element);\n    });\n\n    rootElement.querySelectorAll('modify > *').forEach((element) => {\n      elements.push(element);\n    });\n\n    return elements;\n  }\n\n  getDeletedAnnotElements(rootElement: Document): NodeListOf<Element> | Element[] {\n    return rootElement.querySelectorAll('delete > *');\n  }\n}\n\nexport default CommandXFDFParser;","import Parser, { ParsedExternalXFDF } from './Parser';\n\nclass ExternalRegularXFDFParser extends Parser {\n  private externalXFDFString: string;\n\n  constructor(externalXFDFString: string) {\n    super();\n    this.externalXFDFString = externalXFDFString;\n  }\n\n  parse(): ParsedExternalXFDF {\n    return this._parse(this.externalXFDFString);\n  }\n\n  getMarkupAnnotElements(rootElement: Document): NodeListOf<Element> | Element[] {\n    return rootElement.querySelectorAll('annots > *');\n  }\n\n  getDeletedAnnotElements(): Element[] {\n    // XFDF string that's exported from exportAnnotations doesn't contain any information for deleted annotations\n    // so just return an empty array\n    return [];\n  }\n}\n\nexport default ExternalRegularXFDFParser;"],"mappings":";AAAA;AC+CA;AAqBA;AAmDA;AAsDA;AAyCA;AAoDA;AAyEA;ACpRA;AAuCA;AAmEA;AAgDA;AChMA;ACPA;","sourceRoot":""}