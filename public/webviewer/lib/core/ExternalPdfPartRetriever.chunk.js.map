{"version":3,"file":"ExternalPdfPartRetriever.chunk.js","sources":["webpack:///ExternalPdfPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/ExternalPdfPartRetriever.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[5],{\n\n/***/ 525:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _util_events_EventHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(195);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(439);\n/* harmony import */ var _util_resetImageOrientation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(248);\n\n\n\n\n\nvar exports = window;\n/**\n * ExternalPdfPartRetriever retrieves Document data from a url.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n *\n * @class Represents a pdf document retriever.\n * @name ExternalPdfPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {object} options Additional options\n * @param {boolean} options.useDownloader Whether to use Downloader, defaults to false.\n * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest\n * @param {object} [options.customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nvar ExternalPdfPartRetriever = /** @class */ (function () {\n    function ExternalPdfPartRetriever(url, options) {\n        this.isImage = function (fileName) {\n            var parts = fileName.split('.');\n            var extension = parts[parts.length - 1];\n            return extension.match(/(jpg|jpeg|png|gif)$/i);\n        };\n        options = options || {};\n        this.url = url;\n        this.filename = options['filename'] || url;\n        this.customHeaders = options['customHeaders'];\n        this.useDownloader = !!options['useDownloader'];\n        this.withCredentials = !!options['withCredentials'];\n    }\n    ExternalPdfPartRetriever.prototype.setCustomHeaders = function (headers) {\n        this.customHeaders = headers;\n    };\n    // No need for JSDoc here because this function is only used internally by PDF.js Express.\n    ExternalPdfPartRetriever.prototype['getCustomHeaders'] = function () {\n        return this.customHeaders;\n    };\n    // Requires callback to be non-null\n    ExternalPdfPartRetriever.prototype.getFileData = function (callback) {\n        var _this = this;\n        var me = this;\n        var xhr = new XMLHttpRequest();\n        var responseType = (this.url.indexOf('blob:') === 0 ? 'blob' : 'arraybuffer');\n        xhr.open('GET', this.url, true);\n        xhr.withCredentials = this.withCredentials;\n        // Set the responseType to arraybuffer. \"blob\" is an option too, rendering manual Blob creation unnecessary, but the support for \"blob\" is not widespread enough yet\n        // @ts-ignore\n        xhr.responseType = responseType;\n        if (this.customHeaders) {\n            // set custom headers\n            Object.keys(this.customHeaders).forEach(function (header) {\n                xhr.setRequestHeader(header, _this.customHeaders[header]);\n            });\n        }\n        var isHttp = /^https?:/i.test(this.url);\n        xhr.addEventListener('load', function (evt) {\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n                var blob, arrayBuffer, reader, data, blob, arrayBuffer, e_1, currentTarget, serverResponse;\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (!(this.status === 200 || (!isHttp && this.status === 0))) return [3 /*break*/, 10];\n                            // we have successfully downloaded the document (or we are about to\n                            // read from a local file which is very fast)\n                            me.trigger(ExternalPdfPartRetriever['Events']['DOCUMENT_LOADING_PROGRESS'], [evt.loaded, evt.loaded]);\n                            if (!(this.responseType === 'blob')) return [3 /*break*/, 4];\n                            blob = this.response;\n                            if (!me.isImage(me.filename)) return [3 /*break*/, 2];\n                            return [4 /*yield*/, Object(_util_resetImageOrientation__WEBPACK_IMPORTED_MODULE_4__[/* resetOrientationAsArrayBuffer */ \"b\"])(blob)];\n                        case 1:\n                            arrayBuffer = _a.sent();\n                            me.fileSize = arrayBuffer.byteLength;\n                            callback(new Uint8Array(arrayBuffer));\n                            return [3 /*break*/, 3];\n                        case 2:\n                            reader = new FileReader();\n                            reader.onload = function (e) {\n                                // @ts-ignore TODO-TS What is intended here? e.target.result is a string which cannot be used to instantiate an array buffer\n                                var result = new Uint8Array(e.target.result);\n                                me.fileSize = result.length;\n                                callback(result);\n                            };\n                            reader.readAsArrayBuffer(blob);\n                            _a.label = 3;\n                        case 3: return [3 /*break*/, 9];\n                        case 4:\n                            _a.trys.push([4, 8, , 9]);\n                            data = new Uint8Array(this.response);\n                            if (!me.isImage(me.filename)) return [3 /*break*/, 6];\n                            blob = new Blob([data.buffer]);\n                            return [4 /*yield*/, Object(_util_resetImageOrientation__WEBPACK_IMPORTED_MODULE_4__[/* resetOrientationAsArrayBuffer */ \"b\"])(blob)];\n                        case 5:\n                            arrayBuffer = _a.sent();\n                            me.fileSize = arrayBuffer.byteLength;\n                            callback(new Uint8Array(arrayBuffer));\n                            return [3 /*break*/, 7];\n                        case 6:\n                            me.fileSize = data.length;\n                            callback(data);\n                            _a.label = 7;\n                        case 7: return [3 /*break*/, 9];\n                        case 8:\n                            e_1 = _a.sent();\n                            me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', 'Out of memory']);\n                            return [3 /*break*/, 9];\n                        case 9: return [3 /*break*/, 11];\n                        case 10:\n                            currentTarget = evt.currentTarget;\n                            serverResponse = Object(_utils__WEBPACK_IMPORTED_MODULE_2__[/* createServerResponse */ \"b\"])(currentTarget);\n                            me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', this.status + \" \" + currentTarget.statusText, serverResponse]);\n                            _a.label = 11;\n                        case 11:\n                            me.xhr = null; // to free memory held by xhr\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        }, false);\n        xhr.onprogress = function (evt) {\n            me.trigger(ExternalPdfPartRetriever['Events']['DOCUMENT_LOADING_PROGRESS'], [evt.loaded, evt.total > 0 ? evt.total : 0]);\n        };\n        xhr.addEventListener('error', function () {\n            me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', 'Network failure']);\n            me.xhr = null; // to free memory held by xhr\n        }, false);\n        xhr.send();\n        this.xhr = xhr;\n    };\n    ExternalPdfPartRetriever.prototype.getFile = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            if (exports.Core.isJSWorker) {\n                resolve(_this.url);\n            }\n            if (_this.useDownloader) {\n                var result = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ \"a\"])({ url: _this.url }, (_this.customHeaders ? { 'customHeaders': _this.customHeaders } : {}));\n                resolve(result);\n            }\n            resolve(null);\n        });\n    };\n    ExternalPdfPartRetriever.prototype.abort = function () {\n        if (this.xhr) {\n            this.xhr.abort();\n            this.xhr = null; // to free memory held by xhr\n        }\n    };\n    ExternalPdfPartRetriever['Events'] = {\n        'DOCUMENT_LOADING_PROGRESS': 'documentLoadingProgress',\n        'ERROR': 'error'\n    };\n    return ExternalPdfPartRetriever;\n}());\nObject(_util_events_EventHandler__WEBPACK_IMPORTED_MODULE_1__[/* useEventHandler */ \"a\"])(ExternalPdfPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_3__[/* exportEventHandler */ \"a\"])(ExternalPdfPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_3__[/* exportPartRetrieverFunctions */ \"b\"])(ExternalPdfPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (ExternalPdfPartRetriever);\n\n\n/***/ })\n\n}]);","import EventHandler, { useEventHandler } from '../../util/events/EventHandler';\nimport { PartRetrieverHeaders } from './PartRetriever';\nimport { createServerResponse, ServerResponse } from './utils';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\nimport { resetOrientationAsArrayBuffer } from '../../util/resetImageOrientation';\n\nconst exports = window;\n\n/**\n * ExternalPdfPartRetriever retrieves Document data from a url.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n *\n * @class Represents a pdf document retriever.\n * @name ExternalPdfPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {object} options Additional options\n * @param {boolean} options.useDownloader Whether to use Downloader, defaults to false.\n * @param {boolean} options.withCredentials Whether to set the withCredentials property on the XMLHttpRequest\n * @param {object} [options.customHeaders] Custom headers to send with the XMLHttpRequests\n * @ignore\n */\nclass ExternalPdfPartRetriever {\n  url: string;\n\n  filename: string;\n\n  customHeaders: PartRetrieverHeaders;\n\n  useDownloader: boolean;\n\n  withCredentials: boolean;\n\n  fileSize?: number;\n\n  xhr: XMLHttpRequest\n\n  static 'Events' = {\n    'DOCUMENT_LOADING_PROGRESS': 'documentLoadingProgress',\n    'ERROR': 'error'\n  } as const;\n\n  constructor(url: string, options?: { useDownloader?: boolean; withCredentials?: boolean; filename?: string; customHeaders?: PartRetrieverHeaders }) {\n    options = options || {};\n    this.url = url;\n    this.filename = options['filename'] || url;\n    this.customHeaders = options['customHeaders'];\n    this.useDownloader = !!options['useDownloader'];\n    this.withCredentials = !!options['withCredentials'];\n  }\n\n  setCustomHeaders(headers: PartRetrieverHeaders) {\n    this.customHeaders = headers;\n  }\n\n  // No need for JSDoc here because this function is only used internally by PDF.js Express.\n  'getCustomHeaders'() {\n    return this.customHeaders;\n  }\n\n  // Requires callback to be non-null\n  getFileData(callback: (data: Uint8Array) => void) {\n    const me = this;\n    const xhr = new XMLHttpRequest();\n    const responseType = (this.url.indexOf('blob:') === 0 ? 'blob' : 'arraybuffer');\n    xhr.open('GET', this.url, true);\n    xhr.withCredentials = this.withCredentials;\n    // Set the responseType to arraybuffer. \"blob\" is an option too, rendering manual Blob creation unnecessary, but the support for \"blob\" is not widespread enough yet\n    // @ts-ignore\n    xhr.responseType = responseType;\n    if (this.customHeaders) {\n      // set custom headers\n      Object.keys(this.customHeaders).forEach((header) => {\n        xhr.setRequestHeader(header, this.customHeaders[header]);\n      });\n    }\n    const isHttp = /^https?:/i.test(this.url);\n    xhr.addEventListener('load', async function(evt) {\n      if (this.status === 200 || (!isHttp && this.status === 0)) {\n        // we have successfully downloaded the document (or we are about to\n        // read from a local file which is very fast)\n        me.trigger(ExternalPdfPartRetriever['Events']['DOCUMENT_LOADING_PROGRESS'], [evt.loaded, evt.loaded]);\n        if (this.responseType === 'blob') {\n          const blob = this.response;\n          if (me.isImage(me.filename)) {\n            const arrayBuffer = await resetOrientationAsArrayBuffer(blob as File);\n            me.fileSize = arrayBuffer.byteLength;\n            callback(new Uint8Array(arrayBuffer));\n          } else {\n            const reader = new FileReader();\n            reader.onload = function(e) {\n              // @ts-ignore TODO-TS What is intended here? e.target.result is a string which cannot be used to instantiate an array buffer\n              const result = new Uint8Array(e.target.result);\n              me.fileSize = result.length;\n              callback(result);\n            };\n            reader.readAsArrayBuffer(blob);\n          }\n        } else {\n          try {\n            const data = new Uint8Array(this.response);\n            if (me.isImage(me.filename)) {\n              const blob = new Blob([data.buffer]);\n              const arrayBuffer = await resetOrientationAsArrayBuffer(blob as File);\n              me.fileSize = arrayBuffer.byteLength;\n              callback(new Uint8Array(arrayBuffer));\n            } else {\n              me.fileSize = data.length;\n              callback(data);\n            }\n          } catch (e) {\n            me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', 'Out of memory']);\n          }\n        }\n      } else {\n        const currentTarget = evt.currentTarget as XMLHttpRequest;\n        const serverResponse = createServerResponse(currentTarget);\n        me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', `${this.status} ${currentTarget.statusText}`, serverResponse]);\n      }\n\n      me.xhr = null; // to free memory held by xhr\n    }, false);\n    xhr.onprogress = function(evt) {\n      me.trigger(ExternalPdfPartRetriever['Events']['DOCUMENT_LOADING_PROGRESS'], [evt.loaded, evt.total > 0 ? evt.total : 0]);\n    };\n    xhr.addEventListener('error', function() {\n      me.trigger(ExternalPdfPartRetriever['Events']['ERROR'], ['pdfLoad', 'Network failure']);\n      me.xhr = null; // to free memory held by xhr\n    }, false);\n\n    xhr.send();\n    this.xhr = xhr;\n  }\n\n  getFile(): Promise<string | {url: string; customHeaders?: PartRetrieverHeaders}> {\n    return new Promise((resolve) => {\n      if (exports.Core.isJSWorker) {\n        resolve(this.url);\n      }\n      if (this.useDownloader) {\n        const result = {\n          url: this.url,\n          ...(this.customHeaders ? { 'customHeaders': this.customHeaders } : {}),\n        };\n        resolve(result);\n      }\n      resolve(null);\n    });\n  }\n\n  abort() {\n    if (this.xhr) {\n      this.xhr.abort();\n      this.xhr = null; // to free memory held by xhr\n    }\n  }\n\n  private isImage = (fileName: string) => {\n    const parts = fileName.split('.');\n    const extension = parts[parts.length - 1];\n    return extension.match(/(jpg|jpeg|png|gif)$/i);\n  }\n}\n\ntype ExternalPdfPartRetrieverEvents = {\n  [ExternalPdfPartRetriever.Events.ERROR]: [string, string, ServerResponse?];\n  [ExternalPdfPartRetriever.Events.DOCUMENT_LOADING_PROGRESS]: [number, number];\n}\n\ninterface ExternalPdfPartRetriever extends EventHandler<ExternalPdfPartRetrieverEvents> { }\nuseEventHandler(ExternalPdfPartRetriever);\n\nexportEventHandler(ExternalPdfPartRetriever);\nexportPartRetrieverFunctions(ExternalPdfPartRetriever);\n\nexport default ExternalPdfPartRetriever;\n"],"mappings":";AAAA;AC8DA;AAiBA;AAsBA;AAsBA;AAnFA;","sourceRoot":""}