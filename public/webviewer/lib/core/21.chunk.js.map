{"version":3,"file":"21.chunk.js","sources":["webpack:///21.chunk.js","webpack:///./src/core/src/namespaces/WebViewerServer/WebViewerServerAnnotationManager.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[21],{\n\n/***/ 537:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _util_constants_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _util_events_EventHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);\n/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);\n/* harmony import */ var _Core_AnnotationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);\n\n\n\n\n\n\n/**\n * Creates a new instance of WebViewerServerAnnotationManager.\n *  * <b>Note</b>: As of version 6.3, directly constructing a WebViewerServerAnnotationManager is deprecated and the capability will be removed in a future version. Please use the {@link Core.getWebViewerServerAnnotationManager} function instead.\n * @class An object which manages anonymous user annotations when using WebViewerServer.\n * @name WebViewerServerAnnotationManager\n * @memberof Core\n */\nvar WebViewerServerAnnotationManager = /** @class */ (function () {\n    function WebViewerServerAnnotationManager() {\n        this.init();\n    }\n    WebViewerServerAnnotationManager.prototype.init = function () {\n        this.collabEnabled = false;\n        this.connection = null;\n        this.cbWatchFunc = null;\n        this.serverRoot = null;\n        this.authors = {};\n        this.userId = null;\n        this.annotationManager = null;\n    };\n    // Updates client side annotations with incoming annotations\n    WebViewerServerAnnotationManager.prototype.updateAnnotations = function (data) {\n        var _this = this;\n        for (var i = 0; i < data.length; ++i) {\n            var annot = data[i];\n            switch (annot['at']) {\n                case 'create':\n                    if (!this.authors[annot['author']]) {\n                        this.authors[annot['author']] = annot['aName'];\n                    }\n                    this.importCreateAnnotation(annot);\n                    break;\n                case 'modify':\n                    this.annotationManager.importAnnotationCommand(annot['xfdf']).then(function (_a) {\n                        var annotation = _a[0];\n                        _this.annotationManager.redrawAnnotation(annotation);\n                    });\n                    break;\n                case 'delete':\n                    var command = \"<delete><id>\" + annot['aId'] + \"</id></delete>\";\n                    this.annotationManager.importAnnotationCommand(command);\n                    break;\n            }\n        }\n    };\n    WebViewerServerAnnotationManager.prototype.importCreateAnnotation = function (annotData) {\n        var _this = this;\n        this.annotationManager.importAnnotationCommand(annotData['xfdf']).then(function (_a) {\n            var annotation = _a[0];\n            // @ts-ignore TODO-TS\n            annotation['authorId'] = annotData['author'];\n            _this.annotationManager.redrawAnnotation(annotation);\n            _this.annotationManager.trigger(_util_constants_events__WEBPACK_IMPORTED_MODULE_1__[/* AnnotationManagerEvents */ \"c\"]['UPDATE_ANNOTATION_PERMISSION'], [annotation]);\n        });\n    };\n    WebViewerServerAnnotationManager.prototype.getWatchFunc = function (annotations, type, options) {\n        if (this.cbWatchFunc) {\n            this.cbWatchFunc(annotations, type, options);\n        }\n    };\n    /**\n     * Preloads existing annotations made without realtime collaboration enabled,\n     * will only trigger once on initial collaboration enabling event.\n     * @method Core.WebViewerServerAnnotationManager#preloadAnnotations\n     * @param {Array<Core.Annotations.Annotation>} An array of annotation objects.\n     */\n    WebViewerServerAnnotationManager.prototype['preloadAnnotations'] = function (annotations) {\n        var me = this;\n        this.addEventListener('webViewerServerAnnotationsEnabled', me.getWatchFunc.bind(me, annotations, 'add', { 'imported': false }), { 'once': true });\n    };\n    /**\n     * Opens a connection to the annotation server and sets up collaboration.\n     * @method Core.WebViewerServerAnnotationManager#initiateCollaboration\n     * @param {string} docId The document ID of the object to intiate annotation collaboration on.\n     * @param {string} serverRoot The webViewerServer annotation server to contact for annot storing.\n     * @param {Core.DocumentViewer} docViewer An instance of DocumentViewer.\n     */\n    WebViewerServerAnnotationManager.prototype['initiateCollaboration'] = function (docId, serverRoot, docViewer) {\n        // prevents errors when switching documents\n        // replace with document switching mechanism server side\n        var me = this;\n        if (!docId) {\n            Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* error */ \"g\"])('Document ID required for collaboration');\n            return;\n        }\n        me.serverRoot = serverRoot;\n        me.annotationManager = docViewer.getAnnotationManager();\n        docViewer.addEventListener(_util_constants_events__WEBPACK_IMPORTED_MODULE_1__[/* DocumentViewerEvents */ \"h\"]['DOCUMENT_UNLOADED'], function () {\n            me['disableCollaboration']();\n        });\n        me.watchAnnotations(docId);\n        // Get user session\n        var xmlHttp = new XMLHttpRequest();\n        xmlHttp.addEventListener('load', function () {\n            if (xmlHttp.status === 200 && xmlHttp.responseText.length > 0) {\n                try {\n                    var data_1 = JSON.parse(xmlHttp.responseText);\n                    me.connection = exports.Core.WebViewerServerConnectionService(Object(_util_Utils__WEBPACK_IMPORTED_MODULE_4__[/* joinPaths */ \"k\"])(me.serverRoot, 'blackbox/'), 'annot');\n                    me.userId = data_1['id'];\n                    me.authors[data_1['id']] = data_1['user_name'];\n                    me.annotationManager.setCurrentUser(data_1['id']);\n                    var onMessage = function (event) {\n                        if (event['t'] && event['t'].startsWith('a_') && event['data']) {\n                            me.updateAnnotations(event['data']);\n                        }\n                    };\n                    var onClose = function () {\n                        me['disableCollaboration']();\n                    };\n                    var onOpen = function () {\n                        var request = {\n                            't': 'a_retrieve',\n                            'dId': docId,\n                        };\n                        me.connection.send(request);\n                        me.trigger(WebViewerServerAnnotationManager['Events']['WEBVIEWER_SERVER_ANNOTATIONS_ENABLED'], [me.authors[data_1['id']], me.userId]);\n                    };\n                    me.connection.startConnection(onMessage, onOpen, onClose);\n                }\n                catch (err) {\n                    Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* error */ \"g\"])(err.message);\n                }\n            }\n        });\n        xmlHttp.open('GET', Object(_util_Utils__WEBPACK_IMPORTED_MODULE_4__[/* joinPaths */ \"k\"])(this.serverRoot, 'demo/SessionInfo.jsp'));\n        xmlHttp.withCredentials = true;\n        xmlHttp.send();\n        me.collabEnabled = true;\n        me.annotationManager.setAnnotationDisplayAuthorMap(function (annotation) {\n            return me.authors[annotation['Author']] || annotation['Author'];\n        });\n    };\n    /**\n     * Disables collaboration by closing the annotation server connection.\n     * @method Core.WebViewerServerAnnotationManager#disableCollaboration\n     */\n    WebViewerServerAnnotationManager.prototype['disableCollaboration'] = function () {\n        if (this.cbWatchFunc) {\n            this.annotationManager.removeEventListener(_Core_AnnotationManager__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n            this.cbWatchFunc = null;\n        }\n        if (this.connection) {\n            this.connection.endConnection();\n        }\n        if (this.annotationManager) {\n            this.annotationManager.setCurrentUser('Guest');\n        }\n        this.init();\n        this.trigger(WebViewerServerAnnotationManager['Events']['WEBVIEWER_SERVER_ANNOTATIONS_DISABLED']);\n    };\n    // Watches for newly created annotations\n    WebViewerServerAnnotationManager.prototype.watchAnnotations = function (documentId) {\n        var me = this;\n        var newWatchFunc = function (annotations, type, info) {\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n                var annotData, xfdf, parsedXfdf, serializer, i, annotation, xfdfAnnotData, rawXfdf, parentAuthorId;\n                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            // if the annotation is not created by the user, ignore it (the server polling call will\n                            // have inserted them already)\n                            if (info['imported']) {\n                                return [2 /*return*/];\n                            }\n                            annotData = {\n                                't': \"a_\" + type,\n                                'dId': documentId,\n                                'annots': [],\n                            };\n                            return [4 /*yield*/, me.annotationManager.exportAnnotationCommand()];\n                        case 1:\n                            xfdf = _a.sent();\n                            if (type !== 'delete') {\n                                parsedXfdf = new DOMParser().parseFromString(xfdf, 'text/xml');\n                                serializer = new XMLSerializer();\n                            }\n                            for (i = 0; i < annotations.length; i++) {\n                                annotation = annotations[i];\n                                xfdfAnnotData = void 0;\n                                rawXfdf = void 0;\n                                if (type === 'add') {\n                                    xfdfAnnotData = parsedXfdf.querySelector(\"[name=\\\"\" + annotation['Id'] + \"\\\"]\");\n                                    rawXfdf = serializer.serializeToString(xfdfAnnotData);\n                                    parentAuthorId = null;\n                                    if (annotation['InReplyTo']) {\n                                        // @ts-ignore TODO-TS fix this\n                                        parentAuthorId = me.annotationManager.getAnnotationById(annotation['InReplyTo'])['authorId'] || 'default';\n                                    }\n                                    annotData['annots'].push({\n                                        'at': 'create',\n                                        'aId': annotation['Id'],\n                                        'author': me.userId,\n                                        'aName': me.authors[me.userId],\n                                        'parent': parentAuthorId,\n                                        'xfdf': \"<add>\" + rawXfdf + \"</add>\",\n                                    });\n                                }\n                                else if (type === 'modify') {\n                                    xfdfAnnotData = parsedXfdf.querySelector(\"[name=\\\"\" + annotation['Id'] + \"\\\"]\");\n                                    rawXfdf = serializer.serializeToString(xfdfAnnotData);\n                                    annotData['annots'].push({\n                                        'at': 'modify',\n                                        'aId': annotation['Id'],\n                                        'xfdf': \"<modify>\" + rawXfdf + \"</modify>\",\n                                    });\n                                }\n                                else if (type === 'delete') {\n                                    annotData['annots'].push({\n                                        'at': 'delete',\n                                        'aId': annotation['Id'],\n                                    });\n                                }\n                            }\n                            if (annotData['annots'].length > 0) {\n                                me.connection.send(annotData);\n                            }\n                            return [2 /*return*/];\n                    }\n                });\n            });\n        };\n        if (this.cbWatchFunc) {\n            this.annotationManager.removeEventListener(_Core_AnnotationManager__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n        }\n        this.cbWatchFunc = newWatchFunc.bind(me);\n        this.annotationManager.addEventListener(_Core_AnnotationManager__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n    };\n    WebViewerServerAnnotationManager['Events'] = {\n        'WEBVIEWER_SERVER_ANNOTATIONS_ENABLED': 'webViewerServerAnnotationsEnabled',\n        'WEBVIEWER_SERVER_ANNOTATIONS_DISABLED': 'webViewerServerAnnotationsDisabled'\n    };\n    return WebViewerServerAnnotationManager;\n}());\nObject(_util_events_EventHandler__WEBPACK_IMPORTED_MODULE_3__[/* useEventHandler */ \"a\"])(WebViewerServerAnnotationManager);\n/**\n * Triggered when collaboration is enabled for webViewerServer.\n * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsEnabled', callback)\n * @name Core.WebViewerServerAnnotationManager#webViewerServerAnnotationsEnabled\n * @event\n * @param {string} username user name as specified by webViewerServer collaboration.\n * @param {string} userId user ID as specified by webViewerServer collaboration.\n */\n/**\n * Triggered when collaboration has abruptly closed or been disabled.\n * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsDisabled', callback)\n * @name Core.WebViewerServerAnnotationManager#webViewerServerAnnotationsDisabled\n * @event\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (WebViewerServerAnnotationManager);\n\n\n/***/ })\n\n}]);","import { AnnotationManagerEvents, DocumentViewerEvents } from '../../util/constants/events';\nimport { error } from 'logger';\nimport EventHandler, { useEventHandler } from '../../util/events/EventHandler';\nimport { joinPaths } from '../../util/Utils';\nimport { WebViewerServerConnection } from './WebViewerServerConnectionService';\nimport AnnotationManager from '../Core/AnnotationManager';\nimport type { DocumentViewer } from '../Core/DocumentViewer';\nimport type Annotation from '../Annotations/Annotation';\n\ntype WebViewerServerAnnotation = {\n  at: string;\n  author?: string;\n  aName?: string;\n  xfdf?: string;\n  aId: string;\n  authorId?: string;\n  InReplyTo?: string;\n  parent?: string;\n} & Partial<Annotation>\n\ntype WebViewerServerWatchFunc = (annotations: WebViewerServerAnnotation[], type: string, options: WebViewerServerWatchFuncOptions) => void;\n\n// Not sure what goes on here TODO-TS\ninterface WebViewerServerWatchFuncOptions { }\n\n/**\n * Creates a new instance of WebViewerServerAnnotationManager.\n *  * <b>Note</b>: As of version 6.3, directly constructing a WebViewerServerAnnotationManager is deprecated and the capability will be removed in a future version. Please use the {@link Core.getWebViewerServerAnnotationManager} function instead.\n * @class An object which manages anonymous user annotations when using WebViewerServer.\n * @name WebViewerServerAnnotationManager\n * @memberof Core\n */\nclass WebViewerServerAnnotationManager {\n  collabEnabled: boolean;\n  connection: WebViewerServerConnection;\n  cbWatchFunc: WebViewerServerWatchFunc;\n  serverRoot: string;\n  authors: Record<string, string>;\n  userId: string;\n  annotationManager: AnnotationManager;\n\n  static readonly 'Events': Record<string, string> = {\n    'WEBVIEWER_SERVER_ANNOTATIONS_ENABLED': 'webViewerServerAnnotationsEnabled',\n    'WEBVIEWER_SERVER_ANNOTATIONS_DISABLED': 'webViewerServerAnnotationsDisabled'\n  };\n\n  constructor() {\n    this.init();\n  }\n\n  init() {\n    this.collabEnabled = false;\n    this.connection = null;\n    this.cbWatchFunc = null;\n    this.serverRoot = null;\n    this.authors = {};\n    this.userId = null;\n    this.annotationManager = null;\n  }\n\n  // Updates client side annotations with incoming annotations\n  updateAnnotations(data: WebViewerServerAnnotation[]) {\n    for (let i = 0; i < data.length; ++i) {\n      const annot = data[i];\n      switch (annot['at']) {\n        case 'create':\n          if (!this.authors[annot['author']]) {\n            this.authors[annot['author']] = annot['aName'];\n          }\n\n          this.importCreateAnnotation(annot);\n          break;\n        case 'modify':\n          this.annotationManager.importAnnotationCommand(annot['xfdf']).then(([annotation]) => {\n            this.annotationManager.redrawAnnotation(annotation);\n          });\n          break;\n        case 'delete':\n          const command = `<delete><id>${annot['aId']}</id></delete>`;\n          this.annotationManager.importAnnotationCommand(command);\n          break;\n      }\n    }\n  }\n\n  importCreateAnnotation(annotData: WebViewerServerAnnotation) {\n    this.annotationManager.importAnnotationCommand(annotData['xfdf']).then(([annotation]) => {\n      // @ts-ignore TODO-TS\n      annotation['authorId'] = annotData['author'];\n      this.annotationManager.redrawAnnotation(annotation);\n      this.annotationManager.trigger(AnnotationManagerEvents['UPDATE_ANNOTATION_PERMISSION'], [annotation]);\n    });\n  }\n\n  getWatchFunc(annotations: WebViewerServerAnnotation[], type: string, options: WebViewerServerWatchFuncOptions) {\n    if (this.cbWatchFunc) {\n      this.cbWatchFunc(annotations, type, options);\n    }\n  }\n\n  /**\n   * Preloads existing annotations made without realtime collaboration enabled,\n   * will only trigger once on initial collaboration enabling event.\n   * @method Core.WebViewerServerAnnotationManager#preloadAnnotations\n   * @param {Array<Core.Annotations.Annotation>} An array of annotation objects.\n   */\n  'preloadAnnotations'(annotations: WebViewerServerAnnotation[]) {\n    const me = this;\n    this.addEventListener('webViewerServerAnnotationsEnabled', me.getWatchFunc.bind(me, annotations, 'add', { 'imported': false }), { 'once': true });\n  }\n\n  /**\n   * Opens a connection to the annotation server and sets up collaboration.\n   * @method Core.WebViewerServerAnnotationManager#initiateCollaboration\n   * @param {string} docId The document ID of the object to intiate annotation collaboration on.\n   * @param {string} serverRoot The webViewerServer annotation server to contact for annot storing.\n   * @param {Core.DocumentViewer} docViewer An instance of DocumentViewer.\n   */\n  'initiateCollaboration'(docId: string, serverRoot: string, docViewer: DocumentViewer) {\n    // prevents errors when switching documents\n    // replace with document switching mechanism server side\n    const me = this;\n\n    if (!docId) {\n      error('Document ID required for collaboration');\n      return;\n    }\n\n    me.serverRoot = serverRoot;\n    me.annotationManager = docViewer.getAnnotationManager();\n\n    docViewer.addEventListener(DocumentViewerEvents['DOCUMENT_UNLOADED'], function() {\n      me['disableCollaboration']();\n    });\n\n    me.watchAnnotations(docId);\n\n    // Get user session\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.addEventListener('load', function() {\n      if (xmlHttp.status === 200 && xmlHttp.responseText.length > 0) {\n        try {\n          const data = JSON.parse(xmlHttp.responseText);\n          me.connection = exports.Core.WebViewerServerConnectionService(joinPaths(me.serverRoot, 'blackbox/'), 'annot');\n          me.userId = data['id'];\n          me.authors[data['id']] = data['user_name'];\n          me.annotationManager.setCurrentUser(data['id']);\n\n          const onMessage = function(event: any) {\n            if (event['t'] && event['t'].startsWith('a_') && event['data']) {\n              me.updateAnnotations(event['data']);\n            }\n          };\n\n          const onClose = function() {\n            me['disableCollaboration']();\n          };\n\n          const onOpen = function() {\n            const request = {\n              't': 'a_retrieve',\n              'dId': docId,\n            };\n            me.connection.send(request);\n            me.trigger(WebViewerServerAnnotationManager['Events']['WEBVIEWER_SERVER_ANNOTATIONS_ENABLED'], [me.authors[data['id']], me.userId]);\n          };\n\n          me.connection.startConnection(onMessage, onOpen, onClose);\n        } catch (err) {\n          error(err.message);\n        }\n      }\n    });\n    xmlHttp.open('GET', joinPaths(this.serverRoot, 'demo/SessionInfo.jsp'));\n    xmlHttp.withCredentials = true;\n    xmlHttp.send();\n\n    me.collabEnabled = true;\n    me.annotationManager.setAnnotationDisplayAuthorMap(function(annotation) {\n      return me.authors[annotation['Author']] || annotation['Author'];\n    });\n  }\n\n  /**\n   * Disables collaboration by closing the annotation server connection.\n   * @method Core.WebViewerServerAnnotationManager#disableCollaboration\n   */\n  'disableCollaboration'() {\n    if (this.cbWatchFunc) {\n      this.annotationManager.removeEventListener(AnnotationManager['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n      this.cbWatchFunc = null;\n    }\n\n    if (this.connection) {\n      this.connection.endConnection();\n    }\n\n    if (this.annotationManager) {\n      this.annotationManager.setCurrentUser('Guest');\n    }\n\n    this.init();\n    this.trigger(WebViewerServerAnnotationManager['Events']['WEBVIEWER_SERVER_ANNOTATIONS_DISABLED']);\n  }\n\n  // Watches for newly created annotations\n  watchAnnotations(documentId: string) {\n    const me = this;\n    const newWatchFunc = async function(annotations: WebViewerServerAnnotation[], type: string, info: any) {\n      // if the annotation is not created by the user, ignore it (the server polling call will\n      // have inserted them already)\n      if (info['imported']) {\n        return;\n      }\n\n      const annotData = {\n        't': `a_${type}`,\n        'dId': documentId,\n        'annots': [] as WebViewerServerAnnotation[],\n      };\n\n      const xfdf = await me.annotationManager.exportAnnotationCommand();\n      let parsedXfdf;\n      let serializer;\n      if (type !== 'delete') {\n        parsedXfdf = new DOMParser().parseFromString(xfdf, 'text/xml');\n        serializer = new XMLSerializer();\n      }\n\n      for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        let xfdfAnnotData;\n        let rawXfdf;\n        if (type === 'add') {\n          xfdfAnnotData = parsedXfdf.querySelector(`[name=\"${annotation['Id']}\"]`);\n          rawXfdf = serializer.serializeToString(xfdfAnnotData);\n          let parentAuthorId = null;\n\n          if (annotation['InReplyTo']) {\n            // @ts-ignore TODO-TS fix this\n            parentAuthorId = me.annotationManager.getAnnotationById(annotation['InReplyTo'])['authorId'] || 'default';\n          }\n\n          annotData['annots'].push({\n            'at': 'create',\n            'aId': annotation['Id'],\n            'author': me.userId,\n            'aName': me.authors[me.userId],\n            'parent': parentAuthorId,\n            'xfdf': `<add>${rawXfdf}</add>`,\n          });\n        } else if (type === 'modify') {\n          xfdfAnnotData = parsedXfdf.querySelector(`[name=\"${annotation['Id']}\"]`);\n          rawXfdf = serializer.serializeToString(xfdfAnnotData);\n          annotData['annots'].push({\n            'at': 'modify',\n            'aId': annotation['Id'],\n            'xfdf': `<modify>${rawXfdf}</modify>`,\n          });\n        } else if (type === 'delete') {\n          annotData['annots'].push({\n            'at': 'delete',\n            'aId': annotation['Id'],\n          });\n        }\n      }\n\n      if (annotData['annots'].length > 0) {\n        me.connection.send(annotData);\n      }\n    };\n\n    if (this.cbWatchFunc) {\n      this.annotationManager.removeEventListener(AnnotationManager['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n    }\n\n    this.cbWatchFunc = newWatchFunc.bind(me);\n    this.annotationManager.addEventListener(AnnotationManager['Events']['ANNOTATION_CHANGED'], this.cbWatchFunc);\n  }\n}\n\ntype WebViewerServerEvents = {\n  [WebViewerServerAnnotationManager.Events.WEBVIEWER_SERVER_ANNOTATIONS_ENABLED]: [string, string];\n  [WebViewerServerAnnotationManager.Events.WEBVIEWER_SERVER_ANNOTATIONS_DISABLED]: [];\n}\n\ninterface WebViewerServerAnnotationManager extends EventHandler<WebViewerServerEvents> { }\nuseEventHandler(WebViewerServerAnnotationManager);\n\n/**\n * Triggered when collaboration is enabled for webViewerServer.\n * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsEnabled', callback)\n * @name Core.WebViewerServerAnnotationManager#webViewerServerAnnotationsEnabled\n * @event\n * @param {string} username user name as specified by webViewerServer collaboration.\n * @param {string} userId user ID as specified by webViewerServer collaboration.\n */\n\n/**\n * Triggered when collaboration has abruptly closed or been disabled.\n * Attach like webViewerServerAnnotManager.addEventListener('webViewerServerAnnotationsDisabled', callback)\n * @name Core.WebViewerServerAnnotationManager#webViewerServerAnnotationsDisabled\n * @event\n */\n\nexport default WebViewerServerAnnotationManager;"],"mappings":";AAAA;AC6EA;AAyCA;AA2CA;AA6BA;AA+BA;AAoCA;","sourceRoot":""}