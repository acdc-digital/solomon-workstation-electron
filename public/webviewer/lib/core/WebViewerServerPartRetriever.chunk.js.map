{"version":3,"file":"WebViewerServerPartRetriever.chunk.js","sources":["webpack:///WebViewerServerPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/WebViewerServerPartRetriever.ts","webpack:///./src/core/src/namespaces/WebViewerServer/WebViewerServerConnectionService.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[13],{\n\n/***/ 529:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _util_events_EventHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);\n/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);\n/* harmony import */ var _WebViewerServer_WebViewerServerConnectionService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(547);\n/* harmony import */ var _PartRetriever__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(113);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(439);\n/* harmony import */ var _state_globalState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(49);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(195);\n\n\n\n\n\n\n\n\n\n\n// max active page image/tile requests\nvar MAX_ACTIVE_IMAGE_REQUESTS = 10;\nvar VERSION_LENGTH = 3;\nvar nullFunc = function () {\n    return false;\n};\nvar BBPromise = /** @class */ (function () {\n    function BBPromise() {\n        this.result = null;\n        this.request = null;\n        this.state = 0;\n        var me = this;\n        me.promise = new Promise(function (resolve, reject) {\n            me.resolve = function () {\n                if (me.state === 0 || me.state === 4) {\n                    me.state = 1;\n                    // arguments cannot be called in arrow functions\n                    me.result = arguments[0];\n                    resolve.apply(null, arguments);\n                }\n            };\n            me.reject = function () {\n                if (me.state === 0 || me.state === 4) {\n                    me.state = 2;\n                    reject.apply(null, arguments);\n                }\n            };\n        });\n    }\n    BBPromise.prototype.isResolved = function () {\n        return (this.state & 1) === 1;\n    };\n    BBPromise.prototype.isRejected = function () {\n        return (this.state & 2) === 2;\n    };\n    BBPromise.prototype.isPending = function () {\n        return !this.isRejected() && !this.isResolved();\n    };\n    BBPromise.prototype.isDownloading = function () {\n        return (this.state & 4) === 4;\n    };\n    BBPromise.prototype.setDownloading = function () {\n        this.state |= 4;\n    };\n    return BBPromise;\n}());\n// map + lifo queue so queued jobs can be easily canceled\n// when created with requestSendWithQueue\nvar HashedQueue = /** @class */ (function () {\n    function HashedQueue() {\n        this.hashMap = {};\n        this.queue = [];\n    }\n    HashedQueue.prototype.pop = function () {\n        var item = this.queue.pop();\n        this.hashMap[item.key] = undefined;\n        return item;\n    };\n    HashedQueue.prototype.push = function (key, item) {\n        var objEntry = { key: key, data: item };\n        this.queue.push(objEntry);\n        this.hashMap[key] = objEntry.data;\n    };\n    HashedQueue.prototype.contains = function (key) {\n        return !!this.hashMap[key];\n    };\n    HashedQueue.prototype.get = function (key) {\n        return this.hashMap[key];\n    };\n    HashedQueue.prototype.set = function (key, item) {\n        var _this = this;\n        this.hashMap[key] = item;\n        this.queue.forEach(function (item, index) {\n            if (item.key === key) {\n                _this.queue[index] = item;\n            }\n        });\n    };\n    HashedQueue.prototype.remove = function (key) {\n        var _this = this;\n        this.hashMap[key] = undefined;\n        this.queue.forEach(function (item, index) {\n            if (item.key === key) {\n                _this.queue.splice(index, 1);\n            }\n        });\n    };\n    HashedQueue.prototype.length = function () {\n        return this.queue.length;\n    };\n    return HashedQueue;\n}());\nvar responseSchema = {\n    'pages': [{ name: 'pages', type: 'a' }],\n    'pdf': [{ name: 'url', type: 's' }],\n    'docmod': [{ name: 'url', type: 's' }, { name: 'rID', type: 's' }],\n    'health': [],\n    'tiles': [{ name: 'z', type: 'n' }, { name: 'rID', type: 'n' }, { name: 'tiles', type: 'a' }, { name: 'size', type: 'n' }],\n    'cAnnots': [{ name: 'annots', type: 'a' }],\n    'annots': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }],\n    'image': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }, { name: 'p', type: 'n' }],\n    'text': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }, { name: 'p', type: 'n' }],\n    'ApString2Xod': [{ name: 'url', type: 's' }, { name: 'rID', type: 's' }]\n};\nfunction validateField(object, fieldDesc, promiseCapability) {\n    if (!(fieldDesc.name in object)) {\n        promiseCapability.reject(\"Response missing field \\\"\" + fieldDesc.name + \"\\\"\");\n        return false;\n    }\n    var expectedType = '';\n    var isOK = false;\n    var objVal = object[fieldDesc.name];\n    switch (fieldDesc.type) {\n        case 's':\n            expectedType = 'String';\n            isOK = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isString\"])(objVal);\n            break;\n        case 'a':\n            expectedType = 'Array';\n            isOK = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isArray\"])(objVal);\n            break;\n        case 'n':\n            expectedType = 'Number';\n            isOK = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isNumber\"])(objVal) && Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isFinite\"])(objVal);\n            break;\n        case 'o':\n            expectedType = 'Object';\n            isOK = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isObject\"])(objVal) && !Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"isArray\"])(objVal);\n            break;\n    }\n    if (!isOK) {\n        promiseCapability.reject(\"Expected response field \\\"\" + fieldDesc.name + \"\\\" to have type \" + expectedType);\n    }\n    return isOK;\n}\nfunction validateObject(object, type, promiseCapability) {\n    if (!(type in responseSchema)) {\n        // we don't recognize this response type\n        return true;\n    }\n    var schema = responseSchema[type];\n    for (var i = 0; i < schema.length; i++) {\n        if (!validateField(object, schema[i], promiseCapability)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction replaceOfficeKeys(obj) {\n    var keys = [\n        'locale', 'excelMaxAllowedCellCount', 'applyPageBreaksToSheet',\n        'excelDefaultCellBorderWidth', 'displayChangeTracking'\n    ];\n    // We replace the first character with a capital, because the API on webviewer is slightly incorrect.\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var element = keys_1[_i];\n        obj = replaceKey(obj, element, element.charAt(0).toUpperCase() + element.slice(1));\n    }\n    return obj;\n}\nfunction replaceKey(obj, key, replacementKey) {\n    if (obj[key]) {\n        Object.defineProperty(obj, replacementKey, Object.getOwnPropertyDescriptor(obj, key));\n        delete obj[key];\n    }\n    return obj;\n}\n/**\n * Constructs a new WebViewerServerPartRetriever.\n * WebViewerServerPartRetriever streams a .xod file hosted on a web server and display pages as they are available.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a streaming part retriever.\n * @name WebViewerServerPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @ignore\n */\nvar WebViewerServerPartRetriever = /** @class */ (function () {\n    function WebViewerServerPartRetriever(doc, webViewerServer, serverOptions) {\n        var _this = this;\n        this.disableWebsockets = false;\n        this.singleServerMode = false;\n        this.uploadData = null;\n        this.cacheKey = null;\n        this.officeOptions = null;\n        this.cadOptions = null;\n        this.rasterizerOptions = null;\n        this.uriData = null;\n        this.wvsVersion = null;\n        this.requestOptions = null;\n        this.pageSizesPromise = new BBPromise();\n        this.configPromise = new BBPromise();\n        this.connectionStarted = false;\n        this.pdfURLPromise = null;\n        this.xodURLPromise = null;\n        this.xodExistPromise = null;\n        this.annotPromise = null;\n        this.tileRequests = [];\n        this.freeTileRequests = [];\n        this.cache = {};\n        this.timeStamp = 0;\n        this.pageImages = [];\n        this.pageText = [];\n        this.fileExtension = null;\n        this.deadServer = false;\n        this.id = null;\n        this.auth = null;\n        this.serverID = null;\n        this.healthSwitchCallback = nullFunc;\n        this.linkFinderFunc = nullFunc;\n        this.retryCount = 0;\n        this.hasBadHealthState = false;\n        this.nextRequestID = 1;\n        this.linkRequests = {};\n        this.activeImageRequests = 0;\n        this.requestQueue = new HashedQueue();\n        var serverRoot = webViewerServer;\n        if (!serverRoot.endsWith('/')) {\n            serverRoot += '/';\n        }\n        serverOptions = serverOptions || {};\n        this.disableWebsockets = serverOptions['disableWebsockets'] || false;\n        this.singleServerMode = serverOptions['singleServerMode'] || false;\n        if (serverOptions['customQueryParameters'] != null) {\n            Object(_state_globalState__WEBPACK_IMPORTED_MODULE_8__[/* setState */ \"b\"])('wvsQueryParameters', serverOptions['customQueryParameters']);\n        }\n        if (!serverRoot.endsWith('blackbox/')) {\n            serverRoot += 'blackbox/';\n        }\n        this.uploadData = serverOptions['uploadData'] || null;\n        this.uriData = serverOptions['uriData'] || null;\n        this.cacheKey = serverOptions['cacheKey'] || null;\n        this.officeOptions = serverOptions['officeOptions'] || null;\n        if (this.officeOptions) {\n            this.officeOptions = replaceOfficeKeys(this.officeOptions);\n        }\n        this.rasterizerOptions = serverOptions['rasterizerOptions'] || null;\n        this.cadOptions = serverOptions['cadOptions'] || null;\n        this.serverRoot = serverRoot;\n        this.docUri = doc;\n        this.setWithCredentials(true);\n        var connectionFactory = new _WebViewerServer_WebViewerServerConnectionService__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"](serverRoot, null, this.getWithCredentials());\n        this.connector = connectionFactory.generateConnection(!this.disableWebsockets, function (result) {\n            _this.onServerMessage(result);\n        }, function () { return null; }, function () {\n            _this.connectionStarted = false;\n        }, function () {\n            _this.resetRetriever();\n        });\n    }\n    WebViewerServerPartRetriever.prototype.deleteSyncCookie = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var xmlHttp = new XMLHttpRequest();\n            var url = _this.serverRoot + \"ck\";\n            xmlHttp.open('GET', url);\n            xmlHttp.withCredentials = _this.getWithCredentials();\n            xmlHttp.onreadystatechange = function () {\n                if (xmlHttp.readyState === XMLHttpRequest.DONE) {\n                    if (xmlHttp.status === 200) {\n                        resolve();\n                    }\n                    else {\n                        reject();\n                    }\n                }\n            };\n            xmlHttp.send();\n        });\n    };\n    WebViewerServerPartRetriever.prototype.setLinkReplacementCallbacks = function (healthSwitchCallback, linkFinderFunc) {\n        this.healthSwitchCallback = healthSwitchCallback || nullFunc;\n        this.linkFinderFunc = linkFinderFunc || nullFunc;\n    };\n    WebViewerServerPartRetriever.prototype.closeConnection = function () {\n        this.resetState();\n        return this.connector.endConnection(true);\n    };\n    WebViewerServerPartRetriever.prototype.resetState = function () {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.configPromise = new BBPromise();\n                        this.pageSizesPromise = new BBPromise();\n                        this.connectionStarted = false;\n                        this.id = null;\n                        this.deadServer = false;\n                        return [4 /*yield*/, this.deleteSyncCookie()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WebViewerServerPartRetriever.prototype.resetRetriever = function () {\n        this.healthSwitchCallback();\n        this.resetState();\n        if (this.pdfURLPromise) {\n            if (this.pdfURLPromise.isPending()) {\n                this.sendRequest(this.pdfURLPromise.request);\n            }\n            else if (this.pdfURLPromise.isResolved() && this.linkFinderFunc(this.pdfURLPromise.result['url'], 'pdf')) {\n                this.pdfURLPromise = null;\n                this.requestPDF();\n            }\n        }\n        if (this.annotPromise) {\n            if (this.annotPromise.isPending()) {\n                this.sendRequest(this.annotPromise.request);\n            }\n        }\n        if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n            this.sendRequest(this.xodURLPromise.request);\n        }\n        else if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n            this.getXODIfExists(this.xodExistPromise.request);\n        }\n        var i;\n        for (i = 0; i < this.pageImages.length; i++) {\n            if (this.pageImages[i]) {\n                if (this.pageImages[i].isPending()) {\n                    this.sendRequest(this.pageImages[i].request);\n                }\n                else if (this.pageImages[i].isResolved() && this.linkFinderFunc(this.pageImages[i].result['url'], 'image')) {\n                    this.pageImages[i] = null;\n                    this.requestPageImage(Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"uniqueId\"])(), i);\n                }\n            }\n        }\n        for (i = 0; i < this.pageText.length; i++) {\n            if (this.pageText[i]) {\n                if (this.pageText[i].isPending() && !this.pageText[i].isDownloading()) {\n                    this.sendRequest(this.pageText[i].request);\n                }\n            }\n        }\n        for (i = 0; i < this.tileRequests.length; i++) {\n            if (this.tileRequests[i]) {\n                if (this.tileRequests[i].isPending()) {\n                    this.sendRequest(this.tileRequests[i].request);\n                }\n            }\n        }\n    };\n    WebViewerServerPartRetriever.prototype.initConnection = function () {\n        if (!this.connectionStarted) {\n            this.connectionStarted = true;\n            this.timeStamp = Date.now();\n            return this.connector.initiateConnection();\n        }\n        return Promise.resolve();\n    };\n    WebViewerServerPartRetriever.prototype.uploadDocument = function () {\n        var _this = this;\n        var data;\n        var loadCallback;\n        var ext;\n        var type;\n        var contentType;\n        return new Promise(function (resolve, reject) {\n            if (_this.uploadData) {\n                data = new FormData();\n                data.append('file', _this.uploadData['fileHandle'], _this.uploadData['fileHandle']['name']);\n                if (_this.officeOptions) {\n                    data.append('officeOptions', JSON.stringify(_this.officeOptions));\n                }\n                if (_this.rasterizerOptions) {\n                    data.append('rasterizerOptions', JSON.stringify(_this.rasterizerOptions));\n                }\n                if (_this.cadOptions) {\n                    data.append('cadOptions', _this.cadOptions['getJsonString']());\n                }\n                if (_this.cacheKey) {\n                    data.append('cacheKey', _this.cacheKey);\n                }\n                loadCallback = _this.uploadData['loadCallback'];\n                type = 'upload';\n                ext = _this.uploadData['extension'];\n            }\n            else if (_this.uriData) {\n                data = {\n                    uri: _this.uriData['uri'],\n                    shareId: _this.uriData['shareId'],\n                };\n                data = Object.keys(data).map(function (key) { return key + \"=\" + (data[key] ? encodeURIComponent(data[key]) : ''); }).join('&');\n                contentType = 'application/x-www-form-urlencoded; charset=UTF-8';\n                loadCallback = _this.uriData['loadCallback'];\n                type = 'url';\n                ext = _this.uriData['extension'];\n            }\n            else {\n                // nothing to upload\n                resolve();\n                return;\n            }\n            var xmlHttp = new XMLHttpRequest();\n            var url = Object(_util_Utils__WEBPACK_IMPORTED_MODULE_4__[/* joinPaths */ \"k\"])(_this.serverRoot, 'AuxUpload');\n            url = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(url, { 'type': type, 'ext': ext });\n            xmlHttp.open('POST', url);\n            xmlHttp.withCredentials = _this.getWithCredentials();\n            if (contentType) {\n                xmlHttp.setRequestHeader('Content-Type', contentType);\n            }\n            xmlHttp.addEventListener('load', function () {\n                if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n                    var data_1 = JSON.parse(xmlHttp.response);\n                    _this.docUri = data_1.uri;\n                    loadCallback(data_1);\n                    resolve(data_1);\n                }\n            });\n            xmlHttp.addEventListener('error', function () {\n                reject(xmlHttp.statusText + \" \" + JSON.stringify(xmlHttp));\n            });\n            if (_this.uploadData && _this.uploadData['onProgress'] != null) {\n                xmlHttp.upload.onprogress = function (evt) {\n                    _this.uploadData['onProgress'](evt);\n                };\n            }\n            xmlHttp.send(data);\n        });\n    };\n    WebViewerServerPartRetriever.prototype.requestDocumentWithPass = function (password) {\n        this.password = password || null;\n        if (!this.pageSizesPromise.isResolved()) {\n            this.pageSizesPromise = new BBPromise();\n            this.sendRequest({ 't': 'pages' });\n        }\n        return this.pageSizesPromise.promise;\n    };\n    /**\n     * Requests the information necessary to initialize the Document.\n     * @method WebViewerServerPartRetriever#requestDocument\n     */\n    WebViewerServerPartRetriever.prototype.requestDocument = function (fileExtension) {\n        this.fileExtension = fileExtension || null;\n        if (!this.pageSizesPromise.isResolved()) {\n            this.sendRequest({ 't': 'pages' });\n        }\n        return this.pageSizesPromise.promise;\n    };\n    WebViewerServerPartRetriever.prototype.completRequestObject = function (requestObj) {\n        var toSend = Object.assign(requestObj, { 'uri': encodeURIComponent(this.docUri) });\n        if (this.fileExtension) {\n            toSend['ext'] = this.fileExtension;\n        }\n        if (this.requestOptions) {\n            toSend['c'] = this.requestOptions;\n        }\n        if (this.password) {\n            toSend['pswd'] = this.password;\n        }\n        if (this.cacheKey) {\n            toSend['cacheKey'] = this.cacheKey;\n        }\n        if (this.officeOptions) {\n            toSend['officeOptions'] = this.officeOptions;\n        }\n        if (this.rasterizerOptions) {\n            toSend['rastOptions'] = this.rasterizerOptions;\n        }\n        if (this.cadOptions) {\n            // getting the JSON string causes this to get escaped twice\n            toSend['cadOptions'] = this.cadOptions['mImpl'];\n        }\n        return toSend;\n    };\n    // acts as a buffer so webviewer does not spam the server with requests\n    // currently only applies to page image/tile requests\n    WebViewerServerPartRetriever.prototype.sendRequestFromQueueIfPossible = function () {\n        if (this.requestQueue.length() > 0 && this.activeImageRequests <= MAX_ACTIVE_IMAGE_REQUESTS) {\n            this.sendRequestFromQueueToActive(this.requestQueue.pop().data);\n        }\n    };\n    WebViewerServerPartRetriever.prototype.cancelQueuedRequest = function (id) {\n        if (this.requestQueue.length() > 0 && this.requestQueue.contains(id)) {\n            this.requestQueue.remove(id);\n            return true;\n        }\n        return false;\n    };\n    WebViewerServerPartRetriever.prototype.sendRequest = function (args) {\n        var toSend = this.completRequestObject(args);\n        this.connector.send(toSend);\n    };\n    // Using this function will send the request limited by a queue.\n    // This will allow the requests to be cancelable.\n    //\n    // Currently this is only for use with page image/tile requests. cancelQueuedRequest\n    // is what can be called to cancel requests sent to this queue.\n    WebViewerServerPartRetriever.prototype.sendOrQueueRequest = function (id, args) {\n        if (this.activeImageRequests > MAX_ACTIVE_IMAGE_REQUESTS) {\n            this.requestQueue.push(id, args);\n        }\n        else {\n            this.activeImageRequests++;\n            var toSend = this.completRequestObject(args);\n            this.connector.send(toSend);\n        }\n    };\n    // Call to migrate a queued request to an actual request\n    WebViewerServerPartRetriever.prototype.sendRequestFromQueueToActive = function (requestData) {\n        this.activeImageRequests++;\n        var toSend = this.completRequestObject(requestData);\n        this.connector.send(toSend);\n    };\n    WebViewerServerPartRetriever.prototype.constructPart = function (part) {\n        return part;\n    };\n    WebViewerServerPartRetriever.prototype.healthHandler = function (healthStatus) {\n        if (this.singleServerMode && healthStatus) {\n            Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* warn */ \"j\"])('Server failed health check. Single server mode ignoring check.');\n        }\n        else if (!this.disableIEFallback && healthStatus && this.retryCount <= 3) {\n            this.hasBadHealthState = true;\n            this.connector.endConnection();\n        }\n        else if (this.retryCount > 3) {\n            // instead of spinning our wheels when no healthy server can be found,\n            // ignore future health issues and just bind to a server\n            this.singleServerMode = true;\n        }\n    };\n    WebViewerServerPartRetriever.prototype.onServerMessage = function (data) {\n        var _this = this;\n        var resultObj;\n        var resultPromise;\n        var innerData = data['data'];\n        var error = data['err'];\n        var opType = data['t'];\n        switch (opType) {\n            case 'upload':\n                if (error) {\n                    this.uploadPromise.reject(error);\n                }\n                else {\n                    this.uploadPromise.resolve('Success');\n                }\n                break;\n            case 'pages':\n                if (error) {\n                    this.pageSizesPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, this.pageSizesPromise)) {\n                    this.pageSizesPromise.resolve(innerData);\n                }\n                break;\n            case 'config':\n                if (error) {\n                    this.configPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, this.configPromise)) {\n                    this.healthHandler(innerData['unhealthy']);\n                    if (innerData['id']) {\n                        this.id = innerData['id'];\n                    }\n                    if (innerData['auth']) {\n                        var params = Object(_state_globalState__WEBPACK_IMPORTED_MODULE_8__[/* getState */ \"a\"])('wvsQueryParameters');\n                        params['auth'] = innerData['auth'];\n                        Object(_state_globalState__WEBPACK_IMPORTED_MODULE_8__[/* setState */ \"b\"])('wvsQueryParameters', params);\n                    }\n                    if (innerData['serverVersion']) {\n                        this.wvsVersion = innerData['serverVersion'];\n                        Object(logger__WEBPACK_IMPORTED_MODULE_2__[/* log */ \"h\"])(\"[WebViewer Server] server version: \" + this.wvsVersion);\n                    }\n                    if (innerData['serverID']) {\n                        if (innerData['serverID'] === this.serverID && this.hasBadHealthState) {\n                            this.retryCount += 1;\n                        }\n                        else {\n                            this.retryCount = 0;\n                        }\n                        this.serverID = innerData['serverID'];\n                    }\n                    else {\n                        this.retryCount = 0;\n                    }\n                    this.hasBadHealthState = false;\n                    this.configPromise.resolve(innerData);\n                }\n                break;\n            case 'health':\n                if (error) {\n                    this.configPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, this.configPromise)) {\n                    this.healthHandler(innerData['unhealthy']);\n                }\n                break;\n            case 'pdf':\n                innerData['url'] = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(innerData['url']));\n                if (error) {\n                    this.pdfURLPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, this.pdfURLPromise)) {\n                    this.pdfURLPromise.resolve(innerData);\n                }\n                break;\n            case 'ApString2Xod':\n                innerData['url'] = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../data/\" + encodeURI(innerData['url']));\n                if (error) {\n                    this.linkRequests[innerData['rID']].reject(error);\n                }\n                else if (validateObject(innerData, opType, this.linkRequests[innerData['rID']])) {\n                    this.linkRequests[innerData['rID']].resolve(innerData);\n                }\n                break;\n            case 'docmod':\n                innerData['url'] = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(innerData['url']));\n                if (error) {\n                    this.linkRequests[innerData['rID']].reject(error);\n                }\n                else if (validateObject(innerData, opType, this.pdfURLPromise)) {\n                    this.linkRequests[innerData['rID']].resolve(innerData);\n                }\n                break;\n            case 'xod':\n                if (error) {\n                    if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n                        this.xodURLPromise.reject(error);\n                    }\n                    if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n                        this.xodExistPromise.reject(error);\n                    }\n                }\n                else if (innerData['notFound']) {\n                    // if we tried to create this, then\n                    if (!innerData['noCreate']) {\n                        if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n                            this.xodURLPromise.resolve(innerData);\n                        }\n                    }\n                    if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n                        this.xodExistPromise.resolve(innerData);\n                    }\n                }\n                else {\n                    if (innerData['url']) {\n                        innerData['url'] = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(innerData['url']));\n                    }\n                    if (!this.xodExistPromise || this.xodExistPromise.isResolved()) {\n                        this.xodExistPromise = new BBPromise();\n                        this.xodExistPromise.request = { 't': 'xod', 'noCreate': true };\n                    }\n                    if (!this.xodURLPromise) {\n                        this.xodURLPromise = new BBPromise();\n                        this.xodURLPromise.request = { 't': 'xod' };\n                    }\n                    this.xodExistPromise.resolve(innerData);\n                    this.xodURLPromise.resolve(innerData);\n                }\n                break;\n            case 'cAnnots':\n                resultPromise = this.annotPromise;\n                if (error) {\n                    resultPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, resultPromise)) {\n                    resultPromise.setDownloading();\n                    var annotChunkPromises = [];\n                    var annots = innerData['annots'];\n                    var _loop_1 = function (i) {\n                        var xfdfStart = annots[i]['s'];\n                        var xfdfEnd = annots[i]['e'];\n                        var annotURL = this_1.serverRoot + \"../\" + encodeURI(annots[i]['xfdf']);\n                        var appearanceURL = annots[i]['hasAppearance'] === 'true' ? Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(annotURL + \".xodapp\") : null;\n                        var xfdfRange = Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"range\"])(xfdfStart, xfdfEnd + 1);\n                        annotChunkPromises[i] = {\n                            range: xfdfRange,\n                            promise: new Promise(function (resolve, reject) {\n                                var xmlHttp = new XMLHttpRequest();\n                                xmlHttp.open('GET', Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(annotURL));\n                                xmlHttp.responseType = 'text';\n                                xmlHttp.withCredentials = _this.getWithCredentials();\n                                xmlHttp.addEventListener('load', function () {\n                                    if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n                                        resolve({ xfdfString: xmlHttp.response, appearanceDocURL: appearanceURL, range: xfdfRange });\n                                    }\n                                });\n                                xmlHttp.addEventListener('error', function () {\n                                    reject(xmlHttp.statusText + \" \" + JSON.stringify(xmlHttp));\n                                });\n                                xmlHttp.send();\n                            })\n                        };\n                    };\n                    var this_1 = this;\n                    for (var i = 0; i < annots.length; i++) {\n                        _loop_1(i);\n                    }\n                    resultPromise.resolve(annotChunkPromises);\n                }\n                break;\n            case 'annots':\n                if (error) {\n                    this.annotPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, this.annotPromise)) {\n                    this.annotPromise.setDownloading();\n                    var xmlHttp_1 = new XMLHttpRequest();\n                    var annotURL = this.serverRoot + \"../\" + encodeURI(innerData['url']);\n                    var appearanceURL_1 = innerData['hasAppearance'] ? Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(annotURL + \".xodapp\") : null;\n                    xmlHttp_1.open('GET', Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(annotURL));\n                    xmlHttp_1.responseType = 'text';\n                    xmlHttp_1.withCredentials = this.getWithCredentials();\n                    xmlHttp_1.addEventListener('load', function () {\n                        if (xmlHttp_1.readyState === xmlHttp_1.DONE && xmlHttp_1.status === 200) {\n                            _this.annotPromise.resolve({ xfdfString: xmlHttp_1.response, appearanceDocURL: appearanceURL_1 });\n                        }\n                    });\n                    xmlHttp_1.addEventListener('error', function () {\n                        _this.annotPromise.reject(xmlHttp_1.statusText + \" \" + JSON.stringify(xmlHttp_1));\n                    });\n                    xmlHttp_1.send();\n                }\n                break;\n            case 'image':\n                this.activeImageRequests--;\n                resultObj = this.pageImages[innerData['p']];\n                if (error) {\n                    resultObj.promise.reject(error);\n                }\n                else if (validateObject(innerData, opType, resultObj)) {\n                    // console.log('Page: ' + innerData['p'] + ' ' + data['data']['name']);\n                    resultObj.result = innerData;\n                    resultObj.result.url = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(resultObj.result.url));\n                    resultObj.resolve(resultObj.result);\n                }\n                break;\n            case 'tiles':\n                this.activeImageRequests--;\n                resultObj = innerData['rID'];\n                resultPromise = this.tileRequests[resultObj];\n                this.tileRequests[resultObj] = null;\n                this.freeTileRequests.push(resultObj);\n                if (error) {\n                    resultPromise.reject(error);\n                }\n                else if (validateObject(innerData, opType, resultPromise)) {\n                    for (var i = 0; i < innerData['tiles'].length; i++) {\n                        innerData['tiles'][i] = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(innerData['tiles'][i]));\n                    }\n                    resultPromise.resolve(innerData);\n                }\n                break;\n            case 'text':\n                resultObj = this.pageText[innerData['p']];\n                if (error) {\n                    resultObj.reject(error);\n                }\n                else if (validateObject(innerData, opType, resultObj)) {\n                    resultObj.setDownloading();\n                    var xmlHttp_2 = new XMLHttpRequest();\n                    var turl = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"../\" + encodeURI(innerData['url']));\n                    xmlHttp_2.open('GET', turl);\n                    xmlHttp_2.withCredentials = this.getWithCredentials();\n                    xmlHttp_2.addEventListener('load', function () {\n                        if (xmlHttp_2.readyState === xmlHttp_2.DONE && xmlHttp_2.status === 200) {\n                            resultObj.result = JSON.parse(xmlHttp_2.response);\n                            resultObj.resolve(resultObj.result);\n                        }\n                    });\n                    xmlHttp_2.addEventListener('error', function (e) {\n                        resultObj.reject(xmlHttp_2.statusText + \" \" + JSON.stringify(e));\n                    });\n                    xmlHttp_2.send();\n                }\n                break;\n            case 'progress':\n                if (innerData['t'] === 'loading') {\n                    this.trigger(_PartRetriever__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"]['Events']['DOCUMENT_LOADING_PROGRESS'], [innerData['bytes'], innerData['total']]);\n                }\n                break;\n        }\n        // since a result came in, there may be room on request queue\n        this.sendRequestFromQueueIfPossible();\n        if (!opType && data['echo'] && data) {\n            if (data['echo']['t'] === 'apstring2xod') {\n                var reqID = data['echo']['reqID'];\n                if (reqID) {\n                    var version = parseInt(this.wvsVersion, 10);\n                    if (version >= 2) {\n                        this.linkRequests[reqID].reject('Message unhandled by server');\n                    }\n                    else {\n                        this.linkRequests[reqID].reject();\n                    }\n                    // else, that's expected\n                }\n            }\n        }\n    };\n    WebViewerServerPartRetriever.prototype.getConfig = function () {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.initConnection()];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, this.configPromise.promise];\n                }\n            });\n        });\n    };\n    WebViewerServerPartRetriever.prototype.getAppearanceStringRequest = function (input) {\n        var _this = this;\n        var xmlHttp = new XMLHttpRequest();\n        var url = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"aul\", { 'id': this.id });\n        var formData = new FormData();\n        var parts = {};\n        // for (const appearanceString of input.body) {   => does not work for some reason in minified build\n        for (var i = 0; i < input.body.length; i++) {\n            var appearanceString = input.body[i];\n            parts[appearanceString.id] = appearanceString.appearanceString['w'] + \";\" + appearanceString.appearanceString['h'];\n            formData.append(appearanceString.id, appearanceString.appearanceString['dataString']);\n        }\n        var toSendOrig = {\n            't': 'apstring2xod',\n            'reqID': this.nextRequestID++,\n            'parts': parts,\n        };\n        var toSend = this.completRequestObject(toSendOrig);\n        formData.append('msg', JSON.stringify(toSend));\n        this.linkRequests[toSend['reqID']] = new BBPromise();\n        xmlHttp.open('POST', url);\n        xmlHttp.withCredentials = this.getWithCredentials;\n        var promiseStatus = new Promise(function (resolve, reject) {\n            xmlHttp.onreadystatechange = function () {\n                // request is done. now check if request was success or error\n                if (xmlHttp.readyState === 4) {\n                    if (xmlHttp.status === 200) {\n                        resolve();\n                    }\n                    else {\n                        reject('An error occurred while sending down appearance strings to the server');\n                    }\n                }\n            };\n        });\n        xmlHttp.send(formData);\n        return promiseStatus\n            .then(function () {\n            return _this.linkRequests[toSend['reqID']].promise;\n        });\n    };\n    // Assumes x.x.x version number for wvs and provided version\n    // Returns 0 if value equals this.wvsVersion, -1 if it is less than and 1 if it is greater than\n    WebViewerServerPartRetriever.prototype.compareToWVSVersion = function (version) {\n        var cleanVersion = this.wvsVersion.split('-')[0];\n        var wvsVersionValues = cleanVersion.split('.');\n        var providedVersionValues = version.split('.');\n        if (wvsVersionValues.length !== VERSION_LENGTH) {\n            throw Error('Invalid WVS version length.');\n        }\n        if (providedVersionValues.length !== VERSION_LENGTH) {\n            throw Error('Invalid version length.');\n        }\n        for (var i = 0; i < wvsVersionValues.length; ++i) {\n            if (providedVersionValues.length === i) {\n                return -1;\n            }\n            if (wvsVersionValues[i] > providedVersionValues[i]) {\n                return -1;\n            }\n            if (wvsVersionValues[i] === providedVersionValues[i]) {\n                continue;\n            }\n            else {\n                return 1;\n            }\n        }\n        return 0;\n    };\n    WebViewerServerPartRetriever.prototype.chunkedAnnotationsAvailable = function () {\n        return this.compareToWVSVersion('1.5.9') <= 0;\n    };\n    WebViewerServerPartRetriever.prototype.getAnnots = function () {\n        if (!this.annotPromise) {\n            this.annotPromise = new BBPromise();\n            if (this.chunkedAnnotationsAvailable()) {\n                this.annotPromise.request = { 't': 'cAnnots' };\n            }\n            else {\n                this.annotPromise.request = { 't': 'annots' };\n            }\n            this.sendRequest(this.annotPromise.request);\n        }\n        return this.annotPromise.promise;\n    };\n    WebViewerServerPartRetriever.prototype.requestPageImage = function (id, pageIndex) {\n        if (!this.pageImages[pageIndex]) {\n            this.pageImages[pageIndex] = new BBPromise();\n            this.pageImages[pageIndex].request = { 't': 'image', 'p': pageIndex };\n            this.sendOrQueueRequest(id, this.pageImages[pageIndex].request);\n        }\n        return this.pageImages[pageIndex].promise;\n    };\n    WebViewerServerPartRetriever.prototype.requestPageText = function (pageIndex) {\n        if (!this.pageText[pageIndex]) {\n            this.pageText[pageIndex] = new BBPromise();\n            this.pageText[pageIndex].request = { 't': 'text', 'p': pageIndex };\n            this.sendRequest(this.pageText[pageIndex].request);\n        }\n        return this.pageText[pageIndex].promise;\n    };\n    WebViewerServerPartRetriever.prototype.requestTiles = function (id, pageIndex, zoom, viewportRect, tileSize) {\n        var requestIndex = this.tileRequests.length;\n        if (this.freeTileRequests.length) {\n            requestIndex = this.freeTileRequests.pop();\n        }\n        this.tileRequests[requestIndex] = new BBPromise();\n        this.tileRequests[requestIndex].request = {\n            't': 'tiles', 'p': pageIndex, 'z': zoom, 'r': viewportRect, 'size': tileSize, 'rID': requestIndex,\n        };\n        this.sendOrQueueRequest(id, this.tileRequests[requestIndex].request);\n        return this.tileRequests[requestIndex].promise;\n    };\n    WebViewerServerPartRetriever.prototype.requestPDF = function () {\n        if (!this.pdfURLPromise) {\n            this.pdfURLPromise = new BBPromise();\n            this.pdfURLPromise.request = { 't': 'pdf' };\n            if (this.deadServer) {\n                this.pdfURLPromise.resolve({ 'url': this.docUri });\n            }\n            else {\n                this.sendRequest(this.pdfURLPromise.request);\n            }\n        }\n        return this.pdfURLPromise.promise;\n    };\n    WebViewerServerPartRetriever.prototype.getModifiedDoc = function (options) {\n        var _this = this;\n        var xmlHttp = new XMLHttpRequest();\n        var url = Object(_utils__WEBPACK_IMPORTED_MODULE_9__[/* appendQueryParameters */ \"a\"])(this.serverRoot + \"aul\", { 'id': this.id });\n        var formData = new FormData();\n        var parts = {};\n        if (options['annots']) {\n            parts['annots'] = 'xfdf';\n        }\n        if (options['watermark']) {\n            parts['watermark'] = 'png';\n        }\n        if (options['redactions']) {\n            parts['redactions'] = 'redact';\n        }\n        var toSendOrig = {\n            't': 'docmod',\n            'reqID': this.nextRequestID++,\n            'parts': parts,\n        };\n        if (options['print']) {\n            toSendOrig['print'] = true;\n        }\n        var toSend = this.completRequestObject(toSendOrig);\n        formData.append('msg', JSON.stringify(toSend));\n        return Promise.all([options['annots'], options['watermark'], options['redactions']].map(function (option) {\n            // promisify every option\n            return Promise.resolve(option);\n        })).then(function (options) {\n            var annots = options[0];\n            var watermark = options[1];\n            var redactions = options[2];\n            if (annots) {\n                formData.append('annots', annots);\n            }\n            if (watermark) {\n                formData.append('watermark', watermark);\n            }\n            if (redactions) {\n                formData.append('redactions', redactions);\n            }\n            _this.linkRequests[toSend['reqID']] = new BBPromise();\n            xmlHttp.open('POST', url);\n            xmlHttp.withCredentials = _this.getWithCredentials;\n            var promiseStatus = new Promise(function (resolve, reject) {\n                xmlHttp.onreadystatechange = function () {\n                    // request is done. now check if request was success or error\n                    if (xmlHttp.readyState === 4) {\n                        if (xmlHttp.status === 200) {\n                            resolve();\n                        }\n                        else {\n                            reject('An error occurred while sending down annotation data to the server');\n                        }\n                    }\n                };\n            });\n            xmlHttp.send(formData);\n            return promiseStatus\n                .then(function () {\n                return _this.linkRequests[toSend['reqID']].promise;\n            });\n        });\n    };\n    WebViewerServerPartRetriever.prototype.getXODIfExists = function () {\n        if (!this.xodExistPromise) {\n            this.xodExistPromise = new BBPromise();\n            this.xodExistPromise.request = { 't': 'xod', 'noCreate': true };\n            this.sendRequest(this.xodExistPromise.request);\n        }\n        return this.xodExistPromise.promise;\n    };\n    WebViewerServerPartRetriever.prototype.requestXOD = function () {\n        if (!this.xodURLPromise) {\n            this.xodURLPromise = new BBPromise();\n            this.xodURLPromise.request = { 't': 'xod' };\n            this.sendRequest(this.xodURLPromise.request);\n        }\n        return this.xodURLPromise.promise;\n    };\n    WebViewerServerPartRetriever.prototype.requiresCache = function () {\n        return true;\n    };\n    // eslint-disable-next-line no-unused-vars\n    WebViewerServerPartRetriever.prototype.request = function (parts, customData) {\n        // No-op since we just emit parts as they come in\n    };\n    // eslint-disable-next-line no-unused-vars\n    WebViewerServerPartRetriever.prototype.receivedHeader = function (header) {\n        // console.log('Received a zip local header for file (%d bytes uncompressed)', header.uSize);\n    };\n    WebViewerServerPartRetriever.prototype.abort = function () {\n        for (var i = 0; i < this.tileRequests.length; i++) {\n            if (this.tileRequests[i]) {\n                this.tileRequests[i].resolve(null);\n                this.tileRequests[i] = null;\n                this.freeTileRequests.push(i);\n            }\n        }\n        this.close();\n    };\n    WebViewerServerPartRetriever.prototype.setCustomHeaders = function (headers) {\n        this.requestOptions = this.requestOptions || {};\n        this.requestOptions['headers'] = headers;\n    };\n    WebViewerServerPartRetriever.prototype.getCustomHeaders = function () {\n        return this.requestOptions ? Object(lodash__WEBPACK_IMPORTED_MODULE_1__[\"omit\"])(this.requestOptions['headers'], ['Cookie', 'cookie']) : null;\n    };\n    WebViewerServerPartRetriever.prototype.setWithCredentials = function (withCredentials) {\n        this.requestOptions = this.requestOptions || {};\n        this.requestOptions['internal'] = this.requestOptions['internal'] || {};\n        this.requestOptions['internal']['withCredentials'] = withCredentials;\n    };\n    WebViewerServerPartRetriever.prototype.getWithCredentials = function () {\n        return (this.requestOptions && this.requestOptions['internal'] ? this.requestOptions['internal']['withCredentials'] : null);\n    };\n    WebViewerServerPartRetriever.prototype.getFileData = function () {\n        return Promise.reject();\n    };\n    return WebViewerServerPartRetriever;\n}());\nObject(_util_events_EventHandler__WEBPACK_IMPORTED_MODULE_3__[/* useEventHandler */ \"a\"])(WebViewerServerPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_7__[/* exportEventHandler */ \"a\"])(WebViewerServerPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_7__[/* exportPartRetrieverFunctions */ \"b\"])(WebViewerServerPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (WebViewerServerPartRetriever);\n\n\n/***/ }),\n\n/***/ 547:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);\n/* harmony import */ var _state_globalState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);\n/* harmony import */ var _PartRetrievers_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(195);\n/* harmony import */ var _util_constants_errorMessages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(86);\n\n\n\n\n\n\nvar MAX_RETRY_COUNT = 8;\nvar MANUAL_DISCONNECTION = 3000;\nvar WebsocketConnection = /** @class */ (function () {\n    function WebsocketConnection(constructorBaseURL, target, dataCallback, openCallback, closeCallback, resetCallback) {\n        if (dataCallback === void 0) { dataCallback = null; }\n        if (openCallback === void 0) { openCallback = null; }\n        if (closeCallback === void 0) { closeCallback = null; }\n        if (resetCallback === void 0) { resetCallback = null; }\n        this.mHasError = false;\n        this.retryCount = 0;\n        this.baseURL = this.wsBaseURL(constructorBaseURL);\n        this.url = target ? this.baseURL + \"/\" + target : this.baseURL + \"/ws\";\n        this.dataCallback = dataCallback;\n        this.openCallback = openCallback;\n        this.closeCallback = closeCallback;\n        this.resetCallback = resetCallback;\n    }\n    WebsocketConnection.prototype.wsBaseURL = function (inBaseURL) {\n        var start = inBaseURL.indexOf('://');\n        var protocol = 'ws://';\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            if (start === 5) {\n                protocol = 'wss://';\n            }\n            start += 3;\n        }\n        var end = inBaseURL.lastIndexOf('/');\n        if (end < 0) {\n            end = inBaseURL.length;\n        }\n        return protocol + inBaseURL.slice(start, end);\n    };\n    WebsocketConnection.prototype.send = function (jsObject) {\n        if (this.ws.readyState !== WebSocket.CLOSED && !this.mHasError) {\n            this.ws.send(JSON.stringify(jsObject));\n        }\n    };\n    WebsocketConnection.prototype.initiateConnection = function () {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            var queryParameters;\n            var _this = this;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                queryParameters = Object(_state_globalState__WEBPACK_IMPORTED_MODULE_3__[/* getState */ \"a\"])('wvsQueryParameters');\n                queryParameters['bcid'] = Object(_util_Utils__WEBPACK_IMPORTED_MODULE_2__[/* makeId */ \"l\"])(8);\n                Object(_state_globalState__WEBPACK_IMPORTED_MODULE_3__[/* setState */ \"b\"])('wvsQueryParameters', queryParameters);\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var urlWithParams = Object(_PartRetrievers_utils__WEBPACK_IMPORTED_MODULE_4__[/* appendQueryParameters */ \"a\"])(_this.url);\n                        _this.ws = new WebSocket(urlWithParams);\n                        _this.ws.onopen = function () {\n                            if (_this.openCallback) {\n                                _this.openCallback();\n                            }\n                            resolve();\n                        };\n                        _this.ws.onerror = function (err) {\n                            _this.mHasError = true;\n                            reject(err);\n                        };\n                        _this.ws.onclose = function (_a) {\n                            var code = _a.code;\n                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(_this, void 0, void 0, function () {\n                                var _this = this;\n                                return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_b) {\n                                    switch (_b.label) {\n                                        case 0:\n                                            if (this.closeCallback) {\n                                                this.closeCallback();\n                                            }\n                                            if (!(code !== MANUAL_DISCONNECTION)) return [3 /*break*/, 3];\n                                            if (!(this.retryCount++ < MAX_RETRY_COUNT)) return [3 /*break*/, 2];\n                                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(_this, void 0, void 0, function () {\n                                                    return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                                                        switch (_a.label) {\n                                                            case 0:\n                                                                this.resetCallback();\n                                                                return [4 /*yield*/, this.initiateConnection()];\n                                                            case 1:\n                                                                _a.sent();\n                                                                resolve();\n                                                                return [2 /*return*/];\n                                                        }\n                                                    });\n                                                }); }, 3000); })];\n                                        case 1:\n                                            _b.sent();\n                                            return [3 /*break*/, 3];\n                                        case 2:\n                                            reject(_util_constants_errorMessages__WEBPACK_IMPORTED_MODULE_5__[/* WVSConnectionException */ \"a\"]);\n                                            _b.label = 3;\n                                        case 3: return [2 /*return*/];\n                                    }\n                                });\n                            });\n                        };\n                        _this.ws.onmessage = function (message) {\n                            if (message && message.data) {\n                                var json = JSON.parse(message.data);\n                                if (json['hb']) {\n                                    _this.send({ 'hb': true });\n                                }\n                                else if (json['end']) {\n                                    close();\n                                }\n                                else {\n                                    _this.dataCallback(json);\n                                }\n                            }\n                        };\n                    })];\n            });\n        });\n    };\n    // noReconnect prevents automatic reconnect on close\n    WebsocketConnection.prototype.endConnection = function (noReconnect) {\n        if (noReconnect === void 0) { noReconnect = false; }\n        this.retryCount = 0;\n        if (noReconnect) {\n            this.ws.close(MANUAL_DISCONNECTION);\n        }\n        else {\n            this.ws.close();\n        }\n        return Promise.resolve();\n    };\n    return WebsocketConnection;\n}());\nvar HttpConnection = /** @class */ (function () {\n    function HttpConnection(constructorBaseURL, target, useCredentials, dataCallback, openCallback, closeCallback, resetCallback) {\n        if (dataCallback === void 0) { dataCallback = null; }\n        if (openCallback === void 0) { openCallback = null; }\n        if (closeCallback === void 0) { closeCallback = null; }\n        if (resetCallback === void 0) { resetCallback = null; }\n        this.id = 0;\n        this.reqCounter = 0;\n        this.retryCount = 0;\n        this.hasCloseSignal = false;\n        this.request = null;\n        var baseURL = this.processBaseURL(constructorBaseURL);\n        this.url = target ? (baseURL + \"/\" + target + \"pf\") : (baseURL + \"/pf\");\n        this.useCredentials = useCredentials;\n        this.dataCallback = dataCallback;\n        this.openCallback = openCallback;\n        this.closeCallback = closeCallback;\n        this.resetCallback = resetCallback;\n    }\n    HttpConnection.prototype.processBaseURL = function (inBaseURL) {\n        var end = inBaseURL.lastIndexOf('/');\n        if (end < 0) {\n            end = inBaseURL.length;\n        }\n        return inBaseURL.slice(0, end);\n    };\n    HttpConnection.prototype.dataToJsonChunks = function (inputJson) {\n        var splitStrings = inputJson.split('\\n');\n        var last = splitStrings[splitStrings.length - 1];\n        if (last) {\n            splitStrings.pop();\n        }\n        // get rid of the trailing ]\n        while (splitStrings.length > 0 && splitStrings[splitStrings.length - 1].length < 3) {\n            if (splitStrings.pop() === ']') {\n                this.id = 0;\n            }\n        }\n        // or the leading [\n        if (splitStrings.length > 0 && splitStrings[0].length < 3) {\n            splitStrings.shift();\n        }\n        for (var i = 0; i < splitStrings.length; ++i) {\n            if (splitStrings[i].endsWith(',')) {\n                splitStrings[i] = splitStrings[i].substr(0, splitStrings[i].length - 1);\n            }\n        }\n        return splitStrings;\n    };\n    HttpConnection.prototype.retryConnection = function () {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            var _this = this;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(this.retryCount++ < MAX_RETRY_COUNT)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(function () {\n                                _this.resetCallback();\n                                _this.initiateConnection();\n                                resolve();\n                            }, 3000); })];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    HttpConnection.prototype.processStrings = function (stringArray) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            var data, i;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        data = null;\n                        i = 0;\n                        _a.label = 1;\n                    case 1:\n                        if (!(i < stringArray.length)) return [3 /*break*/, 6];\n                        data = JSON.parse(stringArray[i]);\n                        if (!data) return [3 /*break*/, 5];\n                        if (!data['end']) return [3 /*break*/, 2];\n                        close();\n                        return [3 /*break*/, 5];\n                    case 2:\n                        if (!(data['id'] && Number(data['id']) !== this.id)) return [3 /*break*/, 4];\n                        Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* warn */ \"j\"])('Reconnecting, new server detected');\n                        this.endConnection();\n                        return [4 /*yield*/, this.retryConnection()];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        if (data['hb'] && Number(data['id']) === this.id) {\n                            this.send({ 'hb': true });\n                        }\n                        else if (!this.hasCloseSignal) {\n                            this.dataCallback(data);\n                        }\n                        _a.label = 5;\n                    case 5:\n                        ++i;\n                        return [3 /*break*/, 1];\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // responds whenever data is available on the request\n    // fires off a new listening request afterwards\n    HttpConnection.prototype.onReadyStateChange = function (request) {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            var thisSize, stringArray, data;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(request.readyState >= 3)) return [3 /*break*/, 2];\n                        try {\n                            thisSize = request.responseText.length;\n                        }\n                        catch (e) {\n                            Object(logger__WEBPACK_IMPORTED_MODULE_1__[/* log */ \"h\"])('caught exception');\n                            return [2 /*return*/];\n                        }\n                        if (thisSize > 0) {\n                            try {\n                                stringArray = this.dataToJsonChunks(request.responseText);\n                                if (this.id === 0 && stringArray.length > 0) {\n                                    data = JSON.parse(stringArray.shift());\n                                    this.id = data['id'];\n                                    this.retryCount = 0;\n                                }\n                                this.processStrings(stringArray);\n                            }\n                            catch (e) {\n                            }\n                        }\n                        if (!!this.hasCloseSignal) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.fireOffRequest()];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // initiates the listening request and calls itself to continue\n    // listening until session completes\n    HttpConnection.prototype.fireOffRequest = function () {\n        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(this, void 0, void 0, function () {\n            var _this = this;\n            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        _this.request = new XMLHttpRequest();\n                        _this.request.withCredentials = _this.useCredentials;\n                        var params;\n                        if (_this.id !== 0) {\n                            params = { 'id': String(_this.id), 'uc': String(_this.reqCounter) };\n                        }\n                        else {\n                            params = { 'uc': String(_this.reqCounter) };\n                        }\n                        var urlWithParams = Object(_PartRetrievers_utils__WEBPACK_IMPORTED_MODULE_4__[/* appendQueryParameters */ \"a\"])(_this.url, params);\n                        _this.reqCounter++;\n                        _this.request.open('GET', urlWithParams, true);\n                        _this.request.setRequestHeader('Cache-Control', 'no-cache');\n                        _this.request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n                        _this.request.onreadystatechange = function () {\n                            _this.onReadyStateChange(_this.request);\n                        };\n                        var reset = function () { return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ \"b\"])(_this, void 0, void 0, function () {\n                            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ \"d\"])(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        reject();\n                                        this.endConnection();\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(this.hasCloseSignal && this.retryCount < MAX_RETRY_COUNT)) return [3 /*break*/, 3];\n                                        return [4 /*yield*/, this.retryConnection()];\n                                    case 2:\n                                        _a.sent();\n                                        return [3 /*break*/, 1];\n                                    case 3: return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        _this.request.addEventListener('error', reset);\n                        _this.request.addEventListener('timeout', reset);\n                        _this.request.addEventListener('load', function () {\n                            // request successfully opened\n                            if (_this.openCallback) {\n                                _this.openCallback();\n                            }\n                            resolve();\n                        });\n                        _this.request.send();\n                    })];\n            });\n        });\n    };\n    HttpConnection.prototype.initiateConnection = function () {\n        var queryParameters = Object(_state_globalState__WEBPACK_IMPORTED_MODULE_3__[/* getState */ \"a\"])('wvsQueryParameters');\n        queryParameters['bcid'] = Object(_util_Utils__WEBPACK_IMPORTED_MODULE_2__[/* makeId */ \"l\"])(8);\n        Object(_state_globalState__WEBPACK_IMPORTED_MODULE_3__[/* setState */ \"b\"])('wvsQueryParameters', queryParameters);\n        this.id = 0;\n        this.reqCounter = 0;\n        this.hasCloseSignal = false;\n        return this.fireOffRequest();\n    };\n    HttpConnection.prototype.send = function (inData) {\n        var _this = this;\n        var xmlHttp = new XMLHttpRequest();\n        xmlHttp.withCredentials = this.useCredentials;\n        var urlWithId = Object(_PartRetrievers_utils__WEBPACK_IMPORTED_MODULE_4__[/* appendQueryParameters */ \"a\"])(this.url, { 'id': String(this.id) });\n        var formData = new FormData();\n        formData.append('data', JSON.stringify(inData));\n        xmlHttp.addEventListener('error', function () {\n            _this.endConnection();\n        });\n        xmlHttp.open('POST', urlWithId);\n        xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n        xmlHttp.send(formData);\n    };\n    HttpConnection.prototype.endConnection = function () {\n        this.id = 0;\n        this.hasCloseSignal = true;\n        if (this.closeCallback) {\n            this.closeCallback();\n        }\n        this.request.abort();\n        return Promise.resolve();\n    };\n    return HttpConnection;\n}());\n// generates websocket or http long polling connection\nvar WebViewerServerConnectionFactory = /** @class */ (function () {\n    function WebViewerServerConnectionFactory(constructorBaseURL, target, useCredentials) {\n        this.constructorBaseURL = constructorBaseURL;\n        this.target = target;\n        this.useCredentials = useCredentials;\n    }\n    WebViewerServerConnectionFactory.prototype.generateConnection = function (useWebsocket, dataCallback, openCallback, closeCallback, resetCallback) {\n        if (useWebsocket === void 0) { useWebsocket = true; }\n        if (dataCallback === void 0) { dataCallback = null; }\n        if (openCallback === void 0) { openCallback = null; }\n        if (closeCallback === void 0) { closeCallback = null; }\n        if (resetCallback === void 0) { resetCallback = null; }\n        if (useWebsocket) {\n            return new WebsocketConnection(this.constructorBaseURL, this.target, dataCallback, openCallback, closeCallback, resetCallback);\n        }\n        return new HttpConnection(this.constructorBaseURL, this.target, this.useCredentials, dataCallback, openCallback, closeCallback, resetCallback);\n    };\n    return WebViewerServerConnectionFactory;\n}());\n/* harmony default export */ __webpack_exports__[\"a\"] = (WebViewerServerConnectionFactory);\n\n\n/***/ })\n\n}]);","import { isString, isArray, isNumber, isFinite, isObject, omit, uniqueId, range } from 'lodash';\nimport { warn, log } from 'logger';\nimport { ServerOptions } from './index';\nimport { useEventHandler } from '../../util/events/EventHandler';\nimport { joinPaths } from '../../util/Utils';\nimport WebViewerServerConnectionFactory, { WebViewerServerConnection } from '../WebViewerServer/WebViewerServerConnectionService';\nimport PartRetriever from './PartRetriever';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\nimport { setState, getState } from '../../state/globalState';\nimport { appendQueryParameters } from './utils';\n\n// max active page image/tile requests\nconst MAX_ACTIVE_IMAGE_REQUESTS = 10;\nconst VERSION_LENGTH = 3;\n\nconst nullFunc = function() {\n  return false;\n};\n\nclass BBPromise {\n  promise: Promise<any>;\n  resolve: () => void;\n  reject: () => void;\n  result: any;\n  request: any;\n  state: number;\n\n  constructor() {\n    this.result = null;\n    this.request = null;\n    this.state = 0;\n    const me = this;\n    me.promise = new Promise(function(resolve, reject) {\n      me.resolve = function() {\n        if (me.state === 0 || me.state === 4) {\n          me.state = 1;\n          // arguments cannot be called in arrow functions\n          me.result = arguments[0];\n          resolve.apply(null, arguments);\n        }\n      };\n\n      me.reject = function() {\n        if (me.state === 0 || me.state === 4) {\n          me.state = 2;\n          reject.apply(null, arguments);\n        }\n      };\n    });\n  }\n\n  isResolved() {\n    return (this.state & 1) === 1;\n  }\n\n  isRejected() {\n    return (this.state & 2) === 2;\n  }\n\n  isPending() {\n    return !this.isRejected() && !this.isResolved();\n  }\n\n  isDownloading() {\n    return (this.state & 4) === 4;\n  }\n\n  setDownloading() {\n    this.state |= 4;\n  }\n}\n\n// map + lifo queue so queued jobs can be easily canceled\n// when created with requestSendWithQueue\nclass HashedQueue {\n  hashMap: any = {};\n  queue: Array<any> = [];\n\n  pop() {\n    const item = this.queue.pop();\n    this.hashMap[item.key] = undefined;\n    return item;\n  }\n\n  push(key: string, item: any) {\n    const objEntry = { key: key, data: item };\n    this.queue.push(objEntry);\n    this.hashMap[key] = objEntry.data;\n  }\n\n  contains(key: string) {\n    return !!this.hashMap[key];\n  }\n\n  get(key: string) {\n    return this.hashMap[key];\n  }\n\n  set(key: string, item: any) {\n    this.hashMap[key] = item;\n    this.queue.forEach((item: any, index: number) => {\n      if (item.key === key) {\n        this.queue[index] = item;\n      }\n    });\n  }\n\n  remove(key: string) {\n    this.hashMap[key] = undefined;\n    this.queue.forEach((item: any, index: number) => {\n      if (item.key === key) {\n        this.queue.splice(index, 1);\n      }\n    });\n  }\n\n  length() {\n    return this.queue.length;\n  }\n}\n\ntype Schema = {\n  name: string;\n  type: string;\n}\n\ntype ResponseSchema = {\n  [pages: string]: Array<Schema>;\n  pdf: Array<Schema>;\n  docmod: Array<Schema>;\n  health: Array<Schema>;\n  tiles: Array<Schema>;\n  text: Array<Schema>;\n  annots: Array<Schema>;\n  cAnnots: Array<Schema>;\n  image: Array<Schema>;\n  ApString2Xod: Array<Schema>;\n}\n\nconst responseSchema: ResponseSchema = {\n  'pages': [{ name: 'pages', type: 'a' }],\n  'pdf': [{ name: 'url', type: 's' }],\n  'docmod': [{ name: 'url', type: 's' }, { name: 'rID', type: 's' }],\n  'health': [],\n  'tiles': [{ name: 'z', type: 'n' }, { name: 'rID', type: 'n' }, { name: 'tiles', type: 'a' }, { name: 'size', type: 'n' }],\n  'cAnnots': [{ name: 'annots', type: 'a' }],\n  'annots': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }],\n  'image': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }, { name: 'p', type: 'n' }],\n  'text': [{ name: 'url', type: 's' }, { name: 'name', type: 's' }, { name: 'p', type: 'n' }],\n  'ApString2Xod': [{ name: 'url', type: 's' }, { name: 'rID', type: 's' }]\n};\n\nfunction validateField(object: any, fieldDesc: any, promiseCapability: any) {\n  if (!(fieldDesc.name in object)) {\n    promiseCapability.reject(`Response missing field \"${fieldDesc.name}\"`);\n    return false;\n  }\n  let expectedType = '';\n  let isOK = false;\n  const objVal = object[fieldDesc.name];\n  switch (fieldDesc.type) {\n    case 's':\n      expectedType = 'String';\n      isOK = isString(objVal);\n      break;\n    case 'a':\n      expectedType = 'Array';\n      isOK = isArray(objVal);\n      break;\n    case 'n':\n      expectedType = 'Number';\n      isOK = isNumber(objVal) && isFinite(objVal);\n      break;\n    case 'o':\n      expectedType = 'Object';\n      isOK = isObject(objVal) && !isArray(objVal);\n      break;\n  }\n  if (!isOK) {\n    promiseCapability.reject(`Expected response field \"${fieldDesc.name}\" to have type ${expectedType}`);\n  }\n  return isOK;\n}\n\nfunction validateObject(object: any, type: string, promiseCapability: any) {\n  if (!(type in responseSchema)) {\n    // we don't recognize this response type\n    return true;\n  }\n  const schema = responseSchema[type];\n  for (let i = 0; i < schema.length; i++) {\n    if (!validateField(object, schema[i], promiseCapability)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction replaceOfficeKeys(obj: any) {\n  const keys = [\n    'locale', 'excelMaxAllowedCellCount', 'applyPageBreaksToSheet',\n    'excelDefaultCellBorderWidth', 'displayChangeTracking'\n  ];\n\n  // We replace the first character with a capital, because the API on webviewer is slightly incorrect.\n  for (const element of keys) {\n    obj = replaceKey(obj, element, element.charAt(0).toUpperCase() + element.slice(1));\n  }\n\n  return obj;\n}\n\nfunction replaceKey(obj: any, key: string, replacementKey: string) {\n  if (obj[key]) {\n    Object.defineProperty(obj, replacementKey, Object.getOwnPropertyDescriptor(obj, key));\n    delete obj[key];\n  }\n\n  return obj;\n}\n\n/**\n * Constructs a new WebViewerServerPartRetriever.\n * WebViewerServerPartRetriever streams a .xod file hosted on a web server and display pages as they are available.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a streaming part retriever.\n * @name WebViewerServerPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @ignore\n */\nclass WebViewerServerPartRetriever {\n  disableWebsockets = false;\n  singleServerMode = false;\n  uploadData: any = null;\n  serverRoot: string;\n  cacheKey: string = null;\n  officeOptions: any = null;\n  cadOptions: any = null;\n  rasterizerOptions: any = null;\n  uriData: string = null;\n  docUri: string;\n  wvsVersion: string = null;\n  requestOptions: any = null;\n  pageSizesPromise: BBPromise = new BBPromise();\n  configPromise: BBPromise = new BBPromise();\n  connectionStarted = false;\n  pdfURLPromise: BBPromise = null;\n  xodURLPromise: BBPromise = null;\n  xodExistPromise: BBPromise = null;\n  annotPromise: BBPromise = null;\n  tileRequests: Array<any> = [];\n  freeTileRequests: Array<any> = [];\n  cache: any = {};\n  timeStamp = 0;\n  pageImages: Array<any> = [];\n  pageText: Array<any> = [];\n  fileExtension: string = null;\n  deadServer = false;\n  id: string = null;\n  auth: string = null;\n  serverID: string = null;\n  healthSwitchCallback: () => void = nullFunc;\n  linkFinderFunc: () => void = nullFunc;\n  retryCount = 0;\n  hasBadHealthState = false;\n  nextRequestID =1;\n  linkRequests: any = {};\n  activeImageRequests: any = 0;\n  requestQueue: any = new HashedQueue();\n  connector: WebViewerServerConnection;\n\n  constructor(doc: string, webViewerServer: string, serverOptions: ServerOptions) {\n    let serverRoot = webViewerServer;\n    if (!serverRoot.endsWith('/')) {\n      serverRoot += '/';\n    }\n\n    serverOptions = serverOptions || {};\n    this.disableWebsockets = serverOptions['disableWebsockets'] || false;\n    this.singleServerMode = serverOptions['singleServerMode'] || false;\n\n    if (serverOptions['customQueryParameters'] != null) {\n      setState('wvsQueryParameters', serverOptions['customQueryParameters']);\n    }\n\n    if (!serverRoot.endsWith('blackbox/')) {\n      serverRoot += 'blackbox/';\n    }\n\n    this.uploadData = serverOptions['uploadData'] || null;\n    this.uriData = serverOptions['uriData'] || null;\n    this.cacheKey = serverOptions['cacheKey'] || null;\n    this.officeOptions = serverOptions['officeOptions'] || null;\n    if (this.officeOptions) {\n      this.officeOptions = replaceOfficeKeys(this.officeOptions);\n    }\n\n    this.rasterizerOptions = serverOptions['rasterizerOptions'] || null;\n    this.cadOptions = serverOptions['cadOptions'] || null;\n\n    this.serverRoot = serverRoot;\n    this.docUri = doc;\n    this.setWithCredentials(true);\n\n    const connectionFactory = new WebViewerServerConnectionFactory(serverRoot, null, this.getWithCredentials());\n    this.connector = connectionFactory.generateConnection(!this.disableWebsockets, (result) => {\n      this.onServerMessage(result);\n    }, () => null, () => {\n      this.connectionStarted = false;\n    }, () => {\n      this.resetRetriever();\n    });\n  }\n\n  deleteSyncCookie() {\n    return new Promise((resolve, reject) => {\n      const xmlHttp = new XMLHttpRequest();\n      const url = `${this.serverRoot}ck`;\n      xmlHttp.open('GET', url);\n      xmlHttp.withCredentials = this.getWithCredentials();\n      xmlHttp.onreadystatechange = () => {\n        if (xmlHttp.readyState === XMLHttpRequest.DONE) {\n          if (xmlHttp.status === 200) {\n            resolve();\n          } else {\n            reject();\n          }\n        }\n      };\n      xmlHttp.send();\n    });\n  }\n\n  setLinkReplacementCallbacks(healthSwitchCallback, linkFinderFunc) {\n    this.healthSwitchCallback = healthSwitchCallback || nullFunc;\n    this.linkFinderFunc = linkFinderFunc || nullFunc;\n  }\n\n  closeConnection() {\n    this.resetState();\n    return this.connector.endConnection(true);\n  }\n\n  async resetState() {\n    this.configPromise = new BBPromise();\n    this.pageSizesPromise = new BBPromise();\n    this.connectionStarted = false;\n    this.id = null;\n    this.deadServer = false;\n    await this.deleteSyncCookie();\n  }\n\n  resetRetriever() {\n    this.healthSwitchCallback();\n    this.resetState();\n\n    if (this.pdfURLPromise) {\n      if (this.pdfURLPromise.isPending()) {\n        this.sendRequest(this.pdfURLPromise.request);\n      } else if (this.pdfURLPromise.isResolved() && this.linkFinderFunc(this.pdfURLPromise.result['url'], 'pdf')) {\n        this.pdfURLPromise = null;\n        this.requestPDF();\n      }\n    }\n\n    if (this.annotPromise) {\n      if (this.annotPromise.isPending()) {\n        this.sendRequest(this.annotPromise.request);\n      }\n    }\n\n    if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n      this.sendRequest(this.xodURLPromise.request);\n    } else if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n      this.getXODIfExists(this.xodExistPromise.request);\n    }\n\n    let i;\n    for (i = 0; i < this.pageImages.length; i++) {\n      if (this.pageImages[i]) {\n        if (this.pageImages[i].isPending()) {\n          this.sendRequest(this.pageImages[i].request);\n        } else if (this.pageImages[i].isResolved() && this.linkFinderFunc(this.pageImages[i].result['url'], 'image')) {\n          this.pageImages[i] = null;\n          this.requestPageImage(uniqueId(), i);\n        }\n      }\n    }\n    for (i = 0; i < this.pageText.length; i++) {\n      if (this.pageText[i]) {\n        if (this.pageText[i].isPending() && !this.pageText[i].isDownloading()) {\n          this.sendRequest(this.pageText[i].request);\n        }\n      }\n    }\n    for (i = 0; i < this.tileRequests.length; i++) {\n      if (this.tileRequests[i]) {\n        if (this.tileRequests[i].isPending()) {\n          this.sendRequest(this.tileRequests[i].request);\n        }\n      }\n    }\n  }\n\n\n  initConnection() {\n    if (!this.connectionStarted) {\n      this.connectionStarted = true;\n      this.timeStamp = Date.now();\n      return this.connector.initiateConnection();\n    }\n\n    return Promise.resolve();\n  }\n\n  uploadDocument() {\n    let data;\n    let loadCallback;\n    let ext;\n    let type;\n    let contentType;\n\n    return new Promise((resolve, reject) => {\n      if (this.uploadData) {\n        data = new FormData();\n        data.append('file', this.uploadData['fileHandle'], this.uploadData['fileHandle']['name']);\n        if (this.officeOptions) {\n          data.append('officeOptions', JSON.stringify(this.officeOptions));\n        }\n\n        if (this.rasterizerOptions) {\n          data.append('rasterizerOptions', JSON.stringify(this.rasterizerOptions));\n        }\n\n        if (this.cadOptions) {\n          data.append('cadOptions', this.cadOptions['getJsonString']());\n        }\n\n        if (this.cacheKey) {\n          data.append('cacheKey', this.cacheKey);\n        }\n\n        loadCallback = this.uploadData['loadCallback'];\n        type = 'upload';\n        ext = this.uploadData['extension'];\n      } else if (this.uriData) {\n        data = {\n          uri: this.uriData['uri'],\n          shareId: this.uriData['shareId'],\n        };\n        data = Object.keys(data).map((key) => `${key}=${data[key] ? encodeURIComponent(data[key]) : ''}`).join('&');\n        contentType = 'application/x-www-form-urlencoded; charset=UTF-8';\n        loadCallback = this.uriData['loadCallback'];\n        type = 'url';\n        ext = this.uriData['extension'];\n      } else {\n        // nothing to upload\n        resolve();\n        return;\n      }\n\n      const xmlHttp = new XMLHttpRequest();\n\n      let url = joinPaths(this.serverRoot, 'AuxUpload');\n      url = appendQueryParameters(url, { 'type': type, 'ext': ext });\n\n      xmlHttp.open('POST', url);\n      xmlHttp.withCredentials = this.getWithCredentials();\n      if (contentType) {\n        xmlHttp.setRequestHeader('Content-Type', contentType);\n      }\n\n      xmlHttp.addEventListener('load', () => {\n        if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n          const data = JSON.parse(xmlHttp.response);\n          this.docUri = data.uri;\n          loadCallback(data);\n          resolve(data);\n        }\n      });\n\n      xmlHttp.addEventListener('error', () => {\n        reject(`${xmlHttp.statusText} ${JSON.stringify(xmlHttp)}`);\n      });\n\n      if (this.uploadData && this.uploadData['onProgress'] != null) {\n        xmlHttp.upload.onprogress = (evt) => {\n          this.uploadData['onProgress'](evt);\n        };\n      }\n\n      xmlHttp.send(data);\n    });\n  }\n\n  requestDocumentWithPass(password: string) {\n    this.password = password || null;\n\n    if (!this.pageSizesPromise.isResolved()) {\n      this.pageSizesPromise = new BBPromise();\n      this.sendRequest({ 't': 'pages' });\n    }\n\n    return this.pageSizesPromise.promise;\n  }\n\n  /**\n   * Requests the information necessary to initialize the Document.\n   * @method WebViewerServerPartRetriever#requestDocument\n   */\n  requestDocument(fileExtension: string) {\n    this.fileExtension = fileExtension || null;\n    if (!this.pageSizesPromise.isResolved()) {\n      this.sendRequest({ 't': 'pages' });\n    }\n\n    return this.pageSizesPromise.promise;\n  }\n\n  completRequestObject(requestObj: any) {\n    const toSend = Object.assign(requestObj, { 'uri': encodeURIComponent(this.docUri) });\n    if (this.fileExtension) {\n      toSend['ext'] = this.fileExtension;\n    }\n    if (this.requestOptions) {\n      toSend['c'] = this.requestOptions;\n    }\n    if (this.password) {\n      toSend['pswd'] = this.password;\n    }\n    if (this.cacheKey) {\n      toSend['cacheKey'] = this.cacheKey;\n    }\n    if (this.officeOptions) {\n      toSend['officeOptions'] = this.officeOptions;\n    }\n\n    if (this.rasterizerOptions) {\n      toSend['rastOptions'] = this.rasterizerOptions;\n    }\n\n    if (this.cadOptions) {\n      // getting the JSON string causes this to get escaped twice\n      toSend['cadOptions'] = this.cadOptions['mImpl'];\n    }\n\n    return toSend;\n  }\n\n  // acts as a buffer so webviewer does not spam the server with requests\n  // currently only applies to page image/tile requests\n  sendRequestFromQueueIfPossible() {\n    if (this.requestQueue.length() > 0 && this.activeImageRequests <= MAX_ACTIVE_IMAGE_REQUESTS) {\n      this.sendRequestFromQueueToActive(this.requestQueue.pop().data);\n    }\n  }\n\n  cancelQueuedRequest(id: string) {\n    if (this.requestQueue.length() > 0 && this.requestQueue.contains(id)) {\n      this.requestQueue.remove(id);\n      return true;\n    }\n    return false;\n  }\n\n  sendRequest(args: any) {\n    const toSend = this.completRequestObject(args);\n    this.connector.send(toSend);\n  }\n\n  // Using this function will send the request limited by a queue.\n  // This will allow the requests to be cancelable.\n  //\n  // Currently this is only for use with page image/tile requests. cancelQueuedRequest\n  // is what can be called to cancel requests sent to this queue.\n  sendOrQueueRequest(id: string, args: any) {\n    if (this.activeImageRequests > MAX_ACTIVE_IMAGE_REQUESTS) {\n      this.requestQueue.push(id, args);\n    } else {\n      this.activeImageRequests++;\n      const toSend = this.completRequestObject(args);\n      this.connector.send(toSend);\n    }\n  }\n\n  // Call to migrate a queued request to an actual request\n  sendRequestFromQueueToActive(requestData: any) {\n    this.activeImageRequests++;\n    const toSend = this.completRequestObject(requestData);\n    this.connector.send(toSend);\n  }\n\n  constructPart(part: any) {\n    return part;\n  }\n\n  healthHandler(healthStatus: boolean) {\n    if (this.singleServerMode && healthStatus) {\n      warn('Server failed health check. Single server mode ignoring check.');\n    } else if (!this.disableIEFallback && healthStatus && this.retryCount <= 3) {\n      this.hasBadHealthState = true;\n      this.connector.endConnection();\n    } else if (this.retryCount > 3) {\n      // instead of spinning our wheels when no healthy server can be found,\n      // ignore future health issues and just bind to a server\n      this.singleServerMode = true;\n    }\n  }\n\n  onServerMessage(data: any) {\n    let resultObj;\n    let resultPromise;\n    const innerData = data['data'];\n    const error = data['err'];\n    const opType = data['t'];\n    switch (opType) {\n      case 'upload':\n        if (error) {\n          this.uploadPromise.reject(error);\n        } else {\n          this.uploadPromise.resolve('Success');\n        }\n        break;\n      case 'pages':\n        if (error) {\n          this.pageSizesPromise.reject(error);\n        } else if (validateObject(innerData, opType, this.pageSizesPromise)) {\n          this.pageSizesPromise.resolve(innerData);\n        }\n        break;\n      case 'config':\n        if (error) {\n          this.configPromise.reject(error);\n        } else if (validateObject(innerData, opType, this.configPromise)) {\n          this.healthHandler(innerData['unhealthy']);\n\n          if (innerData['id']) {\n            this.id = innerData['id'];\n          }\n          if (innerData['auth']) {\n            const params = getState('wvsQueryParameters');\n            params['auth'] = innerData['auth'];\n            setState('wvsQueryParameters', params);\n          }\n          if (innerData['serverVersion']) {\n            this.wvsVersion = innerData['serverVersion'];\n            log(`[WebViewer Server] server version: ${this.wvsVersion}`);\n          }\n          if (innerData['serverID']) {\n            if (innerData['serverID'] === this.serverID && this.hasBadHealthState) {\n              this.retryCount += 1;\n            } else {\n              this.retryCount = 0;\n            }\n            this.serverID = innerData['serverID'];\n          } else {\n            this.retryCount = 0;\n          }\n          this.hasBadHealthState = false;\n          this.configPromise.resolve(innerData);\n        }\n        break;\n      case 'health':\n        if (error) {\n          this.configPromise.reject(error);\n        } else if (validateObject(innerData, opType, this.configPromise)) {\n          this.healthHandler(innerData['unhealthy']);\n        }\n        break;\n      case 'pdf':\n        innerData['url'] = appendQueryParameters(`${this.serverRoot}../${encodeURI(innerData['url'])}`);\n        if (error) {\n          this.pdfURLPromise.reject(error);\n        } else if (validateObject(innerData, opType, this.pdfURLPromise)) {\n          this.pdfURLPromise.resolve(innerData);\n        }\n        break;\n      case 'ApString2Xod':\n        innerData['url'] = appendQueryParameters(`${this.serverRoot}../data/${encodeURI(innerData['url'])}`);\n        if (error) {\n          this.linkRequests[innerData['rID']].reject(error);\n        } else if (validateObject(innerData, opType, this.linkRequests[innerData['rID']])) {\n          this.linkRequests[innerData['rID']].resolve(innerData);\n        }\n        break;\n      case 'docmod':\n        innerData['url'] = appendQueryParameters(`${this.serverRoot}../${encodeURI(innerData['url'])}`);\n        if (error) {\n          this.linkRequests[innerData['rID']].reject(error);\n        } else if (validateObject(innerData, opType, this.pdfURLPromise)) {\n          this.linkRequests[innerData['rID']].resolve(innerData);\n        }\n        break;\n      case 'xod':\n        if (error) {\n          if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n            this.xodURLPromise.reject(error);\n          }\n          if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n            this.xodExistPromise.reject(error);\n          }\n        } else if (innerData['notFound']) {\n        // if we tried to create this, then\n          if (!innerData['noCreate']) {\n            if (this.xodURLPromise && this.xodURLPromise.isPending()) {\n              this.xodURLPromise.resolve(innerData);\n            }\n          }\n          if (this.xodExistPromise && this.xodExistPromise.isPending()) {\n            this.xodExistPromise.resolve(innerData);\n          }\n        } else {\n          if (innerData['url']) {\n            innerData['url'] = appendQueryParameters(`${this.serverRoot}../${encodeURI(innerData['url'])}`);\n          }\n          if (!this.xodExistPromise || this.xodExistPromise.isResolved()) {\n            this.xodExistPromise = new BBPromise();\n            this.xodExistPromise.request = { 't': 'xod', 'noCreate': true };\n          }\n          if (!this.xodURLPromise) {\n            this.xodURLPromise = new BBPromise();\n            this.xodURLPromise.request = { 't': 'xod' };\n          }\n          this.xodExistPromise.resolve(innerData);\n          this.xodURLPromise.resolve(innerData);\n        }\n        break;\n      case 'cAnnots':\n        resultPromise = this.annotPromise;\n\n        if (error) {\n          resultPromise.reject(error);\n        } else if (validateObject(innerData, opType, resultPromise)) {\n          resultPromise.setDownloading();\n\n          const annotChunkPromises = [];\n          const annots = innerData['annots'];\n          for (let i = 0; i < annots.length; i++) {\n            const xfdfStart = annots[i]['s'];\n            const xfdfEnd = annots[i]['e'];\n            const annotURL = `${this.serverRoot}../${encodeURI(annots[i]['xfdf'])}`;\n            const appearanceURL = annots[i]['hasAppearance'] === 'true' ? appendQueryParameters(`${annotURL}.xodapp`) : null;\n            const xfdfRange = range(xfdfStart, xfdfEnd + 1);\n\n            annotChunkPromises[i] = {\n              range: xfdfRange,\n              promise: new Promise((resolve, reject) => {\n                const xmlHttp = new XMLHttpRequest();\n                xmlHttp.open('GET', appendQueryParameters(annotURL));\n                xmlHttp.responseType = 'text';\n                xmlHttp.withCredentials = this.getWithCredentials();\n                xmlHttp.addEventListener('load', () => {\n                  if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n                    resolve({ xfdfString: xmlHttp.response, appearanceDocURL: appearanceURL, range: xfdfRange });\n                  }\n                });\n                xmlHttp.addEventListener('error', () => {\n                  reject(`${xmlHttp.statusText} ${JSON.stringify(xmlHttp)}`);\n                });\n                xmlHttp.send();\n              })\n            };\n          }\n\n          resultPromise.resolve(annotChunkPromises);\n        }\n        break;\n      case 'annots':\n        if (error) {\n          this.annotPromise.reject(error);\n        } else if (validateObject(innerData, opType, this.annotPromise)) {\n          this.annotPromise.setDownloading();\n          const xmlHttp = new XMLHttpRequest();\n\n          const annotURL = `${this.serverRoot}../${encodeURI(innerData['url'])}`;\n          const appearanceURL = innerData['hasAppearance'] ? appendQueryParameters(`${annotURL}.xodapp`) : null;\n          xmlHttp.open('GET', appendQueryParameters(annotURL));\n          xmlHttp.responseType = 'text';\n          xmlHttp.withCredentials = this.getWithCredentials();\n          xmlHttp.addEventListener('load', () => {\n            if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n              this.annotPromise.resolve({ xfdfString: xmlHttp.response, appearanceDocURL: appearanceURL });\n            }\n          });\n          xmlHttp.addEventListener('error', () => {\n            this.annotPromise.reject(`${xmlHttp.statusText} ${JSON.stringify(xmlHttp)}`);\n          });\n          xmlHttp.send();\n        }\n        break;\n      case 'image':\n        this.activeImageRequests--;\n        resultObj = this.pageImages[innerData['p']];\n        if (error) {\n          resultObj.promise.reject(error);\n        } else if (validateObject(innerData, opType, resultObj)) {\n        // console.log('Page: ' + innerData['p'] + ' ' + data['data']['name']);\n          resultObj.result = innerData;\n          resultObj.result.url = appendQueryParameters(`${this.serverRoot}../${encodeURI(resultObj.result.url)}`);\n          resultObj.resolve(resultObj.result);\n        }\n\n        break;\n      case 'tiles':\n        this.activeImageRequests--;\n        resultObj = innerData['rID'];\n        resultPromise = this.tileRequests[resultObj];\n        this.tileRequests[resultObj] = null;\n        this.freeTileRequests.push(resultObj);\n\n        if (error) {\n          resultPromise.reject(error);\n        } else if (validateObject(innerData, opType, resultPromise)) {\n          for (let i = 0; i < innerData['tiles'].length; i++) {\n            innerData['tiles'][i] = appendQueryParameters(`${this.serverRoot}../${encodeURI(innerData['tiles'][i])}`);\n          }\n          resultPromise.resolve(innerData);\n        }\n        break;\n      case 'text':\n        resultObj = this.pageText[innerData['p']];\n        if (error) {\n          resultObj.reject(error);\n        } else if (validateObject(innerData, opType, resultObj)) {\n          resultObj.setDownloading();\n          const xmlHttp = new XMLHttpRequest();\n          const turl = appendQueryParameters(`${this.serverRoot}../${encodeURI(innerData['url'])}`);\n          xmlHttp.open('GET', turl);\n          xmlHttp.withCredentials = this.getWithCredentials();\n          xmlHttp.addEventListener('load', function() {\n            if (xmlHttp.readyState === xmlHttp.DONE && xmlHttp.status === 200) {\n              resultObj.result = JSON.parse(xmlHttp.response);\n              resultObj.resolve(resultObj.result);\n            }\n          });\n          xmlHttp.addEventListener('error', (e) => {\n            resultObj.reject(`${xmlHttp.statusText} ${JSON.stringify(e)}`);\n          });\n          xmlHttp.send();\n        }\n        break;\n      case 'progress':\n        if (innerData['t'] === 'loading') {\n          this.trigger(PartRetriever['Events']['DOCUMENT_LOADING_PROGRESS'], [innerData['bytes'], innerData['total']]);\n        }\n        break;\n    }\n\n    // since a result came in, there may be room on request queue\n    this.sendRequestFromQueueIfPossible();\n\n    if (!opType && data['echo'] && data) {\n      if (data['echo']['t'] === 'apstring2xod') {\n        const reqID = data['echo']['reqID'];\n        if (reqID) {\n          const version = parseInt(this.wvsVersion, 10);\n          if (version >= 2) {\n            this.linkRequests[reqID].reject('Message unhandled by server');\n          } else {\n            this.linkRequests[reqID].reject();\n          }\n          // else, that's expected\n        }\n      }\n    }\n  }\n\n  async getConfig() {\n    await this.initConnection();\n    return this.configPromise.promise;\n  }\n\n  getAppearanceStringRequest(input: any) {\n    const xmlHttp = new XMLHttpRequest();\n    const url = appendQueryParameters(`${this.serverRoot}aul`, { 'id': this.id });\n    const formData = new FormData();\n    const parts = {};\n\n    // for (const appearanceString of input.body) {   => does not work for some reason in minified build\n    for (let i = 0; i < input.body.length; i++) {\n      const appearanceString = input.body[i];\n      parts[appearanceString.id] = `${appearanceString.appearanceString['w']};${appearanceString.appearanceString['h']}`;\n      formData.append(appearanceString.id, appearanceString.appearanceString['dataString']);\n    }\n\n    const toSendOrig = {\n      't': 'apstring2xod',\n      'reqID': this.nextRequestID++,\n      'parts': parts,\n    };\n\n    const toSend = this.completRequestObject(toSendOrig);\n    formData.append('msg', JSON.stringify(toSend));\n\n    this.linkRequests[toSend['reqID']] = new BBPromise();\n    xmlHttp.open('POST', url);\n    xmlHttp.withCredentials = this.getWithCredentials;\n    const promiseStatus = new Promise((resolve, reject) => {\n      xmlHttp.onreadystatechange = () => {\n        // request is done. now check if request was success or error\n        if (xmlHttp.readyState === 4) {\n          if (xmlHttp.status === 200) {\n            resolve();\n          } else {\n            reject('An error occurred while sending down appearance strings to the server');\n          }\n        }\n      };\n    });\n    xmlHttp.send(formData);\n    return promiseStatus\n      .then(() => {\n        return this.linkRequests[toSend['reqID']].promise;\n      });\n  }\n\n  // Assumes x.x.x version number for wvs and provided version\n  // Returns 0 if value equals this.wvsVersion, -1 if it is less than and 1 if it is greater than\n  compareToWVSVersion(version: string) {\n    const cleanVersion = this.wvsVersion.split('-')[0];\n    const wvsVersionValues = cleanVersion.split('.');\n    const providedVersionValues = version.split('.');\n\n    if (wvsVersionValues.length !== VERSION_LENGTH) {\n      throw Error('Invalid WVS version length.');\n    }\n\n    if (providedVersionValues.length !== VERSION_LENGTH) {\n      throw Error('Invalid version length.');\n    }\n\n    for (let i = 0; i < wvsVersionValues.length; ++i) {\n      if (providedVersionValues.length === i) {\n        return -1;\n      } if (wvsVersionValues[i] > providedVersionValues[i]) {\n        return -1;\n      } if (wvsVersionValues[i] === providedVersionValues[i]) {\n        continue;\n      } else {\n        return 1;\n      }\n    }\n\n    return 0;\n  }\n\n  chunkedAnnotationsAvailable() {\n    return this.compareToWVSVersion('1.5.9') <= 0;\n  }\n\n  getAnnots() {\n    if (!this.annotPromise) {\n      this.annotPromise = new BBPromise();\n      if (this.chunkedAnnotationsAvailable()) {\n        this.annotPromise.request = { 't': 'cAnnots' };\n      } else {\n        this.annotPromise.request = { 't': 'annots' };\n      }\n      this.sendRequest(this.annotPromise.request);\n    }\n    return this.annotPromise.promise;\n  }\n\n  requestPageImage(id: string, pageIndex: number) {\n    if (!this.pageImages[pageIndex]) {\n      this.pageImages[pageIndex] = new BBPromise();\n      this.pageImages[pageIndex].request = { 't': 'image', 'p': pageIndex };\n      this.sendOrQueueRequest(id, this.pageImages[pageIndex].request);\n    }\n    return this.pageImages[pageIndex].promise;\n  }\n\n  requestPageText(pageIndex: number) {\n    if (!this.pageText[pageIndex]) {\n      this.pageText[pageIndex] = new BBPromise();\n      this.pageText[pageIndex].request = { 't': 'text', 'p': pageIndex };\n      this.sendRequest(this.pageText[pageIndex].request);\n    }\n    return this.pageText[pageIndex].promise;\n  }\n\n  requestTiles(id: string, pageIndex: number, zoom: number, viewportRect: any, tileSize: number) {\n    let requestIndex = this.tileRequests.length;\n    if (this.freeTileRequests.length) {\n      requestIndex = this.freeTileRequests.pop();\n    }\n    this.tileRequests[requestIndex] = new BBPromise();\n    this.tileRequests[requestIndex].request = {\n      't': 'tiles', 'p': pageIndex, 'z': zoom, 'r': viewportRect, 'size': tileSize, 'rID': requestIndex,\n    };\n    this.sendOrQueueRequest(id, this.tileRequests[requestIndex].request);\n    return this.tileRequests[requestIndex].promise;\n  }\n\n  requestPDF() {\n    if (!this.pdfURLPromise) {\n      this.pdfURLPromise = new BBPromise();\n      this.pdfURLPromise.request = { 't': 'pdf' };\n      if (this.deadServer) {\n        this.pdfURLPromise.resolve({ 'url': this.docUri });\n      } else {\n        this.sendRequest(this.pdfURLPromise.request);\n      }\n    }\n    return this.pdfURLPromise.promise;\n  }\n\n  getModifiedDoc(options: any) {\n    const xmlHttp = new XMLHttpRequest();\n    const url = appendQueryParameters(`${this.serverRoot}aul`, { 'id': this.id });\n    const formData = new FormData();\n    const parts = {};\n\n    if (options['annots']) {\n      parts['annots'] = 'xfdf';\n    }\n    if (options['watermark']) {\n      parts['watermark'] = 'png';\n    }\n    if (options['redactions']) {\n      parts['redactions'] = 'redact';\n    }\n\n    const toSendOrig = {\n      't': 'docmod',\n      'reqID': this.nextRequestID++,\n      'parts': parts,\n    };\n\n    if (options['print']) {\n      toSendOrig['print'] = true;\n    }\n\n    const toSend = this.completRequestObject(toSendOrig);\n    formData.append('msg', JSON.stringify(toSend));\n\n    return Promise.all([options['annots'], options['watermark'], options['redactions']].map((option) => {\n      // promisify every option\n      return Promise.resolve(option);\n    })).then((options) => {\n      const annots = options[0];\n      const watermark = options[1];\n      const redactions = options[2];\n      if (annots) {\n        formData.append('annots', annots);\n      }\n      if (watermark) {\n        formData.append('watermark', watermark);\n      }\n      if (redactions) {\n        formData.append('redactions', redactions);\n      }\n\n      this.linkRequests[toSend['reqID']] = new BBPromise();\n      xmlHttp.open('POST', url);\n      xmlHttp.withCredentials = this.getWithCredentials;\n      const promiseStatus = new Promise((resolve, reject) => {\n        xmlHttp.onreadystatechange = () => {\n          // request is done. now check if request was success or error\n          if (xmlHttp.readyState === 4) {\n            if (xmlHttp.status === 200) {\n              resolve();\n            } else {\n              reject('An error occurred while sending down annotation data to the server');\n            }\n          }\n        };\n      });\n      xmlHttp.send(formData);\n      return promiseStatus\n        .then(() => {\n          return this.linkRequests[toSend['reqID']].promise;\n        });\n    });\n  }\n\n  getXODIfExists() {\n    if (!this.xodExistPromise) {\n      this.xodExistPromise = new BBPromise();\n      this.xodExistPromise.request = { 't': 'xod', 'noCreate': true };\n      this.sendRequest(this.xodExistPromise.request);\n    }\n    return this.xodExistPromise.promise;\n  }\n\n  requestXOD() {\n    if (!this.xodURLPromise) {\n      this.xodURLPromise = new BBPromise();\n      this.xodURLPromise.request = { 't': 'xod' };\n      this.sendRequest(this.xodURLPromise.request);\n    }\n    return this.xodURLPromise.promise;\n  }\n\n  requiresCache() {\n    return true;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  request(parts: any, customData: any) {\n    // No-op since we just emit parts as they come in\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  receivedHeader(header: any) {\n    // console.log('Received a zip local header for file (%d bytes uncompressed)', header.uSize);\n  }\n\n  abort() {\n    for (let i = 0; i < this.tileRequests.length; i++) {\n      if (this.tileRequests[i]) {\n        this.tileRequests[i].resolve(null);\n        this.tileRequests[i] = null;\n        this.freeTileRequests.push(i);\n      }\n    }\n    this.close();\n  }\n\n  setCustomHeaders(headers) {\n    this.requestOptions = this.requestOptions || {};\n    this.requestOptions['headers'] = headers;\n  }\n\n  getCustomHeaders() {\n    return this.requestOptions ? omit(this.requestOptions['headers'], ['Cookie', 'cookie']) : null;\n  }\n\n  setWithCredentials(withCredentials) {\n    this.requestOptions = this.requestOptions || {};\n    this.requestOptions['internal'] = this.requestOptions['internal'] || {};\n    this.requestOptions['internal']['withCredentials'] = withCredentials;\n  }\n\n  getWithCredentials() {\n    return (this.requestOptions && this.requestOptions['internal'] ? this.requestOptions['internal']['withCredentials'] : null);\n  }\n\n  getFileData() {\n    return Promise.reject();\n  }\n}\n\nuseEventHandler(WebViewerServerPartRetriever);\nexportEventHandler(WebViewerServerPartRetriever);\nexportPartRetrieverFunctions(WebViewerServerPartRetriever);\n\nexport default WebViewerServerPartRetriever;\n","import { warn, log } from 'logger';\nimport { makeId } from '../../util/Utils';\nimport { getState, setState } from '../../state/globalState';\nimport { appendQueryParameters } from '../PartRetrievers/utils';\nimport { WVSConnectionException } from '../../util/constants/errorMessages';\n\ntype DataCallback = (\n  data: {\n    t: string;\n    data: {};\n  }\n) => void;\n\nconst MAX_RETRY_COUNT = 8;\nconst MANUAL_DISCONNECTION = 3000;\n\nexport interface WebViewerServerConnection {\n  initiateConnection(): Promise<unknown>;\n  endConnection(): Promise<unknown>;\n  send(inData: any): void;\n}\n\nclass WebsocketConnection implements WebViewerServerConnection {\n  baseURL: string;\n  url: string;\n  dataCallback: DataCallback;\n  closeCallback: () => void;\n  openCallback: () => void;\n  resetCallback: () => void;\n  reconnectInterval: ReturnType<typeof setInterval>\n  ws: WebSocket;\n\n  mHasError = false;\n  retryCount = 0;\n\n  constructor(\n    constructorBaseURL: string,\n    target: string,\n    dataCallback: DataCallback = null,\n    openCallback: () => void = null,\n    closeCallback: () => void = null,\n    resetCallback: () => void = null,\n  ) {\n    this.baseURL = this.wsBaseURL(constructorBaseURL);\n    this.url = target ? `${this.baseURL}/${target}` : `${this.baseURL}/ws`;\n    this.dataCallback = dataCallback;\n    this.openCallback = openCallback;\n    this.closeCallback = closeCallback;\n    this.resetCallback = resetCallback;\n  }\n\n  wsBaseURL(inBaseURL: string) {\n    let start = inBaseURL.indexOf('://');\n    let protocol = 'ws://';\n    if (start < 0) {\n      start = 0;\n    } else {\n      if (start === 5) {\n        protocol = 'wss://';\n      }\n      start += 3;\n    }\n    let end = inBaseURL.lastIndexOf('/');\n    if (end < 0) {\n      end = inBaseURL.length;\n    }\n    return protocol + inBaseURL.slice(start, end);\n  }\n\n  send(jsObject: any) {\n    if (this.ws.readyState !== WebSocket.CLOSED && !this.mHasError) {\n      this.ws.send(JSON.stringify(jsObject));\n    }\n  }\n\n  async initiateConnection() {\n    const queryParameters = getState('wvsQueryParameters');\n    queryParameters['bcid'] = makeId(8);\n    setState('wvsQueryParameters', queryParameters);\n\n    return new Promise((resolve, reject) => {\n      const urlWithParams = appendQueryParameters(this.url);\n      this.ws = new WebSocket(urlWithParams);\n      this.ws.onopen = () => {\n        if (this.openCallback) {\n          this.openCallback();\n        }\n        resolve();\n      };\n\n      this.ws.onerror = (err) => {\n        this.mHasError = true;\n        reject(err);\n      };\n\n      this.ws.onclose = async ({ code }) => {\n        if (this.closeCallback) {\n          this.closeCallback();\n        }\n\n        // reconnect if not a user triggered close\n        if (code !== MANUAL_DISCONNECTION) {\n          if (this.retryCount++ < MAX_RETRY_COUNT) {\n            await new Promise((resolve) => setTimeout(async () => {\n              this.resetCallback();\n              await this.initiateConnection();\n              resolve();\n            }, 3000));\n          } else {\n            reject(WVSConnectionException);\n          }\n        }\n      };\n\n      this.ws.onmessage = (message) => {\n        if (message && message.data) {\n          const json = JSON.parse(message.data);\n          if (json['hb']) {\n            this.send({ 'hb': true });\n          } else if (json['end']) {\n            close();\n          } else {\n            this.dataCallback(json);\n          }\n        }\n      };\n    });\n  }\n\n  // noReconnect prevents automatic reconnect on close\n  endConnection(noReconnect = false) {\n    this.retryCount = 0;\n    if (noReconnect) {\n      this.ws.close(MANUAL_DISCONNECTION);\n    } else {\n      this.ws.close();\n    }\n\n    return Promise.resolve();\n  }\n}\n\nclass HttpConnection implements WebViewerServerConnection {\n  baseURL: string;\n  url: string;\n  useCredentials: boolean;\n  dataCallback: DataCallback;\n  closeCallback: () => void;\n  openCallback: () => void;\n  resetCallback: () => void;\n\n  id = 0;\n  reqCounter = 0;\n  retryCount = 0;\n  hasCloseSignal = false;\n  request: XMLHttpRequest = null;\n\n  constructor(\n    constructorBaseURL: string,\n    target: string,\n    useCredentials: boolean,\n    dataCallback: DataCallback = null,\n    openCallback: () => void = null,\n    closeCallback: () => void = null,\n    resetCallback: () => void = null,\n  ) {\n    const baseURL = this.processBaseURL(constructorBaseURL);\n    this.url = target ? (`${baseURL}/${target}pf`) : (`${baseURL}/pf`);\n    this.useCredentials = useCredentials;\n    this.dataCallback = dataCallback;\n    this.openCallback = openCallback;\n    this.closeCallback = closeCallback;\n    this.resetCallback = resetCallback;\n  }\n\n  processBaseURL(inBaseURL: string) {\n    let end = inBaseURL.lastIndexOf('/');\n    if (end < 0) {\n      end = inBaseURL.length;\n    }\n    return inBaseURL.slice(0, end);\n  }\n\n  dataToJsonChunks(inputJson: any) {\n    const splitStrings = inputJson.split('\\n');\n    const last = splitStrings[splitStrings.length - 1];\n    if (last) {\n      splitStrings.pop();\n    }\n    // get rid of the trailing ]\n    while (splitStrings.length > 0 && splitStrings[splitStrings.length - 1].length < 3) {\n      if (splitStrings.pop() === ']') {\n        this.id = 0;\n      }\n    }\n    // or the leading [\n    if (splitStrings.length > 0 && splitStrings[0].length < 3) {\n      splitStrings.shift();\n    }\n    for (let i = 0; i < splitStrings.length; ++i) {\n      if (splitStrings[i].endsWith(',')) {\n        splitStrings[i] = splitStrings[i].substr(0, splitStrings[i].length - 1);\n      }\n    }\n    return splitStrings;\n  }\n\n  async retryConnection() {\n    if (this.retryCount++ < MAX_RETRY_COUNT) {\n      await new Promise((resolve) => setTimeout(() => {\n        this.resetCallback();\n        this.initiateConnection();\n        resolve();\n      }, 3000));\n    }\n  }\n\n  async processStrings(stringArray: string[]) {\n    let data = null;\n    for (let i = 0; i < stringArray.length; ++i) {\n      data = JSON.parse(stringArray[i]);\n      if (data) {\n        if (data['end']) {\n          close();\n        } else if (data['id'] && Number(data['id']) !== this.id) {\n          warn('Reconnecting, new server detected');\n          this.endConnection();\n          await this.retryConnection();\n        } else if (data['hb'] && Number(data['id']) === this.id) {\n          this.send({ 'hb': true });\n        } else if (!this.hasCloseSignal) {\n          this.dataCallback(data);\n        }\n      }\n    }\n  }\n\n  // responds whenever data is available on the request\n  // fires off a new listening request afterwards\n  async onReadyStateChange(request: XMLHttpRequest) {\n    let thisSize;\n    if (request.readyState >= 3) {\n      try {\n        thisSize = request.responseText.length;\n      } catch (e) {\n        log('caught exception');\n        return;\n      }\n      if (thisSize > 0) {\n        try {\n          const stringArray = this.dataToJsonChunks(request.responseText);\n          if (this.id === 0 && stringArray.length > 0) {\n            const data = JSON.parse(stringArray.shift());\n            this.id = data['id'];\n            this.retryCount = 0;\n          }\n          this.processStrings(stringArray);\n        } catch (e) {\n        }\n      }\n      if (!this.hasCloseSignal) {\n        await this.fireOffRequest();\n      }\n    }\n  }\n\n  // initiates the listening request and calls itself to continue\n  // listening until session completes\n  async fireOffRequest() {\n    return new Promise((resolve, reject) => {\n      this.request = new XMLHttpRequest();\n      this.request.withCredentials = this.useCredentials;\n      let params;\n      if (this.id !== 0) {\n        params = { 'id': String(this.id), 'uc': String(this.reqCounter) };\n      } else {\n        params = { 'uc': String(this.reqCounter) };\n      }\n\n      const urlWithParams = appendQueryParameters(this.url, params);\n\n      this.reqCounter++;\n      this.request.open('GET', urlWithParams, true);\n      this.request.setRequestHeader('Cache-Control', 'no-cache');\n      this.request.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n      this.request.onreadystatechange = () => {\n        this.onReadyStateChange(this.request);\n      };\n\n      const reset = async () => {\n        reject();\n        this.endConnection();\n        while (this.hasCloseSignal && this.retryCount < MAX_RETRY_COUNT) {\n          await this.retryConnection();\n        }\n      };\n\n      this.request.addEventListener('error', reset);\n\n      this.request.addEventListener('timeout', reset);\n\n      this.request.addEventListener('load', () => {\n        // request successfully opened\n        if (this.openCallback) {\n          this.openCallback();\n        }\n        resolve();\n      });\n\n      this.request.send();\n    });\n  }\n\n  initiateConnection() {\n    const queryParameters = getState('wvsQueryParameters');\n    queryParameters['bcid'] = makeId(8);\n    setState('wvsQueryParameters', queryParameters);\n\n    this.id = 0;\n    this.reqCounter = 0;\n    this.hasCloseSignal = false;\n    return this.fireOffRequest();\n  }\n\n  send(inData: any) {\n    const xmlHttp = new XMLHttpRequest();\n    xmlHttp.withCredentials = this.useCredentials;\n\n    const urlWithId = appendQueryParameters(this.url, { 'id': String(this.id) });\n    const formData = new FormData();\n    formData.append('data', JSON.stringify(inData));\n    xmlHttp.addEventListener('error', () => {\n      this.endConnection();\n    });\n\n    xmlHttp.open('POST', urlWithId);\n    xmlHttp.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xmlHttp.send(formData);\n  }\n\n  endConnection() {\n    this.id = 0;\n    this.hasCloseSignal = true;\n\n    if (this.closeCallback) {\n      this.closeCallback();\n    }\n\n    this.request.abort();\n    return Promise.resolve();\n  }\n}\n\n// generates websocket or http long polling connection\nclass WebViewerServerConnectionFactory {\n  constructorBaseURL: string;\n  target: string;\n  useCredentials: boolean;\n\n  constructor(\n    constructorBaseURL: string,\n    target: string,\n    useCredentials: boolean,\n  ) {\n    this.constructorBaseURL = constructorBaseURL;\n    this.target = target;\n    this.useCredentials = useCredentials;\n  }\n\n  public generateConnection(\n    useWebsocket = true,\n    dataCallback: DataCallback = null,\n    openCallback: () => void = null,\n    closeCallback: () => void = null,\n    resetCallback: () => void = null,\n  ) {\n    if (useWebsocket) {\n      return new WebsocketConnection(\n        this.constructorBaseURL,\n        this.target,\n        dataCallback,\n        openCallback,\n        closeCallback,\n        resetCallback\n      );\n    }\n    return new HttpConnection(\n      this.constructorBaseURL,\n      this.target,\n      this.useCredentials,\n      dataCallback,\n      openCallback,\n      closeCallback,\n      resetCallback\n    );\n  }\n}\n\nexport default WebViewerServerConnectionFactory;\n"],"mappings":";AAAA;AC+KA;AAuCA;AAlKA;AA0CA;AAkDA;AAqGA;AA8CA;AA8BA;AAmCA;AAoCA;AAyCA;AAgCA;AAiCA;AAuDA;AAgDA;AA2CA;AAoCA;AAmCA;AA+BA;AA4BA;AAuBA;AAgCA;AA8BA;AAyBA;AAuCA;AA4CA;AA6BA;AA0CA;AAiCA;AA0CA;AAoCA;ACvjCA;AAyBA;AAoBA;AA4DA;AAkCA;AAiBA;AA0BA;AAyCA;AASA;AAmCA;","sourceRoot":""}