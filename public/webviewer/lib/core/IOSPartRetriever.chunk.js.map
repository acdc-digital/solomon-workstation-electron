{"version":3,"file":"IOSPartRetriever.chunk.js","sources":["webpack:///IOSPartRetriever.chunk.js","webpack:///./src/core/src/namespaces/PartRetrievers/IOSPartRetriever.ts"],"sourcesContent":["(window[\"wpCoreControlsBundle\"] = window[\"wpCoreControlsBundle\"] || []).push([[6],{\n\n/***/ 526:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _util_constants_status__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(293);\n/* harmony import */ var _HttpPartRetriever__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(518);\n/* harmony import */ var _util_Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);\n/* harmony import */ var _Exports__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(439);\n\n\n\n\n\n// contains the callbacks of the functions that are waiting to execute\nvar callbackMap = {};\n/**\n * Construct a new IOSRangeRequest.\n * @name IOSRangeRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param range The range of bytes to load, inclusive.\n * @param range.start Start\n * @param [range.stop] Stop\n * @ignore\n */\nvar IOSRangeRequest = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(IOSRangeRequest, _super);\n    function IOSRangeRequest(url, range) {\n        var _this = _super.call(this, url, range) || this;\n        _this.url = url;\n        _this.range = range;\n        _this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_1__[/* RequestStatus */ \"a\"]['NOT_STARTED'];\n        return _this;\n    }\n    IOSRangeRequest.prototype.start = function (callback) {\n        var me = this;\n        var success = function (data) {\n            // convert from base64 to byte array\n            var decoded = atob(data);\n            var i;\n            var il = decoded.length;\n            var bytes = new Uint8Array(il);\n            for (i = 0; i < il; ++i) {\n                bytes[i] = decoded.charCodeAt(i);\n            }\n            var n = bytes.length;\n            var finalData = '';\n            var arr;\n            var j = 0;\n            if (Object(_util_Utils__WEBPACK_IMPORTED_MODULE_3__[/* typedArrayApply */ \"r\"])()) {\n                while (j < n) {\n                    arr = bytes.subarray(j, j + 1024);\n                    j += 1024;\n                    finalData += String.fromCharCode.apply(null, arr);\n                }\n            }\n            else {\n                // if we can't call apply with a typed array just use a normal array\n                arr = new Array(1024);\n                while (j < n) {\n                    var k = 0;\n                    for (var end = Math.min(j + 1024, n); j < end; k++, j++) {\n                        arr[k] = bytes[j];\n                    }\n                    finalData += String.fromCharCode.apply(null, k < 1024 ? arr.slice(0, k) : arr);\n                }\n            }\n            me.success(finalData, callback);\n        };\n        var fail = function () {\n            me.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_1__[/* RequestStatus */ \"a\"]['ERROR'];\n            callback({\n                code: me.status,\n            });\n        };\n        callbackMap[this.range.start] = {\n            success: success,\n            fail: fail,\n        };\n        var iframe = document.createElement('IFRAME');\n        iframe.setAttribute('src', this.url);\n        document.documentElement.appendChild(iframe);\n        iframe.parentNode.removeChild(iframe);\n        iframe = null;\n        this.status = _util_constants_status__WEBPACK_IMPORTED_MODULE_1__[/* RequestStatus */ \"a\"]['STARTED'];\n        me.getNextRequest();\n    };\n    return IOSRangeRequest;\n}(_HttpPartRetriever__WEBPACK_IMPORTED_MODULE_2__[\"ByteRangeRequest\"]));\n/**\n * Constructs a new IOSPartRetriever.\n * IOSPartRetriever retrieves Document parts asynchronously from a .xod that exists locally in an iOS app.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a http part retriever.\n * @name IOSPartRetriever\n * @extends Core.PartRetrievers.HttpPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {p: \"pass\", type: \"aes\"} where is p is the password\n * @ignore\n */\nvar IOSPartRetriever = /** @class */ (function (_super) {\n    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ \"c\"])(IOSPartRetriever, _super);\n    function IOSPartRetriever(url, cacheHint, decrypt, decryptOptions) {\n        var _this = _super.call(this, url, cacheHint, decrypt, decryptOptions) || this;\n        _this.rangeRequest = IOSRangeRequest;\n        return _this;\n    }\n    IOSPartRetriever.prototype.createRangeURL = function (url, range) {\n        return url + \"#\" + range.start + \"&\" + (range.stop ? range.stop : '');\n    };\n    IOSPartRetriever.partSuccess = function (data, startRange) {\n        var callback = callbackMap[startRange];\n        delete callbackMap[startRange];\n        callback.success(data);\n    };\n    IOSPartRetriever.partFail = function (data, startRange) {\n        var callback = callbackMap[startRange];\n        delete callbackMap[startRange];\n        callback.fail();\n    };\n    return IOSPartRetriever;\n}(_HttpPartRetriever__WEBPACK_IMPORTED_MODULE_2__[\"default\"]));\nObject(_Exports__WEBPACK_IMPORTED_MODULE_4__[/* exportEventHandler */ \"a\"])(IOSPartRetriever);\nObject(_Exports__WEBPACK_IMPORTED_MODULE_4__[/* exportPartRetrieverFunctions */ \"b\"])(IOSPartRetriever);\n/* harmony default export */ __webpack_exports__[\"default\"] = (IOSPartRetriever);\n\n\n/***/ })\n\n}]);","import { RequestStatus } from '../../util/constants/status';\nimport HttpPartRetriever, { ByteRangeRequest, HttpPartRetrieverCallback } from './HttpPartRetriever';\nimport { PartRetrieverRange, PartRetrieverDecrypt, PartRetrieverDecryptOptions } from './PartRetriever';\nimport { CacheHinting } from './constants';\nimport { typedArrayApply } from '../../util/Utils';\nimport { exportEventHandler, exportPartRetrieverFunctions } from '../Exports';\n\n// contains the callbacks of the functions that are waiting to execute\nconst callbackMap: {\n  [key: number]: {\n    success: Function;\n    fail: Function;\n  };\n} = {};\n\n/**\n * Construct a new IOSRangeRequest.\n * @name IOSRangeRequest\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param range The range of bytes to load, inclusive.\n * @param range.start Start\n * @param [range.stop] Stop\n * @ignore\n */\nclass IOSRangeRequest extends ByteRangeRequest {\n  url: string;\n\n  range: PartRetrieverRange;\n\n  constructor(url: string, range: PartRetrieverRange) {\n    super(url, range);\n    this.url = url;\n    this.range = range;\n\n    this.status = RequestStatus['NOT_STARTED'];\n  }\n\n  start(callback: HttpPartRetrieverCallback) {\n    const me = this;\n\n    const success = function(data: string) {\n      // convert from base64 to byte array\n      const decoded = atob(data);\n      let i;\n      const il = decoded.length;\n      const bytes = new Uint8Array(il);\n\n      for (i = 0; i < il; ++i) {\n        bytes[i] = decoded.charCodeAt(i);\n      }\n\n      const n = bytes.length;\n      let finalData = '';\n      let arr;\n      let j = 0;\n\n      if (typedArrayApply()) {\n        while (j < n) {\n          arr = bytes.subarray(j, j + 1024);\n          j += 1024;\n          finalData += String.fromCharCode.apply(null, arr);\n        }\n      } else {\n        // if we can't call apply with a typed array just use a normal array\n        arr = new Array(1024);\n\n        while (j < n) {\n          let k = 0;\n          for (const end = Math.min(j + 1024, n); j < end; k++, j++) {\n            arr[k] = bytes[j];\n          }\n          finalData += String.fromCharCode.apply(null, k < 1024 ? arr.slice(0, k) : arr);\n        }\n      }\n\n      me.success(finalData, callback);\n    };\n\n    const fail = function() {\n      me.status = RequestStatus['ERROR'];\n      callback({\n        code: me.status,\n      });\n    };\n\n    callbackMap[this.range.start] = {\n      success: success,\n      fail: fail,\n    };\n\n    let iframe = document.createElement('IFRAME');\n    iframe.setAttribute('src', this.url);\n    document.documentElement.appendChild(iframe);\n    iframe.parentNode.removeChild(iframe);\n    iframe = null;\n\n    this.status = RequestStatus['STARTED'];\n\n    me.getNextRequest();\n  }\n}\n\n/**\n * Constructs a new IOSPartRetriever.\n * IOSPartRetriever retrieves Document parts asynchronously from a .xod that exists locally in an iOS app.\n * <br/><br/>\n * <b>Note</b>: As of version 6.0, directly constructing a part retriever is deprecated and the capability will be removed in a future version. Please use the {@link Core.PartRetrievers#getPartRetriever} function instead.\n * @class Represents a http part retriever.\n * @name IOSPartRetriever\n * @extends Core.PartRetrievers.HttpPartRetriever\n * @memberof Core.PartRetrievers\n * @param {string} url The URL of the file to load. May be relative to the current page.\n * @param {Core.PartRetrievers.CacheHinting} cacheHint The type of cache hinting to use\n * @param {function} decrypt Function to be called to decrypt a part of the file\n * @param {Object} decryptOptions An object with options for the decryption e.g. {p: \"pass\", type: \"aes\"} where is p is the password\n * @ignore\n */\n\nclass IOSPartRetriever extends HttpPartRetriever {\n  constructor(url: string, cacheHint: CacheHinting, decrypt: PartRetrieverDecrypt, decryptOptions: PartRetrieverDecryptOptions) {\n    super(url, cacheHint, decrypt, decryptOptions);\n\n    this.rangeRequest = IOSRangeRequest;\n  }\n\n  createRangeURL(url: string, range: PartRetrieverRange) {\n    return `${url}#${range.start}&${range.stop ? range.stop : ''}`;\n  }\n\n  static partSuccess = function(data: any, startRange: number) {\n    const callback = callbackMap[startRange];\n    delete callbackMap[startRange];\n    callback.success(data);\n  }\n\n  static partFail = function(data: any, startRange: number) {\n    const callback = callbackMap[startRange];\n    delete callbackMap[startRange];\n    callback.fail();\n  }\n}\n\nexportEventHandler(IOSPartRetriever);\nexportPartRetrieverFunctions(IOSPartRetriever);\n\nexport default IOSPartRetriever;\n"],"mappings":";AAAA;ACoGA;","sourceRoot":""}